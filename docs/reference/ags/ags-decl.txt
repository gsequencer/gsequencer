<MACRO>
<NAME>ALSA_PCM_NEW_HW_PARAMS_API</NAME>
#define ALSA_PCM_NEW_HW_PARAMS_API
</MACRO>
<MACRO>
<NAME>AGS_RT_PRIORITY</NAME>
#define AGS_RT_PRIORITY (49)
</MACRO>
<FUNCTION>
<NAME>ags_main_quit</NAME>
<RETURNS>void  </RETURNS>
AgsApplicationContext *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TURTLE</NAME>
#define AGS_TYPE_TURTLE                (ags_turtle_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TURTLE</NAME>
#define AGS_TURTLE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TURTLE, AgsTurtle))
</MACRO>
<MACRO>
<NAME>AGS_TURTLE_CLASS</NAME>
#define AGS_TURTLE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_TURTLE, AgsTurtleClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_TURTLE</NAME>
#define AGS_IS_TURTLE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_TURTLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_TURTLE_CLASS</NAME>
#define AGS_IS_TURTLE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_TURTLE))
</MACRO>
<MACRO>
<NAME>AGS_TURTLE_GET_CLASS</NAME>
#define AGS_TURTLE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_TURTLE, AgsTurtleClass))
</MACRO>
<MACRO>
<NAME>AGS_TURTLE_DEFAULT_ENCODING</NAME>
#define AGS_TURTLE_DEFAULT_ENCODING "UTF-8\0"
</MACRO>
<ENUM>
<NAME>AgsTurtleFlags</NAME>
typedef enum{
  AGS_TURTLE_READ_SUBJECT    = 1,
  AGS_TURTLE_READ_VERB       = 1 << 1,
  AGS_TURTLE_READ_OBJECT     = 1 << 2,
  AGS_TURTLE_TRIPLE_END      = 1 << 3,
}AgsTurtleFlags;
</ENUM>
<STRUCT>
<NAME>AgsTurtle</NAME>
struct _AgsTurtle
{
  GObject object;

  guint flags;
  
  gchar *filename;
  
  xmlDoc *doc;
};
</STRUCT>
<STRUCT>
<NAME>AgsTurtleClass</NAME>
struct _AgsTurtleClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_turtle_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_turtle_find_xpath</NAME>
<RETURNS>GList * </RETURNS>
AgsTurtle *turtle, gchar *xpath 
</FUNCTION>
<FUNCTION>
<NAME>ags_turtle_load</NAME>
<RETURNS>void  </RETURNS>
AgsTurtle *turtle 
</FUNCTION>
<FUNCTION>
<NAME>ags_turtle_new</NAME>
<RETURNS>AgsTurtle * </RETURNS>
gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>ags_container_add_all</NAME>
<RETURNS>void  </RETURNS>
GtkContainer *container, GList *list 
</FUNCTION>
<FUNCTION>
<NAME>ags_parameter_grow</NAME>
<RETURNS>GParameter *</RETURNS>
GType type, GParameter *params, guint *n_params, ... 
</FUNCTION>
<FUNCTION>
<NAME>ags_list_free_and_free_link</NAME>
<RETURNS>void  </RETURNS>
GList *list 
</FUNCTION>
<FUNCTION>
<NAME>ags_list_free_and_unref_link</NAME>
<RETURNS>void  </RETURNS>
GList *list 
</FUNCTION>
<FUNCTION>
<NAME>ags_list_duplicate_list</NAME>
<RETURNS>void  </RETURNS>
gpointer entry, gpointer target 
</FUNCTION>
<FUNCTION>
<NAME>ags_combo_box_text_remove_all</NAME>
<RETURNS>void  </RETURNS>
GtkComboBoxText *combo_box 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_HINDICATOR</NAME>
#define AGS_TYPE_HINDICATOR                (ags_hindicator_get_type())
</MACRO>
<MACRO>
<NAME>AGS_HINDICATOR</NAME>
#define AGS_HINDICATOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_INDICATOR, AgsHIndicator))
</MACRO>
<MACRO>
<NAME>AGS_HINDICATOR_CLASS</NAME>
#define AGS_HINDICATOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_INDICATOR, AgsHIndicatorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_HINDICATOR</NAME>
#define AGS_IS_HINDICATOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_INDICATOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_HINDICATOR_CLASS</NAME>
#define AGS_IS_HINDICATOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_INDICATOR))
</MACRO>
<MACRO>
<NAME>AGS_HINDICATOR_GET_CLASS</NAME>
#define AGS_HINDICATOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_INDICATOR, AgsHIndicatorClass))
</MACRO>
<STRUCT>
<NAME>AgsHIndicator</NAME>
struct _AgsHIndicator
{
  AgsIndicator indicator;
};
</STRUCT>
<STRUCT>
<NAME>AgsHIndicatorClass</NAME>
struct _AgsHIndicatorClass
{
  GtkWidgetClass indicator;
};
</STRUCT>
<FUNCTION>
<NAME>ags_hindicator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_hindicator_new</NAME>
<RETURNS>AgsHIndicator * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MENU</NAME>
#define AGS_TYPE_MENU                (ags_menu_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MENU</NAME>
#define AGS_MENU(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MENU, AgsMenu))
</MACRO>
<MACRO>
<NAME>AGS_MENU_CLASS</NAME>
#define AGS_MENU_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MENU, AgsMenuClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MENU</NAME>
#define AGS_IS_MENU(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_MENU))
</MACRO>
<MACRO>
<NAME>AGS_IS_MENU_CLASS</NAME>
#define AGS_IS_MENU_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_MENU))
</MACRO>
<MACRO>
<NAME>AGS_MENU_GET_CLASS</NAME>
#define AGS_MENU_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_MENU, AgsMenuClass))
</MACRO>
<STRUCT>
<NAME>AgsMenu</NAME>
struct _AgsMenu
{
  GtkWindow window;

  AgsTable *table;
};
</STRUCT>
<STRUCT>
<NAME>AgsMenuClass</NAME>
struct _AgsMenuClass
{
  GtkWindowClass window;
};
</STRUCT>
<FUNCTION>
<NAME>ags_menu_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_new</NAME>
<RETURNS>AgsMenu * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_gui_init_context</NAME>
<RETURNS>void  </RETURNS>
AgsApplicationContext *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_EXPANDER</NAME>
#define AGS_TYPE_EXPANDER                (ags_expander_get_type())
</MACRO>
<MACRO>
<NAME>AGS_EXPANDER</NAME>
#define AGS_EXPANDER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_EXPANDER, AgsExpander))
</MACRO>
<MACRO>
<NAME>AGS_EXPANDER_CLASS</NAME>
#define AGS_EXPANDER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_EXPANDER, AgsExpanderClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_EXPANDER</NAME>
#define AGS_IS_EXPANDER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_EXPANDER))
</MACRO>
<MACRO>
<NAME>AGS_IS_EXPANDER_CLASS</NAME>
#define AGS_IS_EXPANDER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_EXPANDER))
</MACRO>
<MACRO>
<NAME>AGS_EXPANDER_GET_CLASS</NAME>
#define AGS_EXPANDER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_EXPANDER, AgsExpanderClass))
</MACRO>
<MACRO>
<NAME>AGS_EXPANDER_CHILD</NAME>
#define AGS_EXPANDER_CHILD(ptr) ((AgsExpanderChild *)(ptr))
</MACRO>
<ENUM>
<NAME>AgsExpanderFlags</NAME>
typedef enum{
  AGS_EXPANDER_DRAW_BORDER        = 1,
}AgsExpanderFlags;
</ENUM>
<STRUCT>
<NAME>AgsExpander</NAME>
struct _AgsExpander
{
  GtkExpander expander;

  guint flags;

  GtkTable *table;

  GList *children;
};
</STRUCT>
<STRUCT>
<NAME>AgsExpanderClass</NAME>
struct _AgsExpanderClass
{
  GtkExpanderClass expander;
};
</STRUCT>
<STRUCT>
<NAME>AgsExpanderChild</NAME>
struct _AgsExpanderChild
{
  GtkWidget *child;

  guint x;
  guint y;

  guint width;
  guint height;
};
</STRUCT>
<FUNCTION>
<NAME>ags_expander_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_expander_child_alloc</NAME>
<RETURNS>AgsExpanderChild * </RETURNS>
guint x, guint y, guint width, guint height 
</FUNCTION>
<FUNCTION>
<NAME>ags_expander_child_find</NAME>
<RETURNS>AgsExpanderChild * </RETURNS>
AgsExpander *expander, GtkWidget *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_expander_add</NAME>
<RETURNS>void  </RETURNS>
AgsExpander *expander, GtkWidget *widget, guint x, guint y, guint width, guint height 
</FUNCTION>
<FUNCTION>
<NAME>ags_expander_remove</NAME>
<RETURNS>void  </RETURNS>
AgsExpander *expander, GtkWidget *widget 
</FUNCTION>
<FUNCTION>
<NAME>ags_expander_new</NAME>
<RETURNS>AgsExpander * </RETURNS>
guint width, guint height 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_WAVEFORM</NAME>
#define AGS_TYPE_WAVEFORM                (ags_waveform_get_type())
</MACRO>
<MACRO>
<NAME>AGS_WAVEFORM</NAME>
#define AGS_WAVEFORM(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_WAVEFORM, AgsWaveform))
</MACRO>
<MACRO>
<NAME>AGS_WAVEFORM_CLASS</NAME>
#define AGS_WAVEFORM_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_WAVEFORM, AgsWaveformClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_WAVEFORM</NAME>
#define AGS_IS_WAVEFORM(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_WAVEFORM))
</MACRO>
<MACRO>
<NAME>AGS_IS_WAVEFORM_CLASS</NAME>
#define AGS_IS_WAVEFORM_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_WAVEFORM))
</MACRO>
<MACRO>
<NAME>AGS_WAVEFORM_GET_CLASS</NAME>
#define AGS_WAVEFORM_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_WAVEFORM, AgsWaveformClass))
</MACRO>
<STRUCT>
<NAME>AgsWaveform</NAME>
struct _AgsWaveform
{
  GtkWidget widget;
};
</STRUCT>
<STRUCT>
<NAME>AgsWaveformClass</NAME>
struct _AgsWaveformClass
{
  GtkWidgetClass widget;
};
</STRUCT>
<FUNCTION>
<NAME>ags_waveform_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_waveform_new</NAME>
<RETURNS>AgsWaveform * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TABLE</NAME>
#define AGS_TYPE_TABLE                (ags_table_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TABLE</NAME>
#define AGS_TABLE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TABLE, AgsTable))
</MACRO>
<MACRO>
<NAME>AGS_TABLE_CLASS</NAME>
#define AGS_TABLE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_TABLE, AgsTableClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_TABLE</NAME>
#define AGS_IS_TABLE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_TABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_TABLE_CLASS</NAME>
#define AGS_IS_TABLE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_TABLE))
</MACRO>
<MACRO>
<NAME>AGS_TABLE_GET_CLASS</NAME>
#define AGS_TABLE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_TABLE, AgsTableClass))
</MACRO>
<STRUCT>
<NAME>AgsTable</NAME>
struct _AgsTable
{
  GtkTable table;
};
</STRUCT>
<STRUCT>
<NAME>AgsTableClass</NAME>
struct _AgsTableClass
{
  GtkTableClass table;
};
</STRUCT>
<FUNCTION>
<NAME>ags_table_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_table_new</NAME>
<RETURNS>AgsTable * </RETURNS>
guint row, guint columns, gboolean homogeneous 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TIMEBAR</NAME>
#define AGS_TYPE_TIMEBAR                (ags_timebar_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TIMEBAR</NAME>
#define AGS_TIMEBAR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TIMEBAR, AgsTimebar))
</MACRO>
<MACRO>
<NAME>AGS_TIMEBAR_CLASS</NAME>
#define AGS_TIMEBAR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_TIMEBAR, AgsTimebarClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_TIMEBAR</NAME>
#define AGS_IS_TIMEBAR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_TIMEBAR))
</MACRO>
<MACRO>
<NAME>AGS_IS_TIMEBAR_CLASS</NAME>
#define AGS_IS_TIMEBAR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_TIMEBAR))
</MACRO>
<MACRO>
<NAME>AGS_TIMEBAR_GET_CLASS</NAME>
#define AGS_TIMEBAR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_TIMEBAR, AgsTimebarClass))
</MACRO>
<STRUCT>
<NAME>AgsTimebar</NAME>
struct _AgsTimebar
{
  GtkRange range;
};
</STRUCT>
<STRUCT>
<NAME>AgsTimebarClass</NAME>
struct _AgsTimebarClass
{
  GtkRangeClass range;
};
</STRUCT>
<FUNCTION>
<NAME>ags_timebar_new</NAME>
<RETURNS>AgsTimebar * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_INDICATOR</NAME>
#define AGS_TYPE_INDICATOR                (ags_indicator_get_type())
</MACRO>
<MACRO>
<NAME>AGS_INDICATOR</NAME>
#define AGS_INDICATOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_INDICATOR, AgsIndicator))
</MACRO>
<MACRO>
<NAME>AGS_INDICATOR_CLASS</NAME>
#define AGS_INDICATOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_INDICATOR, AgsIndicatorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_INDICATOR</NAME>
#define AGS_IS_INDICATOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_INDICATOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_INDICATOR_CLASS</NAME>
#define AGS_IS_INDICATOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_INDICATOR))
</MACRO>
<MACRO>
<NAME>AGS_INDICATOR_GET_CLASS</NAME>
#define AGS_INDICATOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_INDICATOR, AgsIndicatorClass))
</MACRO>
<STRUCT>
<NAME>AgsIndicator</NAME>
struct _AgsIndicator
{
  GtkWidget widget;

  GtkAdjustment *adjustment;
};
</STRUCT>
<STRUCT>
<NAME>AgsIndicatorClass</NAME>
struct _AgsIndicatorClass
{
  GtkWidgetClass widget;
};
</STRUCT>
<FUNCTION>
<NAME>ags_indicator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_indicator_new</NAME>
<RETURNS>AgsIndicator * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_DIAL</NAME>
#define AGS_TYPE_DIAL                (ags_dial_get_type())
</MACRO>
<MACRO>
<NAME>AGS_DIAL</NAME>
#define AGS_DIAL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_DIAL, AgsDial))
</MACRO>
<MACRO>
<NAME>AGS_DIAL_CLASS</NAME>
#define AGS_DIAL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_DIAL, AgsDialClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_DIAL</NAME>
#define AGS_IS_DIAL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_DIAL))
</MACRO>
<MACRO>
<NAME>AGS_IS_DIAL_CLASS</NAME>
#define AGS_IS_DIAL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_DIAL))
</MACRO>
<MACRO>
<NAME>AGS_DIAL_GET_CLASS</NAME>
#define AGS_DIAL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_DIAL, AgsDialClass))
</MACRO>
<MACRO>
<NAME>AGS_DIAL_DEFAULT_PRECISION</NAME>
#define AGS_DIAL_DEFAULT_PRECISION (8.0)
</MACRO>
<ENUM>
<NAME>AgsDialFlags</NAME>
typedef enum{
  AGS_DIAL_WITH_BUTTONS           = 1,
  AGS_DIAL_MOUSE_BUTTON_PRESSED   = 1 <<  1,
  AGS_DIAL_BUTTON_DOWN_PRESSED    = 1 <<  2,
  AGS_DIAL_BUTTON_UP_PRESSED      = 1 <<  3,
  AGS_DIAL_MOTION_CAPTURING_INIT  = 1 <<  4,
  AGS_DIAL_MOTION_CAPTURING       = 1 <<  5,
  AGS_DIAL_IDLE                   = 1 <<  6,
}AgsDialFlags;
</ENUM>
<STRUCT>
<NAME>AgsDial</NAME>
struct _AgsDial
{
  GtkWidget widget;

  guint flags;

  guint radius;
  guint outline_strength;
  guint scale_precision;

  guint font_size;
  gint button_width;
  gint button_height;
  gint margin_left;
  gint margin_right;

  gdouble tolerance;
  gdouble negated_tolerance;

  gint sleep_interval;

  GtkAdjustment *adjustment;

  gdouble gravity_x;
  gdouble gravity_y;
  gdouble current_x;
  gdouble current_y;
};
</STRUCT>
<STRUCT>
<NAME>AgsDialClass</NAME>
struct _AgsDialClass
{
  GtkWidgetClass widget;
};
</STRUCT>
<FUNCTION>
<NAME>ags_dial_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_dial_new</NAME>
<RETURNS>AgsDial * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CARTESIAN</NAME>
#define AGS_TYPE_CARTESIAN                (ags_cartesian_get_type())
</MACRO>
<MACRO>
<NAME>AGS_CARTESIAN</NAME>
#define AGS_CARTESIAN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CARTESIAN, AgsCartesian))
</MACRO>
<MACRO>
<NAME>AGS_CARTESIAN_CLASS</NAME>
#define AGS_CARTESIAN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_CARTESIAN, AgsCartesianClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_CARTESIAN</NAME>
#define AGS_IS_CARTESIAN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_CARTESIAN))
</MACRO>
<MACRO>
<NAME>AGS_IS_CARTESIAN_CLASS</NAME>
#define AGS_IS_CARTESIAN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_CARTESIAN))
</MACRO>
<MACRO>
<NAME>AGS_CARTESIAN_GET_CLASS</NAME>
#define AGS_CARTESIAN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_CARTESIAN, AgsCartesianClass))
</MACRO>
<STRUCT>
<NAME>AgsCartesian</NAME>
struct _AgsCartesian
{
  GtkWidget widget;
};
</STRUCT>
<STRUCT>
<NAME>AgsCartesianClass</NAME>
struct _AgsCartesianClass
{
  GtkWidgetClass widget;
};
</STRUCT>
<FUNCTION>
<NAME>ags_cartesian_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_cartesian_new</NAME>
<RETURNS>AgsCartesian * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MENU_ITEM</NAME>
#define AGS_TYPE_MENU_ITEM                (ags_menu_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MENU_ITEM</NAME>
#define AGS_MENU_ITEM(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MENU_ITEM, AgsMenuItem))
</MACRO>
<MACRO>
<NAME>AGS_MENU_ITEM_CLASS</NAME>
#define AGS_MENU_ITEM_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MENU_ITEM, AgsMenuItemClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MENU_ITEM</NAME>
#define AGS_IS_MENU_ITEM(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_MENU_ITEM))
</MACRO>
<MACRO>
<NAME>AGS_IS_MENU_ITEM_CLASS</NAME>
#define AGS_IS_MENU_ITEM_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_MENU_ITEM))
</MACRO>
<MACRO>
<NAME>AGS_MENU_ITEM_GET_CLASS</NAME>
#define AGS_MENU_ITEM_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_MENU_ITEM, AgsMenuItemClass))
</MACRO>
<STRUCT>
<NAME>AgsMenuItem</NAME>
struct _AgsMenuItem
{
  AgsTable table;
};
</STRUCT>
<STRUCT>
<NAME>AgsMenuItemClass</NAME>
struct _AgsMenuItemClass
{
  AgsTableClass table;
};
</STRUCT>
<FUNCTION>
<NAME>ags_menu_item_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_item_new</NAME>
<RETURNS>AgsMenuItem * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_VINDICATOR</NAME>
#define AGS_TYPE_VINDICATOR                (ags_vindicator_get_type())
</MACRO>
<MACRO>
<NAME>AGS_VINDICATOR</NAME>
#define AGS_VINDICATOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_INDICATOR, AgsVIndicator))
</MACRO>
<MACRO>
<NAME>AGS_VINDICATOR_CLASS</NAME>
#define AGS_VINDICATOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_INDICATOR, AgsVIndicatorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_VINDICATOR</NAME>
#define AGS_IS_VINDICATOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_INDICATOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_VINDICATOR_CLASS</NAME>
#define AGS_IS_VINDICATOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_INDICATOR))
</MACRO>
<MACRO>
<NAME>AGS_VINDICATOR_GET_CLASS</NAME>
#define AGS_VINDICATOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_INDICATOR, AgsVIndicatorClass))
</MACRO>
<STRUCT>
<NAME>AgsVIndicator</NAME>
struct _AgsVIndicator
{
  AgsIndicator indicator;
};
</STRUCT>
<STRUCT>
<NAME>AgsVIndicatorClass</NAME>
struct _AgsVIndicatorClass
{
  GtkWidgetClass indicator;
};
</STRUCT>
<FUNCTION>
<NAME>ags_vindicator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_vindicator_new</NAME>
<RETURNS>AgsVIndicator * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RULER</NAME>
#define AGS_TYPE_RULER                (ags_ruler_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RULER</NAME>
#define AGS_RULER(obj)                (G_TYPE_CHECK_INSTANCE_CAST(obj, AGS_TYPE_RULER, AgsRuler))
</MACRO>
<MACRO>
<NAME>AGS_RULER_CLASS</NAME>
#define AGS_RULER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_RULER, AgsRulerClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RULER</NAME>
#define AGS_IS_RULER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_RULER))
</MACRO>
<MACRO>
<NAME>AGS_IS_RULER_CLASS</NAME>
#define AGS_IS_RULER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_RULER))
</MACRO>
<MACRO>
<NAME>AGS_RULER_GET_CLASS</NAME>
#define AGS_RULER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_RULER, AgsRulerClass))
</MACRO>
<MACRO>
<NAME>AGS_RULER_DEFAULT_STEP</NAME>
#define AGS_RULER_DEFAULT_STEP (16)
</MACRO>
<MACRO>
<NAME>AGS_RULER_LARGE_STEP</NAME>
#define AGS_RULER_LARGE_STEP (8.0)
</MACRO>
<MACRO>
<NAME>AGS_RULER_SMALL_STEP</NAME>
#define AGS_RULER_SMALL_STEP (6.0)
</MACRO>
<STRUCT>
<NAME>AgsRuler</NAME>
struct _AgsRuler
{
  GtkWidget widget;

  guint flags;

  guint font_size;

  GtkAdjustment *adjustment;

  guint step;

  gdouble factor;
  gdouble precision;
  gdouble scale_precision;
};
</STRUCT>
<STRUCT>
<NAME>AgsRulerClass</NAME>
struct _AgsRulerClass
{
  GtkWidgetClass widget;
};
</STRUCT>
<FUNCTION>
<NAME>ags_ruler_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_ruler_new</NAME>
<RETURNS>AgsRuler * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_OPTION_MENU</NAME>
#define AGS_TYPE_OPTION_MENU                (ags_option_menu_get_type())
</MACRO>
<MACRO>
<NAME>AGS_OPTION_MENU</NAME>
#define AGS_OPTION_MENU(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_OPTION_MENU, AgsOptionMenu))
</MACRO>
<MACRO>
<NAME>AGS_OPTION_MENU_CLASS</NAME>
#define AGS_OPTION_MENU_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_OPTION_MENU, AgsOptionMenuClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_OPTION_MENU</NAME>
#define AGS_IS_OPTION_MENU(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_OPTION_MENU))
</MACRO>
<MACRO>
<NAME>AGS_IS_OPTION_MENU_CLASS</NAME>
#define AGS_IS_OPTION_MENU_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_OPTION_MENU))
</MACRO>
<MACRO>
<NAME>AGS_OPTION_MENU_GET_CLASS</NAME>
#define AGS_OPTION_MENU_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_OPTION_MENU, AgsOptionMenuClass))
</MACRO>
<STRUCT>
<NAME>AgsOptionMenu</NAME>
struct _AgsOptionMenu
{
  GtkHBox hbox;

  GtkWidget *button;
  AgsTable *table;

  GtkWidget *menu;
  GList *active_item;
  GtkWidget *focus;
};
</STRUCT>
<STRUCT>
<NAME>AgsOptionMenuClass</NAME>
struct _AgsOptionMenuClass
{
  GtkHBoxClass hbox;

  void (*changed)(AgsOptionMenu *option_menu);
  void (*focus_changed)(AgsOptionMenu *option_menu);
};
</STRUCT>
<FUNCTION>
<NAME>ags_option_menu_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_option_menu_new</NAME>
<RETURNS>AgsOptionMenu * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_HTIMEBAR</NAME>
#define AGS_TYPE_HTIMEBAR                (ags_htimebar_get_type())
</MACRO>
<MACRO>
<NAME>AGS_HTIMEBAR</NAME>
#define AGS_HTIMEBAR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_HTIMEBAR, AgsHTimebar))
</MACRO>
<MACRO>
<NAME>AGS_HTIMEBAR_CLASS</NAME>
#define AGS_HTIMEBAR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_HTIMEBAR, AgsHTimebarClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_HTIMEBAR</NAME>
#define AGS_IS_HTIMEBAR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_HTIMEBAR))
</MACRO>
<MACRO>
<NAME>AGS_IS_HTIMEBAR_CLASS</NAME>
#define AGS_IS_HTIMEBAR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_HTIMEBAR))
</MACRO>
<MACRO>
<NAME>AGS_HTIMEBAR_GET_CLASS</NAME>
#define AGS_HTIMEBAR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_HTIMEBAR, AgsHTimebarClass))
</MACRO>
<STRUCT>
<NAME>AgsHTimebar</NAME>
struct _AgsHTimebar
{
  AgsTimebar range;
};
</STRUCT>
<STRUCT>
<NAME>AgsHTimebarClass</NAME>
struct _AgsHTimebarClass
{
  AgsTimebarClass timebar;
};
</STRUCT>
<FUNCTION>
<NAME>ags_htimebar_new</NAME>
<RETURNS>AgsHTimebar * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_EXPANDER_SET</NAME>
#define AGS_TYPE_EXPANDER_SET                (ags_expander_set_get_type())
</MACRO>
<MACRO>
<NAME>AGS_EXPANDER_SET</NAME>
#define AGS_EXPANDER_SET(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_EXPANDER_SET, AgsExpanderSet))
</MACRO>
<MACRO>
<NAME>AGS_EXPANDER_SET_CLASS</NAME>
#define AGS_EXPANDER_SET_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_EXPANDER_SET, AgsExpanderSetClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_EXPANDER_SET</NAME>
#define AGS_IS_EXPANDER_SET(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_EXPANDER_SET))
</MACRO>
<MACRO>
<NAME>AGS_IS_EXPANDER_SET_CLASS</NAME>
#define AGS_IS_EXPANDER_SET_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_EXPANDER_SET))
</MACRO>
<MACRO>
<NAME>AGS_EXPANDER_SET_GET_CLASS</NAME>
#define AGS_EXPANDER_SET_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_EXPANDER_SET, AgsExpanderSetClass))
</MACRO>
<MACRO>
<NAME>AGS_EXPANDER_SET_CHILD</NAME>
#define AGS_EXPANDER_SET_CHILD(ptr) ((AgsExpanderSetChild *)(ptr))
</MACRO>
<ENUM>
<NAME>AgsExpanderSetFlags</NAME>
typedef enum{
  AGS_EXPANDER_SET_DRAW_GHOST            = 1,
  AGS_EXPANDER_SET_DRAW_LEFT_ENDING      = 1 << 1,
  AGS_EXPANDER_SET_DRAW_RIGHT_ENDING     = 1 << 2,
  AGS_EXPANDER_SET_DRAW_LEFT_CONNECTOR   = 1 << 3,
  AGS_EXPANDER_SET_DRAW_RIGHT_CONNECTOR  = 1 << 4,
}AgsExpanderSetFlags;
</ENUM>
<STRUCT>
<NAME>AgsExpanderSet</NAME>
struct _AgsExpanderSet
{
  GtkTable table;

  guint flags;

  GList *ghost;
  GList *location;
};
</STRUCT>
<STRUCT>
<NAME>AgsExpanderSetClass</NAME>
struct _AgsExpanderSetClass
{
  GtkTableClass table;
};
</STRUCT>
<STRUCT>
<NAME>AgsExpanderSetChild</NAME>
struct _AgsExpanderSetChild
{
  GtkWidget *child;

  guint x;
  guint y;

  guint width;
  guint height;
};
</STRUCT>
<FUNCTION>
<NAME>ags_expander_set_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_expander_set_child_alloc</NAME>
<RETURNS>AgsExpanderSetChild * </RETURNS>
guint x, guint y, guint width, guint height 
</FUNCTION>
<FUNCTION>
<NAME>ags_expander_set_child_find</NAME>
<RETURNS>AgsExpanderSetChild * </RETURNS>
AgsExpanderSet *expander_set, GtkWidget *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_expander_set_set_flags</NAME>
<RETURNS>void  </RETURNS>
AgsExpanderSet *expander_set, guint flags 
</FUNCTION>
<FUNCTION>
<NAME>ags_expander_set_add</NAME>
<RETURNS>void  </RETURNS>
AgsExpanderSet *expander_set, GtkWidget *widget, guint x, guint y, guint width, guint height 
</FUNCTION>
<FUNCTION>
<NAME>ags_expander_set_remove</NAME>
<RETURNS>void  </RETURNS>
AgsExpanderSet *expander_set, GtkWidget *widget 
</FUNCTION>
<FUNCTION>
<NAME>ags_expander_set_new</NAME>
<RETURNS>AgsExpanderSet * </RETURNS>
guint width, guint height 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LED</NAME>
#define AGS_TYPE_LED                (ags_led_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LED</NAME>
#define AGS_LED(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LED, AgsLed))
</MACRO>
<MACRO>
<NAME>AGS_LED_CLASS</NAME>
#define AGS_LED_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LED, AgsLedClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LED</NAME>
#define AGS_IS_LED(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_LED))
</MACRO>
<MACRO>
<NAME>AGS_IS_LED_CLASS</NAME>
#define AGS_IS_LED_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_LED))
</MACRO>
<MACRO>
<NAME>AGS_LED_GET_CLASS</NAME>
#define AGS_LED_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_LED, AgsLedClass))
</MACRO>
<ENUM>
<NAME>AgsLedFlags</NAME>
typedef enum{
  AGS_LED_ACTIVE        = 1,
}AgsLedFlags;
</ENUM>
<STRUCT>
<NAME>AgsLed</NAME>
struct _AgsLed
{
  GtkBin bin;

  guint flags;
};
</STRUCT>
<STRUCT>
<NAME>AgsLedClass</NAME>
struct _AgsLedClass
{
  GtkBinClass bin;
};
</STRUCT>
<FUNCTION>
<NAME>ags_led_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_led_set_active</NAME>
<RETURNS>void  </RETURNS>
AgsLed *led 
</FUNCTION>
<FUNCTION>
<NAME>ags_led_unset_active</NAME>
<RETURNS>void  </RETURNS>
AgsLed *led 
</FUNCTION>
<FUNCTION>
<NAME>ags_led_new</NAME>
<RETURNS>AgsLed * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_APPLICABLE</NAME>
#define AGS_TYPE_APPLICABLE                    (ags_applicable_get_type())
</MACRO>
<MACRO>
<NAME>AGS_APPLICABLE</NAME>
#define AGS_APPLICABLE(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_APPLICABLE, AgsApplicable))
</MACRO>
<MACRO>
<NAME>AGS_APPLICABLE_INTERFACE</NAME>
#define AGS_APPLICABLE_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_APPLICABLE, AgsApplicableInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPLICABLE</NAME>
#define AGS_IS_APPLICABLE(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_APPLICABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPLICABLE_INTERFACE</NAME>
#define AGS_IS_APPLICABLE_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_APPLICABLE))
</MACRO>
<MACRO>
<NAME>AGS_APPLICABLE_GET_INTERFACE</NAME>
#define AGS_APPLICABLE_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_APPLICABLE, AgsApplicableInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsApplicable</NAME>
typedef void AgsApplicable;
</TYPEDEF>
<STRUCT>
<NAME>AgsApplicableInterface</NAME>
struct _AgsApplicableInterface
{
  GTypeInterface interface;
  
  void (*set_update)(AgsApplicable *applicable, gboolean update);
  void (*apply)(AgsApplicable *applicable);
  void (*reset)(AgsApplicable *applicable);
};
</STRUCT>
<FUNCTION>
<NAME>ags_applicable_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_applicable_set_update</NAME>
<RETURNS>void  </RETURNS>
AgsApplicable *applicable, gboolean update 
</FUNCTION>
<FUNCTION>
<NAME>ags_applicable_apply</NAME>
<RETURNS>void  </RETURNS>
AgsApplicable *applicable 
</FUNCTION>
<FUNCTION>
<NAME>ags_applicable_reset</NAME>
<RETURNS>void  </RETURNS>
AgsApplicable *applicable 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COUNTABLE</NAME>
#define AGS_TYPE_COUNTABLE                    (ags_countable_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COUNTABLE</NAME>
#define AGS_COUNTABLE(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COUNTABLE, AgsCountable))
</MACRO>
<MACRO>
<NAME>AGS_COUNTABLE_INTERFACE</NAME>
#define AGS_COUNTABLE_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_COUNTABLE, AgsCountableInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_COUNTABLE</NAME>
#define AGS_IS_COUNTABLE(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_COUNTABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_COUNTABLE_INTERFACE</NAME>
#define AGS_IS_COUNTABLE_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_COUNTABLE))
</MACRO>
<MACRO>
<NAME>AGS_COUNTABLE_GET_INTERFACE</NAME>
#define AGS_COUNTABLE_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_COUNTABLE, AgsCountableInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsCountable</NAME>
typedef void AgsCountable;
</TYPEDEF>
<STRUCT>
<NAME>AgsCountableInterface</NAME>
struct _AgsCountableInterface
{
  GTypeInterface interface;

  guint (*get_notation_counter)(AgsCountable *countable);
  guint (*get_sequencer_counter)(AgsCountable *countable);
};
</STRUCT>
<FUNCTION>
<NAME>ags_countable_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_countable_get_notation_counter</NAME>
<RETURNS>guint  </RETURNS>
AgsCountable *countable 
</FUNCTION>
<FUNCTION>
<NAME>ags_countable_get_sequencer_counter</NAME>
<RETURNS>guint  </RETURNS>
AgsCountable *countable 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PERSISTABLE</NAME>
#define AGS_TYPE_PERSISTABLE                    (ags_persistable_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PERSISTABLE</NAME>
#define AGS_PERSISTABLE(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PERSISTABLE, AgsPersistable))
</MACRO>
<MACRO>
<NAME>AGS_PERSISTABLE_INTERFACE</NAME>
#define AGS_PERSISTABLE_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_PERSISTABLE, AgsPersistableInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_PERSISTABLE</NAME>
#define AGS_IS_PERSISTABLE(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PERSISTABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_PERSISTABLE_INTERFACE</NAME>
#define AGS_IS_PERSISTABLE_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_PERSISTABLE))
</MACRO>
<MACRO>
<NAME>AGS_PERSISTABLE_GET_INTERFACE</NAME>
#define AGS_PERSISTABLE_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_PERSISTABLE, AgsPersistableInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsPersistable</NAME>
typedef void AgsPersistable;
</TYPEDEF>
<STRUCT>
<NAME>AgsPersistableInterface</NAME>
struct _AgsPersistableInterface
{
  GTypeInterface interface;
  
  AgsPersistable* (*read)(AgsPersistable *persistable, xmlDocPtr doc, xmlNodePtr node);
  void (*read_link)(AgsPersistable *persistable, xmlDocPtr doc, xmlNodePtr node);

  xmlNodePtr (*write)(AgsPersistable *persistable, xmlDocPtr doc);
  void (*write_link)(AgsPersistable *persistable, xmlDocPtr doc, xmlNodePtr node);
};
</STRUCT>
<FUNCTION>
<NAME>ags_persistable_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_persistable_read</NAME>
<RETURNS>AgsPersistable * </RETURNS>
AgsPersistable *persistable, xmlDocPtr doc, xmlNodePtr node 
</FUNCTION>
<FUNCTION>
<NAME>ags_persistable_read_link</NAME>
<RETURNS>void  </RETURNS>
AgsPersistable *persistable, xmlDocPtr doc, xmlNodePtr node 
</FUNCTION>
<FUNCTION>
<NAME>ags_persistable_write</NAME>
<RETURNS>xmlNodePtr  </RETURNS>
AgsPersistable *persistable, xmlDocPtr doc 
</FUNCTION>
<FUNCTION>
<NAME>ags_persistable_write_link</NAME>
<RETURNS>void  </RETURNS>
AgsPersistable *persistable, xmlDocPtr doc, xmlNodePtr node 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MUTABLE</NAME>
#define AGS_TYPE_MUTABLE                    (ags_mutable_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MUTABLE</NAME>
#define AGS_MUTABLE(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MUTABLE, AgsMutable))
</MACRO>
<MACRO>
<NAME>AGS_MUTABLE_INTERFACE</NAME>
#define AGS_MUTABLE_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_MUTABLE, AgsMutableInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTABLE</NAME>
#define AGS_IS_MUTABLE(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_MUTABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTABLE_INTERFACE</NAME>
#define AGS_IS_MUTABLE_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_MUTABLE))
</MACRO>
<MACRO>
<NAME>AGS_MUTABLE_GET_INTERFACE</NAME>
#define AGS_MUTABLE_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_MUTABLE, AgsMutableInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsMutable</NAME>
typedef void AgsMutable;
</TYPEDEF>
<STRUCT>
<NAME>AgsMutableInterface</NAME>
struct _AgsMutableInterface
{
  GTypeInterface interface;

  void (*set_muted)(AgsMutable *mutable, gboolean muted);
};
</STRUCT>
<FUNCTION>
<NAME>ags_mutable_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_mutable_set_muted</NAME>
<RETURNS>void  </RETURNS>
AgsMutable *mutable, gboolean muted 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TREE_ITERATOR</NAME>
#define AGS_TYPE_TREE_ITERATOR                    (ags_tree_iterator_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TREE_ITERATOR</NAME>
#define AGS_TREE_ITERATOR(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TREE_ITERATOR, AgsTreeIterator))
</MACRO>
<MACRO>
<NAME>AGS_TREE_ITERATOR_INTERFACE</NAME>
#define AGS_TREE_ITERATOR_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_TREE_ITERATOR, AgsTreeIteratorInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_TREE_ITERATOR</NAME>
#define AGS_IS_TREE_ITERATOR(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_TREE_ITERATOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_TREE_ITERATOR_INTERFACE</NAME>
#define AGS_IS_TREE_ITERATOR_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_TREE_ITERATOR))
</MACRO>
<MACRO>
<NAME>AGS_TREE_ITERATOR_GET_INTERFACE</NAME>
#define AGS_TREE_ITERATOR_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_TREE_ITERATOR, AgsTreeIteratorInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsTreeIterator</NAME>
typedef void AgsTreeIterator;
</TYPEDEF>
<STRUCT>
<NAME>AgsTreeIteratorInterface</NAME>
struct _AgsTreeIteratorInterface
{
  GTypeInterface interface;

  void (*set_inverse_mode)(AgsTreeIterator *tree, gboolean mode);
  gboolean (*is_inverse_mode)(AgsTreeIterator *tree);
  
  void (*iterate)(AgsTreeIterator *tree,
		  gpointer node_id);
  void (*iterate_nested)(AgsTreeIterator *tree,
			 gpointer node_id);
  
  void (*safe_iterate)(AgsTreeIterator *toplevel, AgsTreeIterator *current,
		       gpointer node_id);
  void (*safe_iterate_nested)(AgsTreeIterator *toplevel, AgsTreeIterator *current,
			      gpointer node_id);

  void (*loop_action)(AgsTreeIterator *current,
		      gpointer node_id);
  void (*nested_loop_action)(AgsTreeIterator *current,
			     gpointer node_id);
};
</STRUCT>
<FUNCTION>
<NAME>ags_tree_iterator_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_tree_iterator_set_inverse_mode</NAME>
<RETURNS>void  </RETURNS>
AgsTreeIterator *tree, gboolean mode 
</FUNCTION>
<FUNCTION>
<NAME>ags_tree_iterator_is_inverse_mode</NAME>
<RETURNS>gboolean  </RETURNS>
AgsTreeIterator *tree 
</FUNCTION>
<FUNCTION>
<NAME>ags_tree_iterator_iterate</NAME>
<RETURNS>void  </RETURNS>
AgsTreeIterator *tree, gpointer node_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_tree_iterator_iterate_nested</NAME>
<RETURNS>void  </RETURNS>
AgsTreeIterator *tree, gpointer node_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_tree_iterator_safe_iterate</NAME>
<RETURNS>void  </RETURNS>
AgsTreeIterator *toplevel, AgsTreeIterator *current, gpointer node_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_tree_iterator_safe_iterate_nested</NAME>
<RETURNS>void  </RETURNS>
AgsTreeIterator *toplevel, AgsTreeIterator *current, gpointer node_id 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SEEKABLE</NAME>
#define AGS_TYPE_SEEKABLE                    (ags_seekable_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SEEKABLE</NAME>
#define AGS_SEEKABLE(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SEEKABLE, AgsSeekable))
</MACRO>
<MACRO>
<NAME>AGS_SEEKABLE_INTERFACE</NAME>
#define AGS_SEEKABLE_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_SEEKABLE, AgsSeekableInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_SEEKABLE</NAME>
#define AGS_IS_SEEKABLE(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SEEKABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_SEEKABLE_INTERFACE</NAME>
#define AGS_IS_SEEKABLE_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_SEEKABLE))
</MACRO>
<MACRO>
<NAME>AGS_SEEKABLE_GET_INTERFACE</NAME>
#define AGS_SEEKABLE_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_SEEKABLE, AgsSeekableInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsSeekable</NAME>
typedef void AgsSeekable;
</TYPEDEF>
<STRUCT>
<NAME>AgsSeekableInterface</NAME>
struct _AgsSeekableInterface
{
  GTypeInterface interface;

  void (*seek)(AgsSeekable *seekable, guint steps, gboolean forward);
};
</STRUCT>
<FUNCTION>
<NAME>ags_seekable_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_seekable_seek</NAME>
<RETURNS>void  </RETURNS>
AgsSeekable *seekable, guint steps, gboolean forward 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PORTLET</NAME>
#define AGS_TYPE_PORTLET                    (ags_portlet_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PORTLET</NAME>
#define AGS_PORTLET(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PORTLET, AgsPortlet))
</MACRO>
<MACRO>
<NAME>AGS_PORTLET_INTERFACE</NAME>
#define AGS_PORTLET_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_PORTLET, AgsPortletInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_PORTLET</NAME>
#define AGS_IS_PORTLET(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PORTLET))
</MACRO>
<MACRO>
<NAME>AGS_IS_PORTLET_INTERFACE</NAME>
#define AGS_IS_PORTLET_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_PORTLET))
</MACRO>
<MACRO>
<NAME>AGS_PORTLET_GET_INTERFACE</NAME>
#define AGS_PORTLET_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_PORTLET, AgsPortletInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsPortlet</NAME>
typedef void AgsPortlet;
</TYPEDEF>
<STRUCT>
<NAME>AgsPortletInterface</NAME>
struct _AgsPortletInterface
{
  GTypeInterface interface;

  AgsPort* (*get_port)(AgsPortlet *portlet);
  void (*set_port)(AgsPortlet *portlet, AgsPort *port);

  GList* (*list_safe_properties)(AgsPortlet *portlet);

  void (*safe_get_property)(AgsPortlet *portlet, gchar *property_name, GValue *value);
  void (*safe_set_property)(AgsPortlet *portlet, gchar *property_name, GValue *value);
};
</STRUCT>
<FUNCTION>
<NAME>ags_portlet_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_portlet_get_port</NAME>
<RETURNS>AgsPort * </RETURNS>
AgsPortlet *portlet 
</FUNCTION>
<FUNCTION>
<NAME>ags_portlet_set_port</NAME>
<RETURNS>void  </RETURNS>
AgsPortlet *portlet, AgsPort *port 
</FUNCTION>
<FUNCTION>
<NAME>ags_portlet_list_safe_properties</NAME>
<RETURNS>GList * </RETURNS>
AgsPortlet *portlet 
</FUNCTION>
<FUNCTION>
<NAME>ags_portlet_safe_get_property</NAME>
<RETURNS>void  </RETURNS>
AgsPortlet *portlet, gchar *property_name, GValue *value 
</FUNCTION>
<FUNCTION>
<NAME>ags_portlet_safe_set_property</NAME>
<RETURNS>void  </RETURNS>
AgsPortlet *portlet, gchar *property_name, GValue *value 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SOUNDCARD</NAME>
#define AGS_TYPE_SOUNDCARD                    (ags_soundcard_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD</NAME>
#define AGS_SOUNDCARD(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SOUNDCARD, AgsSoundcard))
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_INTERFACE</NAME>
#define AGS_SOUNDCARD_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_SOUNDCARD, AgsSoundcardInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_SOUNDCARD</NAME>
#define AGS_IS_SOUNDCARD(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SOUNDCARD))
</MACRO>
<MACRO>
<NAME>AGS_IS_SOUNDCARD_INTERFACE</NAME>
#define AGS_IS_SOUNDCARD_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_SOUNDCARD))
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_GET_INTERFACE</NAME>
#define AGS_SOUNDCARD_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_SOUNDCARD, AgsSoundcardInterface))
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_DSP_CHANNELS</NAME>
#define AGS_SOUNDCARD_DEFAULT_DSP_CHANNELS (2)
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_PCM_CHANNELS</NAME>
#define AGS_SOUNDCARD_DEFAULT_PCM_CHANNELS (2)
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_SAMPLERATE</NAME>
#define AGS_SOUNDCARD_DEFAULT_SAMPLERATE (44100.0)
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_FORMAT</NAME>
#define AGS_SOUNDCARD_DEFAULT_FORMAT (AGS_SOUNDCARD_RESOLUTION_16_BIT)
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_BUFFER_SIZE</NAME>
#define AGS_SOUNDCARD_DEFAULT_BUFFER_SIZE (944)
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_DEVICE</NAME>
#define AGS_SOUNDCARD_DEFAULT_DEVICE "hw:0"
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_BPM</NAME>
#define AGS_SOUNDCARD_DEFAULT_BPM (120.0)
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_JIFFIE</NAME>
#define AGS_SOUNDCARD_DEFAULT_JIFFIE ((double) AGS_SOUNDCARD_DEFAULT_SAMPLERATE / (double) AGS_SOUNDCARD_DEFAULT_BUFFER_SIZE)
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_TACT</NAME>
#define AGS_SOUNDCARD_DEFAULT_TACT (1.0 / 1.0)
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_TACT_JIFFIE</NAME>
#define AGS_SOUNDCARD_DEFAULT_TACT_JIFFIE (60.0 / AGS_SOUNDCARD_DEFAULT_BPM * AGS_SOUNDCARD_DEFAULT_TACT)
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_TACTRATE</NAME>
#define AGS_SOUNDCARD_DEFAULT_TACTRATE (1.0 / AGS_SOUNDCARD_DEFAULT_TACT_JIFFIE)
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_SCALE</NAME>
#define AGS_SOUNDCARD_DEFAULT_SCALE (1.0)
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_DELAY</NAME>
#define AGS_SOUNDCARD_DEFAULT_DELAY (AGS_SOUNDCARD_DEFAULT_JIFFIE * (60.0 / AGS_SOUNDCARD_DEFAULT_BPM))
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_DEFAULT_PERIOD</NAME>
#define AGS_SOUNDCARD_DEFAULT_PERIOD (64.0)
</MACRO>
<TYPEDEF>
<NAME>AgsSoundcard</NAME>
typedef void AgsSoundcard;
</TYPEDEF>
<ENUM>
<NAME>AgsSoundcardResolutionMode</NAME>
typedef enum{
  AGS_SOUNDCARD_RESOLUTION_8_BIT    = 8,
  AGS_SOUNDCARD_RESOLUTION_16_BIT   = 16,
  AGS_SOUNDCARD_RESOLUTION_24_BIT   = 24,
  AGS_SOUNDCARD_RESOLUTION_32_BIT   = 32,
  AGS_SOUNDCARD_RESOLUTION_64_BIT   = 64,
}AgsSoundcardResolutionMode;
</ENUM>
<STRUCT>
<NAME>AgsSoundcardInterface</NAME>
struct _AgsSoundcardInterface
{
  GTypeInterface interface;

  void (*set_application_context)(AgsSoundcard *soundcard,
				  AgsApplicationContext *application_context);
  AgsApplicationContext* (*get_application_context)(AgsSoundcard *soundcard);

  void (*set_device)(AgsSoundcard *soundcard,
		     gchar *card_id);
  gchar* (*get_device)(AgsSoundcard *soundcard);
  
  void (*set_presets)(AgsSoundcard *soundcard,
		      guint channels,
		      guint rate,
		      guint buffer_size,
		      guint format);
  void (*get_presets)(AgsSoundcard *soundcard,
		      guint *channels,
		      guint *rate,
		      guint *buffer_size,
		      guint *format);
  
  void (*list_cards)(AgsSoundcard *soundcard,
		     GList **card_id, GList **card_name);
  void (*pcm_info)(AgsSoundcard *soundcard, gchar *card_id,
		   guint *channels_min, guint *channels_max,
		   guint *rate_min, guint *rate_max,
		   guint *buffer_size_min, guint *buffer_size_max,
		   GError **error);
  
  gboolean (*is_starting)(AgsSoundcard *soundcard);
  gboolean (*is_playing)(AgsSoundcard *soundcard);
  
  void (*play_init)(AgsSoundcard *soundcard,
		    GError **error);
  void (*play)(AgsSoundcard *soundcard,
	       GError **error);
  void (*stop)(AgsSoundcard *soundcard);

  void (*tic)(AgsSoundcard *soundcard);
  void (*offset_changed)(AgsSoundcard *soundcard,
			 guint note_offset);

  signed short* (*get_buffer)(AgsSoundcard *soundcard);
  signed short* (*get_next_buffer)(AgsSoundcard *soundcard);  

  void (*set_bpm)(AgsSoundcard *soundcard,
		  gdouble bpm);
  gdouble (*get_bpm)(AgsSoundcard *soundcard);
  
  gdouble (*get_delay)(AgsSoundcard *soundcard);
  guint (*get_attack)(AgsSoundcard *soundcard);
  
  void (*set_note_offset)(AgsSoundcard *soundcard,
			  guint note_offset);
  guint (*get_note_offset)(AgsSoundcard *soundcard);

  void (*set_audio)(AgsSoundcard *soundcard,
		    GList *audio);
  GList* (*get_audio)(AgsSoundcard *soundcard);
};
</STRUCT>
<FUNCTION>
<NAME>ags_soundcard_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_set_application_context</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, AgsApplicationContext *application_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_get_application_context</NAME>
<RETURNS>AgsApplicationContext * </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_set_device</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, gchar *device_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_get_device</NAME>
<RETURNS>gchar * </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_set_presets</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, guint channels, guint rate, guint buffer_size, guint format 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_get_presets</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, guint *channels, guint *rate, guint *buffer_size, guint *format 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_list_cards</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, GList **card_id, GList **card_name 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_pcm_info</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, gchar *card_id, guint *channels_min, guint *channels_max, guint *rate_min, guint *rate_max, guint *buffer_size_min, guint *buffer_size_max, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_is_starting</NAME>
<RETURNS>gboolean  </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_is_playing</NAME>
<RETURNS>gboolean  </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_play_init</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_play</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_stop</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_tic</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_offset_changed</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, guint note_offset 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_get_buffer</NAME>
<RETURNS>signed short * </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_get_next_buffer</NAME>
<RETURNS>signed short * </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_set_bpm</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, gdouble bpm 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_get_bpm</NAME>
<RETURNS>gdouble  </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_get_delay</NAME>
<RETURNS>gdouble  </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_get_attack</NAME>
<RETURNS>guint  </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_set_note_offset</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, guint note_offset 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_get_note_offset</NAME>
<RETURNS>guint  </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_set_audio</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, GList *audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_get_audio</NAME>
<RETURNS>GList * </RETURNS>
AgsSoundcard *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__UINT_UINT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__UINT_UINT_UINT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__UINT_DOUBLE_UINT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__UINT_INT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__UINT_DOUBLE</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__ULONG_UINT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__ULONG_UINT_BOOLEAN</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__DOUBLE_DOUBLE</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__ULONG_UINT_UINT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__STRING_UINT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__STRING_POINTER</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__STRING_STRING_STRING</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__OBJECT_UINT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__OBJECT_OBJECT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__OBJECT_OBJECT_OBJECT_INT_BOOLEAN</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__OBJECT_OBJECT_OBJECT_OBJECT_OBJECT_OBJECT_UINT_INT_BOOLEAN</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_VOID__OBJECT_OBJECT_OBJECT_OBJECT_OBJECT_OBJECT_OBJECT_OBJECT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_ULONG__VOID</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_INT__VOID</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_BOOLEAN__OBJECT_OBJECT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_STRING__STRING_STRING</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_STRING__ULONG_STRING_STRING_STRING_STRING_UINT_POINTER</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_POINTER__VOID</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_POINTER__UINT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_POINTER__STRING_STRING</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_OBJECT__VOID</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_OBJECT__STRING_STRING_STRING</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_OBJECT__OBJECT_POINTER_POINTER</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<FUNCTION>
<NAME>g_cclosure_user_marshal_OBJECT__OBJECT_OBJECT</NAME>
<RETURNS>void  </RETURNS>
GClosure     *closure, GValue       *return_value, guint         n_param_values, const GValue *param_values, gpointer      invocation_hint, gpointer      marshal_data 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CONNECTABLE</NAME>
#define AGS_TYPE_CONNECTABLE                    (ags_connectable_get_type())
</MACRO>
<MACRO>
<NAME>AGS_CONNECTABLE</NAME>
#define AGS_CONNECTABLE(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CONNECTABLE, AgsConnectable))
</MACRO>
<MACRO>
<NAME>AGS_CONNECTABLE_INTERFACE</NAME>
#define AGS_CONNECTABLE_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_CONNECTABLE, AgsConnectableInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_CONNECTABLE</NAME>
#define AGS_IS_CONNECTABLE(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_CONNECTABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_CONNECTABLE_INTERFACE</NAME>
#define AGS_IS_CONNECTABLE_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_CONNECTABLE))
</MACRO>
<MACRO>
<NAME>AGS_CONNECTABLE_GET_INTERFACE</NAME>
#define AGS_CONNECTABLE_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_CONNECTABLE, AgsConnectableInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsConnectable</NAME>
typedef void AgsConnectable;
</TYPEDEF>
<STRUCT>
<NAME>AgsConnectableInterface</NAME>
struct _AgsConnectableInterface
{
  GTypeInterface interface;

  void (*add_to_registry)(AgsConnectable *connectable);
  void (*remove_from_registry)(AgsConnectable *connectable);

  xmlNode* (*update)(AgsConnectable *connectable);

  gboolean (*is_ready)(AgsConnectable *connectable);
  gboolean (*is_connected)(AgsConnectable *connectable);

  void (*connect)(AgsConnectable *connectable);
  void (*disconnect)(AgsConnectable *connectable);
};
</STRUCT>
<FUNCTION>
<NAME>ags_connectable_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_connectable_add_to_registry</NAME>
<RETURNS>void  </RETURNS>
AgsConnectable *connectable 
</FUNCTION>
<FUNCTION>
<NAME>ags_connectable_connect</NAME>
<RETURNS>void  </RETURNS>
AgsConnectable *connectable 
</FUNCTION>
<FUNCTION>
<NAME>ags_connectable_disconnect</NAME>
<RETURNS>void  </RETURNS>
AgsConnectable *connectable 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_APPLICATION_CONTEXT</NAME>
#define AGS_TYPE_APPLICATION_CONTEXT                (ags_application_context_get_type())
</MACRO>
<MACRO>
<NAME>AGS_APPLICATION_CONTEXT</NAME>
#define AGS_APPLICATION_CONTEXT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_APPLICATION_CONTEXT, AgsApplicationContext))
</MACRO>
<MACRO>
<NAME>AGS_APPLICATION_CONTEXT_CLASS</NAME>
#define AGS_APPLICATION_CONTEXT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_APPLICATION_CONTEXT, AgsApplicationContextClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPLICATION_CONTEXT</NAME>
#define AGS_IS_APPLICATION_CONTEXT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_APPLICATION_CONTEXT))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPLICATION_CONTEXT_CLASS</NAME>
#define AGS_IS_APPLICATION_CONTEXT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_APPLICATION_CONTEXT))
</MACRO>
<MACRO>
<NAME>AGS_APPLICATION_CONTEXT_GET_CLASS</NAME>
#define AGS_APPLICATION_CONTEXT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_APPLICATION_CONTEXT, AgsApplicationContextClass))
</MACRO>
<MACRO>
<NAME>AGS_VERSION</NAME>
#define AGS_VERSION "0.4.3\0"
</MACRO>
<MACRO>
<NAME>AGS_BUILD_ID</NAME>
#define AGS_BUILD_ID "Thu Apr  2 13:04:21 GMT 2015\0"
</MACRO>
<MACRO>
<NAME>AGS_DEFAULT_DIRECTORY</NAME>
#define AGS_DEFAULT_DIRECTORY ".gsequencer\0"
</MACRO>
<MACRO>
<NAME>AGS_DEFAULT_CONFIG</NAME>
#define AGS_DEFAULT_CONFIG "ags.conf\0"
</MACRO>
<MACRO>
<NAME>AGS_INIT_CONTEXT_TSD_APPLICATION_CONTEXT</NAME>
#define AGS_INIT_CONTEXT_TSD_APPLICATION_CONTEXT "ags-application-context\0"
</MACRO>
<ENUM>
<NAME>AgsApplicationContextFlags</NAME>
typedef enum{
  AGS_APPLICATION_CONTEXT_DEFAULT            = 1,
  AGS_APPLICATION_CONTEXT_REGISTER_TYPES     = 1 << 1,
  AGS_APPLICATION_CONTEXT_ADD_TO_REGISTRY    = 1 << 2,
  AGS_APPLICATION_CONTEXT_CONNECT            = 1 << 3,
  AGS_APPLICATION_CONTEXT_TYPES_REGISTERED   = 1 << 4,
  AGS_APPLICATION_CONTEXT_READY              = 1 << 5,
  AGS_APPLICATION_CONTEXT_CONNECTED          = 1 << 6,
}AgsApplicationContextFlags;
</ENUM>
<STRUCT>
<NAME>AgsApplicationContext</NAME>
struct _AgsApplicationContext
{
  GObject object;

  guint flags;

  gchar *version;
  gchar *build_id;

  int argc;
  char **argv;
  
  GObject *log;

  gchar *domain;
  GList *sibling;
  
  AgsConfig *config;

  pthread_mutex_t *mutex;
  
  GObject *main_loop;
  GObject *autosave_thread;
  GObject *task_thread;
  
  AgsFile *file;
};
</STRUCT>
<STRUCT>
<NAME>AgsApplicationContextClass</NAME>
struct _AgsApplicationContextClass
{
  GObjectClass object;

  void (*load_config)(AgsApplicationContext *application_context);
  
  void (*register_types)(AgsApplicationContext *application_context);

  void (*read)(AgsFile *file, xmlNode *node, GObject **gobject);
  xmlNode* (*write)(AgsFile *file, xmlNode *parent, GObject *gobject);
};
</STRUCT>
<FUNCTION>
<NAME>ags_application_context_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_application_context_load_config</NAME>
<RETURNS>void  </RETURNS>
AgsApplicationContext *application_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_application_read</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GObject **gobject 
</FUNCTION>
<FUNCTION>
<NAME>ags_application_write</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GObject *gobject 
</FUNCTION>
<FUNCTION>
<NAME>ags_application_context_add_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsApplicationContext *application_context, AgsApplicationContext *sibling 
</FUNCTION>
<FUNCTION>
<NAME>ags_application_context_remove_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsApplicationContext *application_context, AgsApplicationContext *sibling 
</FUNCTION>
<FUNCTION>
<NAME>ags_application_context_find_default</NAME>
<RETURNS>AgsApplicationContext * </RETURNS>
GList *application_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_application_context_find_main_loop</NAME>
<RETURNS>GList * </RETURNS>
GList *application_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_application_context_new</NAME>
<RETURNS>AgsApplicationContext * </RETURNS>
GObject *main_loop, AgsConfig *config 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TACTABLE</NAME>
#define AGS_TYPE_TACTABLE                    (ags_tactable_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TACTABLE</NAME>
#define AGS_TACTABLE(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TACTABLE, AgsTactable))
</MACRO>
<MACRO>
<NAME>AGS_TACTABLE_INTERFACE</NAME>
#define AGS_TACTABLE_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_TACTABLE, AgsTactableInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_TACTABLE</NAME>
#define AGS_IS_TACTABLE(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_TACTABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_TACTABLE_INTERFACE</NAME>
#define AGS_IS_TACTABLE_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_TACTABLE))
</MACRO>
<MACRO>
<NAME>AGS_TACTABLE_GET_INTERFACE</NAME>
#define AGS_TACTABLE_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_TACTABLE, AgsTactableInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsTactable</NAME>
typedef void AgsTactable;
</TYPEDEF>
<STRUCT>
<NAME>AgsTactableInterface</NAME>
struct _AgsTactableInterface
{
  GTypeInterface interface;

  void (*change_sequencer_duration)(AgsTactable *tactable, gdouble duration);
  void (*change_notation_duration)(AgsTactable *tactable, gdouble duration);
  void (*change_tact)(AgsTactable *tactable, gdouble tact);
  void (*change_bpm)(AgsTactable *tactable, gdouble bpm);
};
</STRUCT>
<FUNCTION>
<NAME>ags_tactable_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_tactable_change_sequencer_duration</NAME>
<RETURNS>void  </RETURNS>
AgsTactable *tactable, gdouble duration 
</FUNCTION>
<FUNCTION>
<NAME>ags_tactable_change_notation_duration</NAME>
<RETURNS>void  </RETURNS>
AgsTactable *tactable, gdouble duration 
</FUNCTION>
<FUNCTION>
<NAME>ags_tactable_change_tact</NAME>
<RETURNS>void  </RETURNS>
AgsTactable *tactable, gdouble tact 
</FUNCTION>
<FUNCTION>
<NAME>ags_tactable_change_bpm</NAME>
<RETURNS>void  </RETURNS>
AgsTactable *tactable, gdouble bpm 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLUGIN</NAME>
#define AGS_TYPE_PLUGIN                    (ags_plugin_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLUGIN</NAME>
#define AGS_PLUGIN(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLUGIN, AgsPlugin))
</MACRO>
<MACRO>
<NAME>AGS_PLUGIN_INTERFACE</NAME>
#define AGS_PLUGIN_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_PLUGIN, AgsPluginInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLUGIN</NAME>
#define AGS_IS_PLUGIN(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PLUGIN))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLUGIN_INTERFACE</NAME>
#define AGS_IS_PLUGIN_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_PLUGIN))
</MACRO>
<MACRO>
<NAME>AGS_PLUGIN_GET_INTERFACE</NAME>
#define AGS_PLUGIN_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_PLUGIN, AgsPluginInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsPlugin</NAME>
typedef void AgsPlugin;
</TYPEDEF>
<STRUCT>
<NAME>AgsPluginInterface</NAME>
struct _AgsPluginInterface
{
  GTypeInterface interface;
  
  gchar* (*get_name)(AgsPlugin *plugin);
  void (*set_name)(AgsPlugin *plugin, gchar *name);

  gchar* (*get_version)(AgsPlugin *plugin);
  void (*set_version)(AgsPlugin *plugin, gchar *version);

  gchar* (*get_build_id)(AgsPlugin *plugin);
  void (*set_build_id)(AgsPlugin *plugin, gchar *build_id);

  gchar* (*get_xml_type)(AgsPlugin *plugin);
  void (*set_xml_type)(AgsPlugin *plugin, gchar *xml_type);  

  GList* (*get_ports)(AgsPlugin *plugin);
  void (*set_ports)(AgsPlugin *plugin, GList *ports);

  void (*read)(AgsFile *file,
	       xmlNode *node,
	       AgsPlugin *plugin);
  xmlNode* (*write)(AgsFile *file,
		    xmlNode *parent,
		    AgsPlugin *plugin);
};
</STRUCT>
<FUNCTION>
<NAME>ags_plugin_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_get_name</NAME>
<RETURNS>gchar * </RETURNS>
AgsPlugin *plugin 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_set_name</NAME>
<RETURNS>void  </RETURNS>
AgsPlugin *plugin, gchar *name 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_get_version</NAME>
<RETURNS>gchar * </RETURNS>
AgsPlugin *plugin 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_set_version</NAME>
<RETURNS>void  </RETURNS>
AgsPlugin *plugin, gchar *version 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_get_build_id</NAME>
<RETURNS>gchar * </RETURNS>
AgsPlugin *plugin 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_set_build_id</NAME>
<RETURNS>void  </RETURNS>
AgsPlugin *plugin, gchar *build_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_get_xml_type</NAME>
<RETURNS>gchar * </RETURNS>
AgsPlugin *plugin 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_set_xml_type</NAME>
<RETURNS>void  </RETURNS>
AgsPlugin *plugin, gchar *xml_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_get_ports</NAME>
<RETURNS>GList * </RETURNS>
AgsPlugin *plugin 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_set_ports</NAME>
<RETURNS>void  </RETURNS>
AgsPlugin *plugin, GList *ports 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_read</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsPlugin *plugin 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_write</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsPlugin *plugin 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_STACKABLE</NAME>
#define AGS_TYPE_STACKABLE                    (ags_stackable_get_type())
</MACRO>
<MACRO>
<NAME>AGS_STACKABLE</NAME>
#define AGS_STACKABLE(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_STACKABLE, AgsStackable))
</MACRO>
<MACRO>
<NAME>AGS_STACKABLE_INTERFACE</NAME>
#define AGS_STACKABLE_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_STACKABLE, AgsStackableInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_STACKABLE</NAME>
#define AGS_IS_STACKABLE(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_STACKABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_STACKABLE_INTERFACE</NAME>
#define AGS_IS_STACKABLE_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_STACKABLE))
</MACRO>
<MACRO>
<NAME>AGS_STACKABLE_GET_INTERFACE</NAME>
#define AGS_STACKABLE_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_STACKABLE, AgsStackableInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsStackable</NAME>
typedef void AgsStackable;
</TYPEDEF>
<STRUCT>
<NAME>AgsStackableInterface</NAME>
struct _AgsStackableInterface
{
  GTypeInterface interface;

  void (*push)(AgsStackable *stackable);
  void (*pop)(AgsStackable *stackable);
};
</STRUCT>
<FUNCTION>
<NAME>ags_stackable_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_stackable_push</NAME>
<RETURNS>void  </RETURNS>
AgsStackable *stackable 
</FUNCTION>
<FUNCTION>
<NAME>ags_stackable_pop</NAME>
<RETURNS>void  </RETURNS>
AgsStackable *stackable 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MAIN_LOOP</NAME>
#define AGS_TYPE_MAIN_LOOP                    (ags_main_loop_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MAIN_LOOP</NAME>
#define AGS_MAIN_LOOP(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MAIN_LOOP, AgsMainLoop))
</MACRO>
<MACRO>
<NAME>AGS_MAIN_LOOP_INTERFACE</NAME>
#define AGS_MAIN_LOOP_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_MAIN_LOOP, AgsMainLoopInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_MAIN_LOOP</NAME>
#define AGS_IS_MAIN_LOOP(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_MAIN_LOOP))
</MACRO>
<MACRO>
<NAME>AGS_IS_MAIN_LOOP_INTERFACE</NAME>
#define AGS_IS_MAIN_LOOP_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_MAIN_LOOP))
</MACRO>
<MACRO>
<NAME>AGS_MAIN_LOOP_GET_INTERFACE</NAME>
#define AGS_MAIN_LOOP_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_MAIN_LOOP, AgsMainLoopInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsMainLoop</NAME>
typedef void AgsMainLoop;
</TYPEDEF>
<STRUCT>
<NAME>AgsMainLoopInterface</NAME>
struct _AgsMainLoopInterface
{
  GTypeInterface interface;

  void (*set_application_context)(AgsMainLoop *main_loop, AgsApplicationContext *application_context);
  AgsApplicationContext* (*get_application_context)(AgsMainLoop *main_loop);
  
  void (*set_tic)(AgsMainLoop *main_loop, guint tic);
  guint (*get_tic)(AgsMainLoop *main_loop);

  void (*set_last_sync)(AgsMainLoop *main_loop, guint last_sync);
  guint (*get_last_sync)(AgsMainLoop *main_loop);
};
</STRUCT>
<FUNCTION>
<NAME>ags_main_loop_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_main_loop_set_application_context</NAME>
<RETURNS>void  </RETURNS>
AgsMainLoop *main_loop, AgsApplicationContext *application_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_main_loop_get_application_context</NAME>
<RETURNS>AgsApplicationContext * </RETURNS>
AgsMainLoop *main_loop 
</FUNCTION>
<FUNCTION>
<NAME>ags_main_loop_set_tic</NAME>
<RETURNS>void  </RETURNS>
AgsMainLoop *main_loop, guint tic 
</FUNCTION>
<FUNCTION>
<NAME>ags_main_loop_get_tic</NAME>
<RETURNS>guint  </RETURNS>
AgsMainLoop *main_loop 
</FUNCTION>
<FUNCTION>
<NAME>ags_main_loop_set_last_sync</NAME>
<RETURNS>void  </RETURNS>
AgsMainLoop *main_loop, guint last_sync 
</FUNCTION>
<FUNCTION>
<NAME>ags_main_loop_get_last_sync</NAME>
<RETURNS>guint  </RETURNS>
AgsMainLoop *main_loop 
</FUNCTION>
<FUNCTION>
<NAME>ags_init_context</NAME>
<RETURNS>void  </RETURNS>
AgsApplicationContext *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PACKABLE</NAME>
#define AGS_TYPE_PACKABLE                    (ags_packable_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PACKABLE</NAME>
#define AGS_PACKABLE(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PACKABLE, AgsPackable))
</MACRO>
<MACRO>
<NAME>AGS_PACKABLE_INTERFACE</NAME>
#define AGS_PACKABLE_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_PACKABLE, AgsPackableInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_PACKABLE</NAME>
#define AGS_IS_PACKABLE(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PACKABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_PACKABLE_INTERFACE</NAME>
#define AGS_IS_PACKABLE_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_PACKABLE))
</MACRO>
<MACRO>
<NAME>AGS_PACKABLE_GET_INTERFACE</NAME>
#define AGS_PACKABLE_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_PACKABLE, AgsPackableInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsPackable</NAME>
typedef void AgsPackable;
</TYPEDEF>
<STRUCT>
<NAME>AgsPackableInterface</NAME>
struct _AgsPackableInterface
{
  GTypeInterface interface;

  gboolean (*pack)(AgsPackable *packable, GObject *container);
  gboolean (*unpack)(AgsPackable *packable);
};
</STRUCT>
<FUNCTION>
<NAME>ags_packable_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_packable_pack</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPackable *packable, GObject *container 
</FUNCTION>
<FUNCTION>
<NAME>ags_packable_unpack</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPackable *packable 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_DYNAMIC_CONNECTABLE</NAME>
#define AGS_TYPE_DYNAMIC_CONNECTABLE                    (ags_dynamic_connectable_get_type())
</MACRO>
<MACRO>
<NAME>AGS_DYNAMIC_CONNECTABLE</NAME>
#define AGS_DYNAMIC_CONNECTABLE(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_DYNAMIC_CONNECTABLE, AgsDynamicConnectable))
</MACRO>
<MACRO>
<NAME>AGS_DYNAMIC_CONNECTABLE_INTERFACE</NAME>
#define AGS_DYNAMIC_CONNECTABLE_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_DYNAMIC_CONNECTABLE, AgsDynamicConnectableInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_DYNAMIC_CONNECTABLE</NAME>
#define AGS_IS_DYNAMIC_CONNECTABLE(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_DYNAMIC_CONNECTABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_DYNAMIC_CONNECTABLE_INTERFACE</NAME>
#define AGS_IS_DYNAMIC_CONNECTABLE_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_DYNAMIC_CONNECTABLE))
</MACRO>
<MACRO>
<NAME>AGS_DYNAMIC_CONNECTABLE_GET_INTERFACE</NAME>
#define AGS_DYNAMIC_CONNECTABLE_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_DYNAMIC_CONNECTABLE, AgsDynamicConnectableInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsDynamicConnectable</NAME>
typedef void AgsDynamicConnectable;
</TYPEDEF>
<STRUCT>
<NAME>AgsDynamicConnectableInterface</NAME>
struct _AgsDynamicConnectableInterface
{
  GTypeInterface interface;

  void (*connect_dynamic)(AgsDynamicConnectable *connectable);
  void (*disconnect_dynamic)(AgsDynamicConnectable *connectable);
};
</STRUCT>
<FUNCTION>
<NAME>ags_dynamic_connectable_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_dynamic_connectable_connect</NAME>
<RETURNS>void  </RETURNS>
AgsDynamicConnectable *connectable 
</FUNCTION>
<FUNCTION>
<NAME>ags_dynamic_connectable_disconnect</NAME>
<RETURNS>void  </RETURNS>
AgsDynamicConnectable *connectable 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RUNNABLE</NAME>
#define AGS_TYPE_RUNNABLE                    (ags_runnable_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RUNNABLE</NAME>
#define AGS_RUNNABLE(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RUNNABLE, AgsRunnable))
</MACRO>
<MACRO>
<NAME>AGS_RUNNABLE_INTERFACE</NAME>
#define AGS_RUNNABLE_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_RUNNABLE, AgsRunnableInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_RUNNABLE</NAME>
#define AGS_IS_RUNNABLE(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_RUNNABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_RUNNABLE_INTERFACE</NAME>
#define AGS_IS_RUNNABLE_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_RUNNABLE))
</MACRO>
<MACRO>
<NAME>AGS_RUNNABLE_GET_INTERFACE</NAME>
#define AGS_RUNNABLE_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_RUNNABLE, AgsRunnableInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsRunnable</NAME>
typedef void AgsRunnable;
</TYPEDEF>
<STRUCT>
<NAME>AgsRunnableInterface</NAME>
struct _AgsRunnableInterface
{
  GTypeInterface interface;

  void (*run)(AgsRunnable *runnable);
  void (*stop)(AgsRunnable *runnable);
};
</STRUCT>
<FUNCTION>
<NAME>ags_runnable_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_runnable_run</NAME>
<RETURNS>void  </RETURNS>
AgsRunnable *runnable 
</FUNCTION>
<FUNCTION>
<NAME>ags_runnable_stop</NAME>
<RETURNS>void  </RETURNS>
AgsRunnable *runnable 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_EFFECT</NAME>
#define AGS_TYPE_EFFECT                    (ags_effect_get_type())
</MACRO>
<MACRO>
<NAME>AGS_EFFECT</NAME>
#define AGS_EFFECT(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_EFFECT, AgsEffect))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_INTERFACE</NAME>
#define AGS_EFFECT_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_EFFECT, AgsEffectInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_EFFECT</NAME>
#define AGS_IS_EFFECT(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_EFFECT))
</MACRO>
<MACRO>
<NAME>AGS_IS_EFFECT_INTERFACE</NAME>
#define AGS_IS_EFFECT_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_EFFECT))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_GET_INTERFACE</NAME>
#define AGS_EFFECT_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_EFFECT, AgsEffectInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsEffect</NAME>
typedef void AgsEffect;
</TYPEDEF>
<STRUCT>
<NAME>AgsEffectInterface</NAME>
struct _AgsEffectInterface
{
  GTypeInterface interface;
};
</STRUCT>
<FUNCTION>
<NAME>ags_effect_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CONFIG</NAME>
#define AGS_TYPE_CONFIG                (ags_config_get_type ())
</MACRO>
<MACRO>
<NAME>AGS_CONFIG</NAME>
#define AGS_CONFIG(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CONFIG, AgsConfig))
</MACRO>
<MACRO>
<NAME>AGS_CONFIG_CLASS</NAME>
#define AGS_CONFIG_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_CONFIG, AgsConfigClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_CONFIG</NAME>
#define AGS_IS_CONFIG(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_CONFIG))
</MACRO>
<MACRO>
<NAME>AGS_IS_CONFIG_CLASS</NAME>
#define AGS_IS_CONFIG_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_CONFIG))
</MACRO>
<MACRO>
<NAME>AGS_CONFIG_GET_CLASS</NAME>
#define AGS_CONFIG_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_CONFIG, AgsConfigClass))
</MACRO>
<MACRO>
<NAME>AGS_CONFIG_DEFAULT_VERSION</NAME>
#define AGS_CONFIG_DEFAULT_VERSION "0.4.3\0"
</MACRO>
<MACRO>
<NAME>AGS_CONFIG_DEFAULT_BUILD_ID</NAME>
#define AGS_CONFIG_DEFAULT_BUILD_ID "Sat Apr  4 02:44:55 GMT 2015\0"
</MACRO>
<MACRO>
<NAME>AGS_INIT_CONTEXT_TSD_CONFIG</NAME>
#define AGS_INIT_CONTEXT_TSD_CONFIG "ags-config\0"
</MACRO>
<MACRO>
<NAME>AGS_CONFIG_GENERIC</NAME>
#define AGS_CONFIG_GENERIC "generic\0"
</MACRO>
<MACRO>
<NAME>AGS_CONFIG_THREAD</NAME>
#define AGS_CONFIG_THREAD "thread\0"
</MACRO>
<MACRO>
<NAME>AGS_CONFIG_SOUNDCARD</NAME>
#define AGS_CONFIG_SOUNDCARD "device\0"
</MACRO>
<MACRO>
<NAME>AGS_CONFIG_RECALL</NAME>
#define AGS_CONFIG_RECALL "recall\0"
</MACRO>
<STRUCT>
<NAME>AgsConfig</NAME>
struct _AgsConfig
{
  GObject object;

  guint version;
  gchar *build_id;
  
  GObject *application_context;

  GKeyFile *key_file;
};
</STRUCT>
<STRUCT>
<NAME>AgsConfigClass</NAME>
struct _AgsConfigClass
{
  GObjectClass object;

  void (*load_defaults)(AgsConfig *config);

  void (*set_value)(AgsConfig *config, gchar *group, gchar *key, gchar *value);
  gchar* (*get_value)(AgsConfig *config, gchar *group, gchar *key);
};
</STRUCT>
<FUNCTION>
<NAME>ags_config_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_config_load_defaults</NAME>
<RETURNS>void  </RETURNS>
AgsConfig *config 
</FUNCTION>
<FUNCTION>
<NAME>ags_config_load_from_file</NAME>
<RETURNS>void  </RETURNS>
AgsConfig *config, gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>ags_config_set_value</NAME>
<RETURNS>void  </RETURNS>
AgsConfig *config, gchar *group, gchar *key, gchar *value 
</FUNCTION>
<FUNCTION>
<NAME>ags_config_get_value</NAME>
<RETURNS>gchar * </RETURNS>
AgsConfig *config, gchar *group, gchar *key 
</FUNCTION>
<FUNCTION>
<NAME>ags_config_save</NAME>
<RETURNS>void  </RETURNS>
AgsConfig *config 
</FUNCTION>
<FUNCTION>
<NAME>ags_config_new</NAME>
<RETURNS>AgsConfig * </RETURNS>
GObject *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_FILE_LAUNCH</NAME>
#define AGS_TYPE_FILE_LAUNCH                (ags_file_launch_get_type())
</MACRO>
<MACRO>
<NAME>AGS_FILE_LAUNCH</NAME>
#define AGS_FILE_LAUNCH(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_FILE_LAUNCH, AgsFileLaunch))
</MACRO>
<MACRO>
<NAME>AGS_FILE_LAUNCH_CLASS</NAME>
#define AGS_FILE_LAUNCH_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_FILE_LAUNCH, AgsFileLaunchClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_FILE_LAUNCH</NAME>
#define AGS_IS_FILE_LAUNCH(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_FILE_LAUNCH))
</MACRO>
<MACRO>
<NAME>AGS_IS_FILE_LAUNCH_CLASS</NAME>
#define AGS_IS_FILE_LAUNCH_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_FILE_LAUNCH))
</MACRO>
<MACRO>
<NAME>AGS_FILE_LAUNCH_GET_CLASS</NAME>
#define AGS_FILE_LAUNCH_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_FILE_LAUNCH, AgsFileLaunchClass))
</MACRO>
<STRUCT>
<NAME>AgsFileLaunch</NAME>
struct _AgsFileLaunch
{
  GObject object;

  GObject *ags_main;

  xmlNode *node;
  GObject *file;
};
</STRUCT>
<STRUCT>
<NAME>AgsFileLaunchClass</NAME>
struct _AgsFileLaunchClass
{
  GObjectClass object;

  void (*start)(AgsFileLaunch *file_launch);
};
</STRUCT>
<FUNCTION>
<NAME>ags_file_launch_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_launch_start</NAME>
<RETURNS>void  </RETURNS>
AgsFileLaunch *file_launch 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_launch_new</NAME>
<RETURNS>AgsFileLaunch * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_FILE_LOOKUP</NAME>
#define AGS_TYPE_FILE_LOOKUP                (ags_file_lookup_get_type())
</MACRO>
<MACRO>
<NAME>AGS_FILE_LOOKUP</NAME>
#define AGS_FILE_LOOKUP(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_FILE_LOOKUP, AgsFileLookup))
</MACRO>
<MACRO>
<NAME>AGS_FILE_LOOKUP_CLASS</NAME>
#define AGS_FILE_LOOKUP_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_FILE_LOOKUP, AgsFileLookupClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_FILE_LOOKUP</NAME>
#define AGS_IS_FILE_LOOKUP(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_FILE_LOOKUP))
</MACRO>
<MACRO>
<NAME>AGS_IS_FILE_LOOKUP_CLASS</NAME>
#define AGS_IS_FILE_LOOKUP_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_FILE_LOOKUP))
</MACRO>
<MACRO>
<NAME>AGS_FILE_LOOKUP_GET_CLASS</NAME>
#define AGS_FILE_LOOKUP_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_FILE_LOOKUP, AgsFileLookupClass))
</MACRO>
<STRUCT>
<NAME>AgsFileLookup</NAME>
struct _AgsFileLookup
{
  GObject object;

  AgsFile *file;

  xmlNode *node;
  gpointer ref;
};
</STRUCT>
<STRUCT>
<NAME>AgsFileLookupClass</NAME>
struct _AgsFileLookupClass
{
  GObjectClass object;

  void (*resolve)(AgsFileLookup *lookup);
};
</STRUCT>
<FUNCTION>
<NAME>ags_file_lookup_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_lookup_find_by_node</NAME>
<RETURNS>GList * </RETURNS>
GList *file_lookup, xmlNode *node 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_lookup_resolve</NAME>
<RETURNS>void  </RETURNS>
AgsFileLookup *lookup 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_lookup_new</NAME>
<RETURNS>AgsFileLookup * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_util_read_value</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, gchar **id, GValue *value, xmlChar **xpath 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_util_write_value</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, gchar *id, GValue *value, GType pointer_type, guint arr_length 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_util_read_parameter</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, gchar **id, GParameter **parameter, gint *n_params, xmlChar ***xpath 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_util_write_parameter</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, gchar *id, GParameter *parameter, gint n_params 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_util_read_dependency</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, gchar **id, gchar **name, xmlChar **xpath 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_util_write_dependency</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, gchar *id, gchar *name, xmlChar *xpath 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_util_read_object</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GObject **gobject 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_util_write_object</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GObject *gobject 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_util_read_history</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsHistory **history 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_util_write_history</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsHistory *history 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_FILE_ID_REF</NAME>
#define AGS_TYPE_FILE_ID_REF                (ags_file_id_ref_get_type())
</MACRO>
<MACRO>
<NAME>AGS_FILE_ID_REF</NAME>
#define AGS_FILE_ID_REF(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_FILE_ID_REF, AgsFileIdRef))
</MACRO>
<MACRO>
<NAME>AGS_FILE_ID_REF_CLASS</NAME>
#define AGS_FILE_ID_REF_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_FILE_ID_REF, AgsFileIdRef))
</MACRO>
<MACRO>
<NAME>AGS_IS_FILE_ID_REF</NAME>
#define AGS_IS_FILE_ID_REF(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_FILE_ID_REF))
</MACRO>
<MACRO>
<NAME>AGS_IS_FILE_ID_REF_CLASS</NAME>
#define AGS_IS_FILE_ID_REF_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_FILE_ID_REF))
</MACRO>
<MACRO>
<NAME>AGS_FILE_ID_REF_GET_CLASS</NAME>
#define AGS_FILE_ID_REF_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_FILE_ID_REF, AgsFileIdRefClass))
</MACRO>
<MACRO>
<NAME>AGS_FILE_RESOLVE</NAME>
#define AGS_FILE_RESOLVE(f)          ((AgsFileResolve)(f))
</MACRO>
<MACRO>
<NAME>AGS_FILE_ID_REF_SERIALIZE_DATA</NAME>
#define AGS_FILE_ID_REF_SERIALIZE_DATA "ags-file-id-ref-serizalize-data\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_ID_REF_RESOLVE_DATA</NAME>
#define AGS_FILE_ID_REF_RESOLVE_DATA "ags-file-id-ref-resolve-data\0"
</MACRO>
<USER_FUNCTION>
<NAME>AgsFileResolve</NAME>
<RETURNS>void </RETURNS>
void
</USER_FUNCTION>
<STRUCT>
<NAME>AgsFileIdRef</NAME>
struct _AgsFileIdRef
{
  GObject object;

  GObject *ags_main;
  GObject *file;

  xmlNode *node;
  gchar *xpath;
  gpointer ref;
};
</STRUCT>
<STRUCT>
<NAME>AgsFileIdRefClass</NAME>
struct _AgsFileIdRefClass
{
  GObjectClass object;

  void (*resolved)(AgsFileIdRef *file_id_ref);
};
</STRUCT>
<FUNCTION>
<NAME>ags_file_id_ref_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_id_ref_resolved</NAME>
<RETURNS>void  </RETURNS>
AgsFileIdRef *file_id_ref 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_id_ref_new</NAME>
<RETURNS>AgsFileIdRef * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_FILE_LINK</NAME>
#define AGS_TYPE_FILE_LINK                (ags_file_link_get_type())
</MACRO>
<MACRO>
<NAME>AGS_FILE_LINK</NAME>
#define AGS_FILE_LINK(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_FILE_LINK, AgsFileLink))
</MACRO>
<MACRO>
<NAME>AGS_FILE_LINK_CLASS</NAME>
#define AGS_FILE_LINK_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_FILE_LINK, AgsFileLink))
</MACRO>
<MACRO>
<NAME>AGS_IS_FILE_LINK</NAME>
#define AGS_IS_FILE_LINK(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_FILE_LINK))
</MACRO>
<MACRO>
<NAME>AGS_IS_FILE_LINK_CLASS</NAME>
#define AGS_IS_FILE_LINK_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_FILE_LINK))
</MACRO>
<MACRO>
<NAME>AGS_FILE_LINK_GET_CLASS</NAME>
#define AGS_FILE_LINK_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_FILE_LINK, AgsFileLinkClass))
</MACRO>
<STRUCT>
<NAME>AgsFileLink</NAME>
struct _AgsFileLink
{
  GObject object;

  gchar *filename;
  gchar *data;
  AgsTimestamp *timestamp;
};
</STRUCT>
<STRUCT>
<NAME>AgsFileLinkClass</NAME>
struct _AgsFileLinkClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_file_link_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_link_new</NAME>
<RETURNS>AgsFileLink * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_FILE_DEFAULT_VERSION</NAME>
#define AGS_FILE_DEFAULT_VERSION "0.4.2\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_EFFECTS_DEFAULT_VERSION</NAME>
#define AGS_FILE_EFFECTS_DEFAULT_VERSION "0.4.2\0"
</MACRO>
<MACRO>
<NAME>AGS_CLIPBOARD_DEFAULT_VERSION</NAME>
#define AGS_CLIPBOARD_DEFAULT_VERSION "0.4.2\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_FALSE</NAME>
#define AGS_FILE_FALSE "FALSE\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_TRUE</NAME>
#define AGS_FILE_TRUE "TRUE\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_BOOLEAN_PROP</NAME>
#define AGS_FILE_BOOLEAN_PROP "gboolean\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_CHAR_PROP</NAME>
#define AGS_FILE_CHAR_PROP "gchar\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_INT64_PROP</NAME>
#define AGS_FILE_INT64_PROP "gint64\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_UINT64_PROP</NAME>
#define AGS_FILE_UINT64_PROP "guint64\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_FLOAT_PROP</NAME>
#define AGS_FILE_FLOAT_PROP "gfloat\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_DOUBLE_PROP</NAME>
#define AGS_FILE_DOUBLE_PROP "gdouble\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_POINTER_PROP</NAME>
#define AGS_FILE_POINTER_PROP "gpointer\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_OBJECT_PROP</NAME>
#define AGS_FILE_OBJECT_PROP "GObject\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_BOOLEAN_POINTER_PROP</NAME>
#define AGS_FILE_BOOLEAN_POINTER_PROP "gboolean-pointer\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_CHAR_POINTER_PROP</NAME>
#define AGS_FILE_CHAR_POINTER_PROP "gchar-pointer\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_INT64_POINTER_PROP</NAME>
#define AGS_FILE_INT64_POINTER_PROP "gint64-pointer\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_UINT64_POINTER_PROP</NAME>
#define AGS_FILE_UINT64_POINTER_PROP "guint64-pointer\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_FLOAT_POINTER_PROP</NAME>
#define AGS_FILE_FLOAT_POINTER_PROP "gfloat-pointer\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_DOUBLE_POINTER_PROP</NAME>
#define AGS_FILE_DOUBLE_POINTER_PROP "gdouble-pointer\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_ID_PROP</NAME>
#define AGS_FILE_ID_PROP "id\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_NAME_PROP</NAME>
#define AGS_FILE_NAME_PROP "name\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_TYPE_PROP</NAME>
#define AGS_FILE_TYPE_PROP "type\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_CONTEXT_PROP</NAME>
#define AGS_FILE_CONTEXT_PROP "context\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_SCOPE_PROP</NAME>
#define AGS_FILE_SCOPE_PROP "scope\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_VERSION_PROP</NAME>
#define AGS_FILE_VERSION_PROP "version\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_BUILD_ID_PROP</NAME>
#define AGS_FILE_BUILD_ID_PROP "build-id\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_XPATH_PROP</NAME>
#define AGS_FILE_XPATH_PROP "xpath\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_FLAGS_PROP</NAME>
#define AGS_FILE_FLAGS_PROP "flags\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_LED</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_LED (g_type_name(AgsTypeLed))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_VINDICATOR</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_VINDICATOR (g_type_name(AgsTypeVIndicator))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_HINDICATOR</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_HINDICATOR (g_type_name(AgsTypeHIndicator))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_LABEL</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_LABEL (g_type_name(GtkTypeLabel))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_WAVEFORM</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_WAVEFORM (g_type_name(AgsTypeWaveform))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_BUTTON</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_BUTTON (g_type_name(GtkTypeButton))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_TOGGLE_BUTTON</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_TOGGLE_BUTTON (g_type_name(GtkTypeToggleButton))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_CHECK_BUTTON</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_CHECK_BUTTON (g_type_name(GtkTypeCheckButton))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_SPIN_BUTTON</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_SPIN_BUTTON (g_type_name(GtkTypeSpinButton))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_VSCALE</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_VSCALE (g_type_name(GtkTypeVScale))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_HSCALE</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_HSCALE (g_type_name(GtkTypeHScale))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_DIAL</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_DIAL (g_type_name(AgsTypeDial))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DYNAMIC_WIDGET_CARTESIAN</NAME>
#define AGS_FILE_DYNAMIC_WIDGET_CARTESIAN (g_type_name(GtkTypeCartesian))
</MACRO>
<MACRO>
<NAME>AGS_TYPE_FILE</NAME>
#define AGS_TYPE_FILE                (ags_file_get_type())
</MACRO>
<MACRO>
<NAME>AGS_FILE</NAME>
#define AGS_FILE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_FILE, AgsFile))
</MACRO>
<MACRO>
<NAME>AGS_FILE_CLASS</NAME>
#define AGS_FILE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_FILE, AgsFileClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_FILE</NAME>
#define AGS_IS_FILE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_FILE))
</MACRO>
<MACRO>
<NAME>AGS_IS_FILE_CLASS</NAME>
#define AGS_IS_FILE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_FILE))
</MACRO>
<MACRO>
<NAME>AGS_FILE_GET_CLASS</NAME>
#define AGS_FILE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_FILE, AgsFileClass))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DEFAULT_ENCODING</NAME>
#define AGS_FILE_DEFAULT_ENCODING "UTF-8\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_DEFAULT_DTD</NAME>
#define AGS_FILE_DEFAULT_DTD "ags_file.dtd\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_CHECKSUM_LENGTH</NAME>
#define AGS_FILE_CHECKSUM_LENGTH (g_checksum_type_get_length(G_CHECKSUM_MD5))
</MACRO>
<MACRO>
<NAME>AGS_FILE_DEFAULT_AUDIO_FORMAT</NAME>
#define AGS_FILE_DEFAULT_AUDIO_FORMAT "raw\0"
</MACRO>
<MACRO>
<NAME>AGS_FILE_DEFAULT_AUDIO_ENCODING</NAME>
#define AGS_FILE_DEFAULT_AUDIO_ENCODING "base64\0"
</MACRO>
<ENUM>
<NAME>AgsFileFlags</NAME>
typedef enum{
  AGS_FILE_READ                    = 1,
  AGS_FILE_READ_AUDIO_SIGNAL       = 1 << 1,
  AGS_FILE_READ_EMBEDDED_AUDIO     = 1 << 2,
  AGS_FILE_WRITE                   = 1 << 3,
  AGS_FILE_WRITE_AUDIO_SIGNAL      = 1 << 4,
  AGS_FILE_WRITE_EMBEDDED_AUDIO    = 1 << 5,
}AgsFileFlags;
</ENUM>
<STRUCT>
<NAME>AgsFile</NAME>
struct _AgsFile
{
  GObject object;

  guint flags;

  FILE *out;
  xmlChar *buffer;

  gchar *filename;
  gchar *encoding;
  gchar *dtd;

  gchar *audio_format;
  gchar *audio_encoding;

  xmlDoc *doc;
  xmlNode *root_node;

  GList *id_refs;
  GList *lookup;
  GList *launch;

  GObject *application_context;

  GObject *clipboard;
  GList *property;
  GList *script;
  GObject *cluster;
  GObject *client;
  GObject *server;

  GObject *history;

  GList *embedded_audio;
  GList *file_link;
};
</STRUCT>
<STRUCT>
<NAME>AgsFileClass</NAME>
struct _AgsFileClass
{
  GObjectClass object;

  void (*open)(AgsFile *file);
  void (*open_from_data)(AgsFile *file,
			 gchar *data, guint length);
  void (*rw_open)(AgsFile *file,
		  gboolean create);

  void (*write)(AgsFile *file);
  void (*write_concurrent)(AgsFile *file);
  void (*write_resolve)(AgsFile *file);

  void (*read)(AgsFile *file);
  void (*read_resolve)(AgsFile *file);
  void (*read_start)(AgsFile *file);
};
</STRUCT>
<FUNCTION>
<NAME>ags_file_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_str2md5</NAME>
<RETURNS>gchar * </RETURNS>
gchar *content, guint strlen 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_add_id_ref</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, GObject *id_ref 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_find_id_ref_by_node</NAME>
<RETURNS>GObject * </RETURNS>
AgsFile *file, xmlNode *node 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_find_id_ref_by_xpath</NAME>
<RETURNS>GObject * </RETURNS>
AgsFile *file, gchar *xpath 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_find_id_ref_by_reference</NAME>
<RETURNS>GObject * </RETURNS>
AgsFile *file, gpointer ref 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_add_lookup</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, GObject *file_lookup 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_add_launch</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, GObject *file_launch 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_open</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_open_from_data</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, gchar *data, guint length 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_rw_open</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, gboolean create 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_open_filename</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_close</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_concurrent</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_resolve</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_resolve</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_start</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_application_context</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GObject **application_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_application_context</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *parent, GObject *application_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_new</NAME>
<RETURNS>AgsFile * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SAVE_FILE</NAME>
#define AGS_TYPE_SAVE_FILE                (ags_save_file_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SAVE_FILE</NAME>
#define AGS_SAVE_FILE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SAVE_FILE, AgsSaveFile))
</MACRO>
<MACRO>
<NAME>AGS_SAVE_FILE_CLASS</NAME>
#define AGS_SAVE_FILE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SAVE_FILE, AgsSaveFileClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SAVE_FILE</NAME>
#define AGS_IS_SAVE_FILE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SAVE_FILE))
</MACRO>
<MACRO>
<NAME>AGS_IS_SAVE_FILE_CLASS</NAME>
#define AGS_IS_SAVE_FILE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SAVE_FILE))
</MACRO>
<MACRO>
<NAME>AGS_SAVE_FILE_GET_CLASS</NAME>
#define AGS_SAVE_FILE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SAVE_FILE, AgsSaveFileClass))
</MACRO>
<STRUCT>
<NAME>AgsSaveFile</NAME>
struct _AgsSaveFile
{
  AgsTask task;

  AgsFile *file;
};
</STRUCT>
<STRUCT>
<NAME>AgsSaveFileClass</NAME>
struct _AgsSaveFileClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_save_file_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_save_file_new</NAME>
<RETURNS>AgsSaveFile * </RETURNS>
AgsFile *file 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LISTING_EDITOR</NAME>
#define AGS_TYPE_LISTING_EDITOR                (ags_listing_editor_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LISTING_EDITOR</NAME>
#define AGS_LISTING_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LISTING_EDITOR, AgsListingEditor))
</MACRO>
<MACRO>
<NAME>AGS_LISTING_EDITOR_CLASS</NAME>
#define AGS_LISTING_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LISTING_EDITOR, AgsListingEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LISTING_EDITOR</NAME>
#define AGS_IS_LISTING_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LISTING_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_LISTING_EDITOR_CLASS</NAME>
#define AGS_IS_LISTING_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LISTING_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_LISTING_EDITOR_GET_CLASS</NAME>
#define AGS_LISTING_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_LISTING_EDITOR, AgsListingEditorClass))
</MACRO>
<STRUCT>
<NAME>AgsListingEditor</NAME>
struct _AgsListingEditor
{
  AgsPropertyListingEditor property_listing_editor;

  GType channel_type;

  GtkVBox *child;
};
</STRUCT>
<STRUCT>
<NAME>AgsListingEditorClass</NAME>
struct _AgsListingEditorClass
{
  AgsPropertyListingEditorClass property_listing_editor;
};
</STRUCT>
<FUNCTION>
<NAME>ags_listing_editor_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_listing_editor_resize</NAME>
<RETURNS>void  </RETURNS>
AgsListingEditor *listing_editor, guint pads, guint pads_old 
</FUNCTION>
<FUNCTION>
<NAME>ags_listing_editor_new</NAME>
<RETURNS>AgsListingEditor * </RETURNS>
GType channel_type 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PROPERTY_LISTING_EDITOR</NAME>
#define AGS_TYPE_PROPERTY_LISTING_EDITOR                (ags_property_listing_editor_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PROPERTY_LISTING_EDITOR</NAME>
#define AGS_PROPERTY_LISTING_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PROPERTY_LISTING_EDITOR, AgsPropertyListingEditor))
</MACRO>
<MACRO>
<NAME>AGS_PROPERTY_LISTING_EDITOR_CLASS</NAME>
#define AGS_PROPERTY_LISTING_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PROPERTY_LISTING_EDITOR, AgsPropertyListingEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PROPERTY_LISTING_EDITOR</NAME>
#define AGS_IS_PROPERTY_LISTING_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PROPERTY_LISTING_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_PROPERTY_LISTING_EDITOR_CLASS</NAME>
#define AGS_IS_PROPERTY_LISTING_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PROPERTY_LISTING_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_PROPERTY_LISTING_EDITOR_GET_CLASS</NAME>
#define AGS_PROPERTY_LISTING_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PROPERTY_LISTING_EDITOR, AgsPropertyListingEditorClass))
</MACRO>
<STRUCT>
<NAME>AgsPropertyListingEditor</NAME>
struct _AgsPropertyListingEditor
{
  AgsPropertyEditor property_editor;

  GtkVBox *child;
};
</STRUCT>
<STRUCT>
<NAME>AgsPropertyListingEditorClass</NAME>
struct _AgsPropertyListingEditorClass
{
  AgsPropertyEditorClass property_editor;
};
</STRUCT>
<FUNCTION>
<NAME>ags_property_listing_editor_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_property_listing_editor_new</NAME>
<RETURNS>AgsPropertyListingEditor * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SERVER_PREFERENCES</NAME>
#define AGS_TYPE_SERVER_PREFERENCES                (ags_server_preferences_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SERVER_PREFERENCES</NAME>
#define AGS_SERVER_PREFERENCES(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SERVER_PREFERENCES, AgsServerPreferences))
</MACRO>
<MACRO>
<NAME>AGS_SERVER_PREFERENCES_CLASS</NAME>
#define AGS_SERVER_PREFERENCES_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SERVER_PREFERENCES, AgsServerPreferencesClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SERVER_PREFERENCES</NAME>
#define AGS_IS_SERVER_PREFERENCES(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SERVER_PREFERENCES))
</MACRO>
<MACRO>
<NAME>AGS_IS_SERVER_PREFERENCES_CLASS</NAME>
#define AGS_IS_SERVER_PREFERENCES_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SERVER_PREFERENCES))
</MACRO>
<MACRO>
<NAME>AGS_SERVER_PREFERENCES_GET_CLASS</NAME>
#define AGS_SERVER_PREFERENCES_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SERVER_PREFERENCES, AgsServerPreferencesClass))
</MACRO>
<STRUCT>
<NAME>AgsServerPreferences</NAME>
struct _AgsServerPreferences
{
  GtkVBox vbox;

  GtkCheckButton *start;

  GtkEntry *address;
  GtkEntry *port;

  GtkEntry *username;
  GtkEntry *password;
};
</STRUCT>
<STRUCT>
<NAME>AgsServerPreferencesClass</NAME>
struct _AgsServerPreferencesClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_server_preferences_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_server_preferences_new</NAME>
<RETURNS>AgsServerPreferences * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PROPERTY_COLLECTION_EDITOR</NAME>
#define AGS_TYPE_PROPERTY_COLLECTION_EDITOR                (ags_property_collection_editor_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PROPERTY_COLLECTION_EDITOR</NAME>
#define AGS_PROPERTY_COLLECTION_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PROPERTY_COLLECTION_EDITOR, AgsPropertyCollectionEditor))
</MACRO>
<MACRO>
<NAME>AGS_PROPERTY_COLLECTION_EDITOR_CLASS</NAME>
#define AGS_PROPERTY_COLLECTION_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PROPERTY_COLLECTION_EDITOR, AgsPropertyCollectionEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PROPERTY_COLLECTION_EDITOR</NAME>
#define AGS_IS_PROPERTY_COLLECTION_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PROPERTY_COLLECTION_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_PROPERTY_COLLECTION_EDITOR_CLASS</NAME>
#define AGS_IS_PROPERTY_COLLECTION_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PROPERTY_COLLECTION_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_PROPERTY_COLLECTION_EDITOR_GET_CLASS</NAME>
#define AGS_PROPERTY_COLLECTION_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PROPERTY_COLLECTION_EDITOR, AgsPropertyCollectionEditorClass))
</MACRO>
<STRUCT>
<NAME>AgsPropertyCollectionEditor</NAME>
struct _AgsPropertyCollectionEditor
{
  AgsPropertyEditor property_editor;

  GType child_type;
  guint child_parameter_count;
  GParameter *child_parameter;

  GtkVBox *child;

  GtkButton *add_collection;
};
</STRUCT>
<STRUCT>
<NAME>AgsPropertyCollectionEditorClass</NAME>
struct _AgsPropertyCollectionEditorClass
{
  AgsPropertyEditorClass property_editor;
};
</STRUCT>
<FUNCTION>
<NAME>ags_property_collection_editor_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_property_collection_editor_new</NAME>
<RETURNS>AgsPropertyCollectionEditor * </RETURNS>
GType child_type, guint child_parameter_count, GParameter *child_parameter 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PERFORMANCE_PREFERENCES</NAME>
#define AGS_TYPE_PERFORMANCE_PREFERENCES                (ags_performance_preferences_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PERFORMANCE_PREFERENCES</NAME>
#define AGS_PERFORMANCE_PREFERENCES(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PERFORMANCE_PREFERENCES, AgsPerformancePreferences))
</MACRO>
<MACRO>
<NAME>AGS_PERFORMANCE_PREFERENCES_CLASS</NAME>
#define AGS_PERFORMANCE_PREFERENCES_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PERFORMANCE_PREFERENCES, AgsPerformancePreferencesClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PERFORMANCE_PREFERENCES</NAME>
#define AGS_IS_PERFORMANCE_PREFERENCES(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PERFORMANCE_PREFERENCES))
</MACRO>
<MACRO>
<NAME>AGS_IS_PERFORMANCE_PREFERENCES_CLASS</NAME>
#define AGS_IS_PERFORMANCE_PREFERENCES_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_PERFORMANCE_PREFERENCES))
</MACRO>
<MACRO>
<NAME>AGS_PERFORMANCE_PREFERENCES_GET_CLASS</NAME>
#define AGS_PERFORMANCE_PREFERENCES_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PERFORMANCE_PREFERENCES, AgsPerformancePreferencesClass))
</MACRO>
<STRUCT>
<NAME>AgsPerformancePreferences</NAME>
struct _AgsPerformancePreferences
{
  GtkVBox vbox;

  GtkCheckButton *super_threaded;
  GtkCheckButton *stream_auto_sense;
};
</STRUCT>
<STRUCT>
<NAME>AgsPerformancePreferencesClass</NAME>
struct _AgsPerformancePreferencesClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_performance_preferences_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_performance_preferences_new</NAME>
<RETURNS>AgsPerformancePreferences * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_NAVIGATION</NAME>
#define AGS_TYPE_NAVIGATION                (ags_navigation_get_type())
</MACRO>
<MACRO>
<NAME>AGS_NAVIGATION</NAME>
#define AGS_NAVIGATION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_NAVIGATION, AgsNavigation))
</MACRO>
<MACRO>
<NAME>AGS_NAVIGATION_CLASS</NAME>
#define AGS_NAVIGATION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_NAVIGATION, AgsNavigationClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_NAVIGATION</NAME>
#define AGS_IS_NAVIGATION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_NAVIGATION))
</MACRO>
<MACRO>
<NAME>AGS_IS_NAVIGATION_CLASS</NAME>
#define AGS_IS_NAVIGATION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_NAVIGATION))
</MACRO>
<MACRO>
<NAME>AGS_NAVIGATION_GET_CLASS</NAME>
#define AGS_NAVIGATION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_NAVIGATION, AgsNavigationClass))
</MACRO>
<MACRO>
<NAME>AGS_NAVIGATION_DEFAULT_TACT_STEP</NAME>
#define AGS_NAVIGATION_DEFAULT_TACT_STEP (1.0)
</MACRO>
<MACRO>
<NAME>AGS_NAVIGATION_SEEK_STEPS</NAME>
#define AGS_NAVIGATION_SEEK_STEPS (1.0)
</MACRO>
<MACRO>
<NAME>AGS_NAVIGATION_REWIND_STEPS</NAME>
#define AGS_NAVIGATION_REWIND_STEPS (4.0)
</MACRO>
<ENUM>
<NAME>AgsNavigationFlags</NAME>
typedef enum{
  AGS_NAVIGATION_BLOCK_TACT   = 1,
  AGS_NAVIGATION_BLOCK_PLAY   = 1 << 1,
}AgsNavigationFlags;
</ENUM>
<STRUCT>
<NAME>AgsNavigation</NAME>
struct _AgsNavigation
{
  GtkVBox vbox;

  guint flags;

  GObject *soundcard;

  GtkToggleButton *expander;

  GtkSpinButton *bpm;
  gdouble current_bpm;

  GtkToggleButton *rewind;
  GtkButton *previous;
  GtkToggleButton *play;
  GtkButton *stop;
  GtkButton *next;
  GtkToggleButton *forward;

  GtkCheckButton *loop;

  GtkLabel *position_time;
  GtkSpinButton *position_tact;

  GtkLabel *duration_time;
  GtkSpinButton *duration_tact;

  GtkSpinButton *loop_left_tact;
  GtkSpinButton *loop_right_tact;

  GtkCheckButton *scroll;
};
</STRUCT>
<STRUCT>
<NAME>AgsNavigationClass</NAME>
struct _AgsNavigationClass
{
  GtkVBoxClass vbox;

  void (*change_position)(AgsNavigation *navigation,
			  gdouble tact);
};
</STRUCT>
<FUNCTION>
<NAME>ags_navigation_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_tact_to_time_string</NAME>
<RETURNS>gchar * </RETURNS>
gdouble tact, gdouble bpm 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_update_time_string</NAME>
<RETURNS>void  </RETURNS>
double tact, gchar *time_string, gdouble bpm 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_set_seeking_sensitive</NAME>
<RETURNS>void  </RETURNS>
AgsNavigation *navigation, gboolean enabled 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_change_position</NAME>
<RETURNS>void  </RETURNS>
AgsNavigation *navigation, gdouble tact, gdouble bpm 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_new</NAME>
<RETURNS>AgsNavigation * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LV2_BROWSER</NAME>
#define AGS_TYPE_LV2_BROWSER                (ags_lv2_browser_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LV2_BROWSER</NAME>
#define AGS_LV2_BROWSER(obj)                (G_TYPE_CHECK_INSTANCE_CAST(obj, AGS_TYPE_LV2_BROWSER, AgsLv2Browser))
</MACRO>
<MACRO>
<NAME>AGS_LV2_BROWSER_CLASS</NAME>
#define AGS_LV2_BROWSER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_LV2_BROWSER, AgsLv2BrowserClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LV2_BROWSER</NAME>
#define AGS_IS_LV2_BROWSER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LV2_BROWSER))
</MACRO>
<MACRO>
<NAME>AGS_IS_LV2_BROWSER_CLASS</NAME>
#define AGS_IS_LV2_BROWSER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LV2_BROWSER))
</MACRO>
<MACRO>
<NAME>AGS_LV2_BROWSER_GET_CLASS</NAME>
#define AGS_LV2_BROWSER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_LV2_BROWSER, AgsLv2BrowserClass))
</MACRO>
<STRUCT>
<NAME>AgsLv2Browser</NAME>
struct _AgsLv2Browser
{
  GtkVBox vbox;

  gchar *path;

  GtkHBox *plugin;
  GtkVBox *description;

  GtkWidget *preview;
};
</STRUCT>
<STRUCT>
<NAME>AgsLv2BrowserClass</NAME>
struct _AgsLv2BrowserClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_lv2_browser_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_browser_get_plugin_filename</NAME>
<RETURNS>gchar * </RETURNS>
AgsLv2Browser *lv2_browser 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_browser_get_plugin_effect</NAME>
<RETURNS>gchar * </RETURNS>
AgsLv2Browser *lv2_browser 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_browser_combo_box_controls_new</NAME>
<RETURNS>GtkWidget * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_browser_preview_new</NAME>
<RETURNS>GtkWidget * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_browser_new</NAME>
<RETURNS>AgsLv2Browser * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_WINDOW</NAME>
#define AGS_TYPE_WINDOW                (ags_window_get_type())
</MACRO>
<MACRO>
<NAME>AGS_WINDOW</NAME>
#define AGS_WINDOW(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_WINDOW, AgsWindow))
</MACRO>
<MACRO>
<NAME>AGS_WINDOW_CLASS</NAME>
#define AGS_WINDOW_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_WINDOW, AgsWindowClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_WINDOW</NAME>
#define AGS_IS_WINDOW(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_WINDOW))
</MACRO>
<MACRO>
<NAME>AGS_IS_WINDOW_CLASS</NAME>
#define AGS_IS_WINDOW_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_WINDOW))
</MACRO>
<MACRO>
<NAME>AGS_WINDOW_GET_CLASS</NAME>
#define AGS_WINDOW_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_WINDOW, AgsWindowClass))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_COUNTER</NAME>
#define AGS_MACHINE_COUNTER(ptr) ((AgsMachineCounter *)(ptr))
</MACRO>
<ENUM>
<NAME>AgsWindowFlags</NAME>
typedef enum{
  AGS_WINDOW_READY        = 1,
  AGS_WINDOW_LOADING      = 1 << 1,
  AGS_WINDOW_SAVING       = 1 << 2,
  AGS_WINDOW_TERMINATING  = 1 << 3,
}AgsWindowFlags;
</ENUM>
<STRUCT>
<NAME>AgsWindow</NAME>
struct _AgsWindow
{
  GtkWindow window;

  guint flags;

  char *name;

  GObject *application_context;
  pthread_mutex_t *application_mutex;
  
  GObject *soundcard;

  AgsMenuBar *menu_bar;

  GtkVPaned *paned;

  GtkVBox *machines;
  GList *machine_counter;
  AgsMachine *selected;

  AgsEditor *editor;
  AgsNavigation *navigation;

  AgsAutomationEditor *automation_editor;

  AgsExportWindow *export_window;
  GtkWidget *import_window;

  AgsPreferences *preferences;
};
</STRUCT>
<STRUCT>
<NAME>AgsWindowClass</NAME>
struct _AgsWindowClass
{
  GtkWindowClass window;
};
</STRUCT>
<STRUCT>
<NAME>AgsMachineCounter</NAME>
struct _AgsMachineCounter
{
  gchar *version;
  gchar *build_id;

  GType machine_type;
  guint counter;
};
</STRUCT>
<FUNCTION>
<NAME>ags_window_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_window_find_machine_counter</NAME>
<RETURNS>AgsMachineCounter * </RETURNS>
AgsWindow *window, GType machine_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_window_increment_machine_counter</NAME>
<RETURNS>void  </RETURNS>
AgsWindow *window, GType machine_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_window_decrement_machine_counter</NAME>
<RETURNS>void  </RETURNS>
AgsWindow *window, GType machine_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_counter_alloc</NAME>
<RETURNS>AgsMachineCounter * </RETURNS>
gchar *version, gchar *build_id, GType machine_type, guint initial_value 
</FUNCTION>
<FUNCTION>
<NAME>ags_window_new</NAME>
<RETURNS>AgsWindow * </RETURNS>
GObject *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_EDITOR</NAME>
#define AGS_TYPE_EDITOR                (ags_editor_get_type ())
</MACRO>
<MACRO>
<NAME>AGS_EDITOR</NAME>
#define AGS_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_EDITOR, AgsEditor))
</MACRO>
<MACRO>
<NAME>AGS_EDITOR_CLASS</NAME>
#define AGS_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_EDITOR, AgsEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_EDITOR</NAME>
#define AGS_IS_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_EDITOR_CLASS</NAME>
#define AGS_IS_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_EDITOR_GET_CLASS</NAME>
#define AGS_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_EDITOR, AgsEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_EDITOR_DEFAULT_VERSION</NAME>
#define AGS_EDITOR_DEFAULT_VERSION "0.4.2\0"
</MACRO>
<MACRO>
<NAME>AGS_EDITOR_DEFAULT_BUILD_ID</NAME>
#define AGS_EDITOR_DEFAULT_BUILD_ID "CEST 02-10-2014 19:36\0"
</MACRO>
<MACRO>
<NAME>AGS_EDITOR_DEFAULT</NAME>
#define AGS_EDITOR_DEFAULT "default\0"
</MACRO>
<STRUCT>
<NAME>AgsEditor</NAME>
struct _AgsEditor
{
  GtkVBox vbox;

  guint flags;

  gchar *version;
  gchar *build_id;

  GObject *soundcard;

  GtkTable *table;

  AgsMachineSelector *machine_selector;
  AgsMachine *selected_machine;
  gulong set_audio_channels_handler;
  gulong set_pads_handler;

  AgsToolbar *toolbar;

  AgsNotebook *notebook;

  union AgsMeter{
    AgsPiano *piano;
    AgsSoundset *soundset;
  }meter;

  union AgsEdit{
    AgsNoteEdit *note_edit;
    AgsPatternEdit *pattern_edit;
    AgsAutomationEdit *automation_edit;
  }edit;

  guint tact_counter;
};
</STRUCT>
<STRUCT>
<NAME>AgsEditorClass</NAME>
struct _AgsEditorClass
{
  GtkVBoxClass vbox;

  void (*machine_changed)(AgsEditor *editor,
			  AgsMachine *machine);
};
</STRUCT>
<FUNCTION>
<NAME>ags_editor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_editor_machine_changed</NAME>
<RETURNS>void  </RETURNS>
AgsEditor *editor, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_editor_new</NAME>
<RETURNS>AgsEditor * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_parent_set_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsLineMember *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_dial_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *dial, AgsLineMember *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_vscale_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *vscale, AgsLineMember *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_hscale_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *hscale, AgsLineMember *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_spin_button_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *spin_button, AgsLineMember *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_check_button_clicked_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *check_button, AgsLineMember *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_toggle_button_clicked_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *toggle_button, AgsLineMember *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_button_clicked_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *button, AgsLineMember *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_port_safe_write_callback</NAME>
<RETURNS>void  </RETURNS>
AgsPort *port, GValue *value, AgsLineMember *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_browser_plugin_filename_callback</NAME>
<RETURNS>void  </RETURNS>
GtkComboBoxText *combo_box, AgsLadspaBrowser *ladspa_browser 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_browser_plugin_effect_callback</NAME>
<RETURNS>void  </RETURNS>
GtkComboBoxText *combo_box, AgsLadspaBrowser *ladspa_browser 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_XORG_APPLICATION_CONTEXT</NAME>
#define AGS_TYPE_XORG_APPLICATION_CONTEXT                (ags_xorg_application_context_get_type())
</MACRO>
<MACRO>
<NAME>AGS_XORG_APPLICATION_CONTEXT</NAME>
#define AGS_XORG_APPLICATION_CONTEXT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_XORG_APPLICATION_CONTEXT, AgsXorgApplicationContext))
</MACRO>
<MACRO>
<NAME>AGS_XORG_APPLICATION_CONTEXT_CLASS</NAME>
#define AGS_XORG_APPLICATION_CONTEXT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_XORG_APPLICATION_CONTEXT, AgsXorgApplicationContextClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_XORG_APPLICATION_CONTEXT</NAME>
#define AGS_IS_XORG_APPLICATION_CONTEXT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_XORG_APPLICATION_CONTEXT))
</MACRO>
<MACRO>
<NAME>AGS_IS_XORG_APPLICATION_CONTEXT_CLASS</NAME>
#define AGS_IS_XORG_APPLICATION_CONTEXT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_XORG_APPLICATION_CONTEXT))
</MACRO>
<MACRO>
<NAME>AGS_XORG_APPLICATION_CONTEXT_GET_CLASS</NAME>
#define AGS_XORG_APPLICATION_CONTEXT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_XORG_APPLICATION_CONTEXT, AgsXorgApplicationContextClass))
</MACRO>
<MACRO>
<NAME>AGS_XORG_VERSION</NAME>
#define AGS_XORG_VERSION "0.4.3\0"
</MACRO>
<MACRO>
<NAME>AGS_XORG_BUILD_ID</NAME>
#define AGS_XORG_BUILD_ID "Thu Apr  2 13:04:21 GMT 2015\0"
</MACRO>
<ENUM>
<NAME>AgsXorgApplicationContextFlags</NAME>
typedef enum{
  AGS_XORG_APPLICATION_CONTEXT_SHOW_GUI      = 1,
}AgsXorgApplicationContextFlags;
</ENUM>
<STRUCT>
<NAME>AgsXorgApplicationContext</NAME>
struct _AgsXorgApplicationContext
{
  AgsApplicationContext application_context;

  AgsThreadPool *thread_pool;

  AgsThread *soundcard_thread;
  AgsThread *export_thread;

  AgsThread *gui_thread;
  
  AgsThread *autosave_thread;

  AgsServer *server;
  
  GList *soundcard;
  
  AgsWindow *window;
};
</STRUCT>
<STRUCT>
<NAME>AgsXorgApplicationContextClass</NAME>
struct _AgsXorgApplicationContextClass
{
  AgsApplicationContextClass application_context;
};
</STRUCT>
<FUNCTION>
<NAME>ags_xorg_application_context_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_xorg_application_context_new</NAME>
<RETURNS>AgsXorgApplicationContext * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_export_window_file_chooser_button_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *file_chooser_button, AgsExportWindow *export_window 
</FUNCTION>
<FUNCTION>
<NAME>ags_export_window_tact_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *spin_button, AgsExportWindow *export_window 
</FUNCTION>
<FUNCTION>
<NAME>ags_export_window_export_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *toggle_button, AgsExportWindow *export_window 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PAD_EDITOR</NAME>
#define AGS_TYPE_PAD_EDITOR                (ags_pad_editor_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PAD_EDITOR</NAME>
#define AGS_PAD_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PAD_EDITOR, AgsPadEditor))
</MACRO>
<MACRO>
<NAME>AGS_PAD_EDITOR_CLASS</NAME>
#define AGS_PAD_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PAD_EDITOR, AgsPadEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PAD_EDITOR</NAME>
#define AGS_IS_PAD_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PAD_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_PAD_EDITOR_CLASS</NAME>
#define AGS_IS_PAD_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PAD_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_PAD_EDITOR_GET_CLASS</NAME>
#define AGS_PAD_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_PAD_EDITOR, AgsPadEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_PAD_EDITOR_DEFAULT_VERSION</NAME>
#define AGS_PAD_EDITOR_DEFAULT_VERSION "0.4.2\0"
</MACRO>
<MACRO>
<NAME>AGS_PAD_EDITOR_DEFAULT_BUILD_ID</NAME>
#define AGS_PAD_EDITOR_DEFAULT_BUILD_ID "CEST 02-10-2014 19:36\0"
</MACRO>
<STRUCT>
<NAME>AgsPadEditor</NAME>
struct _AgsPadEditor
{
  GtkVBox vbox;

  gchar *version;
  gchar *build_id;
  
  AgsChannel *pad;

  GtkExpander *line_editor_expander;
  GtkVBox *line_editor;
};
</STRUCT>
<STRUCT>
<NAME>AgsPadEditorClass</NAME>
struct _AgsPadEditorClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_pad_editor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_editor_set_channel</NAME>
<RETURNS>void  </RETURNS>
AgsPadEditor *pad_editor, AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_editor_resize_lines</NAME>
<RETURNS>void  </RETURNS>
AgsPadEditor *pad_editor, guint audio_channels, guint audio_channels_old 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_editor_new</NAME>
<RETURNS>AgsPadEditor * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_parent_set_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_destroy_callback</NAME>
<RETURNS>gboolean  </RETURNS>
GtkObject *object, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_show_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_expander_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_bpm_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_rewind_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_prev_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_play_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_stop_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_next_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_forward_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_loop_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_position_tact_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_duration_tact_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_loop_left_tact_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_loop_right_tact_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_raster_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_navigation_tic_callback</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, AgsNavigation *navigation 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LINE_EDITOR</NAME>
#define AGS_TYPE_LINE_EDITOR                (ags_line_editor_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LINE_EDITOR</NAME>
#define AGS_LINE_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LINE_EDITOR, AgsLineEditor))
</MACRO>
<MACRO>
<NAME>AGS_LINE_EDITOR_CLASS</NAME>
#define AGS_LINE_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LINE_EDITOR, AgsLineEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINE_EDITOR</NAME>
#define AGS_IS_LINE_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LINE_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINE_EDITOR_CLASS</NAME>
#define AGS_IS_LINE_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LINE_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_LINE_EDITOR_GET_CLASS</NAME>
#define AGS_LINE_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_LINE_EDITOR, AgsLineEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_LINE_EDITOR_DEFAULT_VERSION</NAME>
#define AGS_LINE_EDITOR_DEFAULT_VERSION "0.4.2\0"
</MACRO>
<MACRO>
<NAME>AGS_LINE_EDITOR_DEFAULT_BUILD_ID</NAME>
#define AGS_LINE_EDITOR_DEFAULT_BUILD_ID "CEST 02-10-2014 19:36\0"
</MACRO>
<STRUCT>
<NAME>AgsLineEditor</NAME>
struct _AgsLineEditor
{
  GtkVBox vbox;

  gchar *version;
  gchar *build_id;

  AgsChannel *channel;

  AgsLinkEditor *link_editor;
  AgsLineMemberEditor *member_editor;
};
</STRUCT>
<STRUCT>
<NAME>AgsLineEditorClass</NAME>
struct _AgsLineEditorClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_line_editor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_editor_set_channel</NAME>
<RETURNS>void  </RETURNS>
AgsLineEditor *line_editor, AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_editor_new</NAME>
<RETURNS>AgsLineEditor * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_xorg_init_context</NAME>
<RETURNS>void  </RETURNS>
AgsApplicationContext *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLUGIN_PREFERENCES</NAME>
#define AGS_TYPE_PLUGIN_PREFERENCES                (ags_plugin_preferences_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLUGIN_PREFERENCES</NAME>
#define AGS_PLUGIN_PREFERENCES(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLUGIN_PREFERENCES, AgsPluginPreferences))
</MACRO>
<MACRO>
<NAME>AGS_PLUGIN_PREFERENCES_CLASS</NAME>
#define AGS_PLUGIN_PREFERENCES_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PLUGIN_PREFERENCES, AgsPluginPreferencesClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLUGIN_PREFERENCES</NAME>
#define AGS_IS_PLUGIN_PREFERENCES(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PLUGIN_PREFERENCES))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLUGIN_PREFERENCES_CLASS</NAME>
#define AGS_IS_PLUGIN_PREFERENCES_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_PLUGIN_PREFERENCES))
</MACRO>
<MACRO>
<NAME>AGS_PLUGIN_PREFERENCES_GET_CLASS</NAME>
#define AGS_PLUGIN_PREFERENCES_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PLUGIN_PREFERENCES, AgsPluginPreferencesClass))
</MACRO>
<STRUCT>
<NAME>AgsPluginPreferences</NAME>
struct _AgsPluginPreferences
{
  GtkVBox vbox;

  AgsLadspaPluginPreferences *ladspa_plugin_preferencens;
};
</STRUCT>
<STRUCT>
<NAME>AgsPluginPreferencesClass</NAME>
struct _AgsPluginPreferencesClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<STRUCT>
<NAME>AgsLadspaPluginPreferences</NAME>
struct _AgsLadspaPluginPreferences
{
  GtkEntry *ladspa_path;
  GtkCellView *plugin_file;
};
</STRUCT>
<FUNCTION>
<NAME>ags_plugin_preferences_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_plugin_preferences_alloc</NAME>
<RETURNS>AgsLadspaPluginPreferences * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_preferences_new</NAME>
<RETURNS>AgsPluginPreferences * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUDIO_PREFERENCES</NAME>
#define AGS_TYPE_AUDIO_PREFERENCES                (ags_audio_preferences_get_type())
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_PREFERENCES</NAME>
#define AGS_AUDIO_PREFERENCES(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUDIO_PREFERENCES, AgsAudioPreferences))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_PREFERENCES_CLASS</NAME>
#define AGS_AUDIO_PREFERENCES_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_AUDIO_PREFERENCES, AgsAudioPreferencesClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_PREFERENCES</NAME>
#define AGS_IS_AUDIO_PREFERENCES(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_AUDIO_PREFERENCES))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_PREFERENCES_CLASS</NAME>
#define AGS_IS_AUDIO_PREFERENCES_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_AUDIO_PREFERENCES))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_PREFERENCES_GET_CLASS</NAME>
#define AGS_AUDIO_PREFERENCES_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_AUDIO_PREFERENCES, AgsAudioPreferencesClass))
</MACRO>
<STRUCT>
<NAME>AgsAudioPreferences</NAME>
struct _AgsAudioPreferences
{
  GtkVBox vbox;

  GtkComboBox *card;
  GtkSpinButton *audio_channels;
  GtkSpinButton *samplerate;
  GtkSpinButton *buffer_size;
};
</STRUCT>
<STRUCT>
<NAME>AgsAudioPreferencesClass</NAME>
struct _AgsAudioPreferencesClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_audio_preferences_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_preferences_new</NAME>
<RETURNS>AgsAudioPreferences * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_editor_parent_set_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget  *widget, GtkObject *old_parent, AgsEditor *editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_editor_set_audio_channels_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, guint audio_channels, guint audio_channels_old, AgsEditor *editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_editor_set_pads_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GType channel_type, guint pads, guint pads_old, AgsEditor *editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_editor_machine_changed_callback</NAME>
<RETURNS>void  </RETURNS>
AgsMachineSelector *machine_selector, AgsMachine *machine, AgsEditor *editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_editor_change_position_callback</NAME>
<RETURNS>void  </RETURNS>
AgsNavigation *navigation, gdouble tact, AgsEditor *editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_editor_edit_vscrollbar_value_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *note_edit, AgsEditor *editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_property_collection_editor_add_collection_callback</NAME>
<RETURNS>void  </RETURNS>
GtkButton *button, AgsPropertyCollectionEditor *property_collection_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_property_collection_editor_remove_collection_callback</NAME>
<RETURNS>void  </RETURNS>
GtkButton *button, GtkTable *table 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LINK_EDITOR</NAME>
#define AGS_TYPE_LINK_EDITOR                (ags_link_editor_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LINK_EDITOR</NAME>
#define AGS_LINK_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST(obj, AGS_TYPE_LINK_EDITOR, AgsLinkEditor))
</MACRO>
<MACRO>
<NAME>AGS_LINK_EDITOR_CLASS</NAME>
#define AGS_LINK_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_LINK_EDITOR, AgsLinkEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINK_EDITOR</NAME>
#define AGS_IS_LINK_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LINK_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINK_EDITOR_CLASS</NAME>
#define AGS_IS_LINK_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LINK_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_LINK_EDITOR_GET_CLASS</NAME>
#define AGS_LINK_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_LINK_EDITOR, AgsLinkEditorClass))
</MACRO>
<ENUM>
<NAME>AgsLinkEditorFlags</NAME>
typedef enum{
  AGS_LINK_EDITOR_FILE_CHOOSER_PLAY_DONE = 1,
}AgsLinkEditorFlags;
</ENUM>
<STRUCT>
<NAME>AgsLinkEditor</NAME>
struct _AgsLinkEditor
{
  GtkHBox hbox;

  guint flags;

  GtkComboBox *combo;
  GtkSpinButton *spin_button;

  AgsAudioFile *audio_file;

  GtkFileChooserDialog *file_chooser;
};
</STRUCT>
<STRUCT>
<NAME>AgsLinkEditorClass</NAME>
struct _AgsLinkEditorClass
{
  GtkHBoxClass hbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_link_editor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_editor_new</NAME>
<RETURNS>AgsLinkEditor * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_listing_editor_parent_set_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsListingEditor *listing_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_parent_set_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsBulkMember *bulk_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_dial_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *dial, AgsBulkMember *bulk_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_vscale_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *vscale, AgsBulkMember *bulk_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_hscale_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *hscale, AgsBulkMember *bulk_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_spin_button_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *spin_button, AgsBulkMember *bulk_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_check_button_clicked_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *check_button, AgsBulkMember *bulk_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_toggle_button_clicked_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *toggle_button, AgsBulkMember *bulk_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_button_clicked_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *button, AgsBulkMember *bulk_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_port_safe_write_callback</NAME>
<RETURNS>void  </RETURNS>
AgsPort *port, GValue *value, AgsBulkMember *bulk_member 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MENU_BAR</NAME>
#define AGS_TYPE_MENU_BAR                (ags_menu_bar_get_type ())
</MACRO>
<MACRO>
<NAME>AGS_MENU_BAR</NAME>
#define AGS_MENU_BAR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MENU_BAR, AgsMenuBar))
</MACRO>
<MACRO>
<NAME>AGS_MENU_BAR_CLASS</NAME>
#define AGS_MENU_BAR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MENU_BAR, AgsMenuBarClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MENU_BAR</NAME>
#define AGS_IS_MENU_BAR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_MENU_BAR))
</MACRO>
<MACRO>
<NAME>AGS_IS_MENU_BAR_CLASS</NAME>
#define AGS_IS_MENU_BAR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MENU_BAR))
</MACRO>
<MACRO>
<NAME>AGS_MENU_BAR_GET_CLASS</NAME>
#define AGS_MENU_BAR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_MENU_BAR, AgsMenuBarClass))
</MACRO>
<MACRO>
<NAME>AGS_MENU_BAR_LADSPA_FILENAME_KEY</NAME>
#define AGS_MENU_BAR_LADSPA_FILENAME_KEY "ags-menu-bar-ladspa-filename\0"
</MACRO>
<MACRO>
<NAME>AGS_MENU_BAR_LADSPA_EFFECT_KEY</NAME>
#define AGS_MENU_BAR_LADSPA_EFFECT_KEY "ags-menu-bar-ladspa-effect\0"
</MACRO>
<MACRO>
<NAME>AGS_MENU_BAR_LV2_FILENAME_KEY</NAME>
#define AGS_MENU_BAR_LV2_FILENAME_KEY "ags-menu-bar-lv2-filename\0"
</MACRO>
<MACRO>
<NAME>AGS_MENU_BAR_LV2_URI_KEY</NAME>
#define AGS_MENU_BAR_LV2_URI_KEY "ags-menu-bar-lv2-uri\0"
</MACRO>
<STRUCT>
<NAME>AgsMenuBar</NAME>
struct _AgsMenuBar
{
  GtkMenuBar menu_bar;

  GtkMenu *file;
  
  GtkMenu *edit;
  GtkMenu *add;
  GtkMenu *bridge;
  GtkMenu *ladspa;
  GtkMenu *lv2;
  
  GtkMenu *help;
};
</STRUCT>
<STRUCT>
<NAME>AgsMenuBarClass</NAME>
struct _AgsMenuBarClass
{
  GtkMenuBarClass menu_bar;
};
</STRUCT>
<FUNCTION>
<NAME>ags_menu_bar_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_new</NAME>
<RETURNS>AgsMenuBar * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_zoom_menu_new</NAME>
<RETURNS>GtkMenu * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_tact_menu_new</NAME>
<RETURNS>GtkMenu * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_menu_new</NAME>
<RETURNS>GtkMenu * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_menu_new</NAME>
<RETURNS>GtkMenu * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_zoom_combo_box_new</NAME>
<RETURNS>GtkComboBox * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_tact_combo_box_new</NAME>
<RETURNS>GtkComboBox * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PREFERENCES</NAME>
#define AGS_TYPE_PREFERENCES                (ags_preferences_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PREFERENCES</NAME>
#define AGS_PREFERENCES(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PREFERENCES, AgsPreferences))
</MACRO>
<MACRO>
<NAME>AGS_PREFERENCES_CLASS</NAME>
#define AGS_PREFERENCES_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PREFERENCES, AgsPreferencesClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PREFERENCES</NAME>
#define AGS_IS_PREFERENCES(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PREFERENCES))
</MACRO>
<MACRO>
<NAME>AGS_IS_PREFERENCES_CLASS</NAME>
#define AGS_IS_PREFERENCES_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_PREFERENCES))
</MACRO>
<MACRO>
<NAME>AGS_PREFERENCES_GET_CLASS</NAME>
#define AGS_PREFERENCES_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PREFERENCES, AgsPreferencesClass))
</MACRO>
<MACRO>
<NAME>AGS_PREFERENCES_DEFAULT_FILENAME</NAME>
#define AGS_PREFERENCES_DEFAULT_FILENAME "ags_current.xml\0"
</MACRO>
<ENUM>
<NAME>AgsPreferencesFlags</NAME>
typedef enum{
  AGS_PREFERENCES_SHUTDOWN               = 1,
}AgsPreferencesFlags;
</ENUM>
<STRUCT>
<NAME>AgsPreferences</NAME>
struct _AgsPreferences
{
  GtkDialog dialog;

  guint flags;

  GtkWindow *parent;

  AgsGenericPreferences *generic_preferences;
  AgsAudioPreferences *audio_preferences;
  AgsPerformancePreferences *performance_preferences;
  AgsServerPreferences *server_preferences;
};
</STRUCT>
<STRUCT>
<NAME>AgsPreferencesClass</NAME>
struct _AgsPreferencesClass
{
  GtkDialogClass dialog;
};
</STRUCT>
<FUNCTION>
<NAME>ags_preferences_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_preferences_new</NAME>
<RETURNS>AgsPreferences * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_editor_add_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *button, AgsLineMemberEditor *line_member_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_editor_remove_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *button, AgsLineMemberEditor *line_member_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_editor_plugin_browser_response_callback</NAME>
<RETURNS>void  </RETURNS>
GtkDialog *dialog, gint response, AgsLineMemberEditor *line_member_editor 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PAD</NAME>
#define AGS_TYPE_PAD                (ags_pad_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PAD</NAME>
#define AGS_PAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PAD, AgsPad))
</MACRO>
<MACRO>
<NAME>AGS_PAD_CLASS</NAME>
#define AGS_PAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PAD, AgsPadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PAD</NAME>
#define AGS_IS_PAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_PAD_CLASS</NAME>
#define AGS_IS_PAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_PAD))
</MACRO>
<MACRO>
<NAME>AGS_PAD_GET_CLASS</NAME>
#define AGS_PAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PAD, AgsPadClass))
</MACRO>
<MACRO>
<NAME>AGS_PAD_DEFAULT_VERSION</NAME>
#define AGS_PAD_DEFAULT_VERSION "0.4.2\0"
</MACRO>
<MACRO>
<NAME>AGS_PAD_DEFAULT_BUILD_ID</NAME>
#define AGS_PAD_DEFAULT_BUILD_ID "CEST 02-10-2014 19:36\0"
</MACRO>
<ENUM>
<NAME>AgsPadFlags</NAME>
typedef enum{
  AGS_PAD_CONNECTED           = 1,
  AGS_PAD_SHOW_GROUPING       = 1 << 1,
  AGS_PAD_GROUP_ALL           = 1 << 2,
  AGS_PAD_GROUP_LINE          = 1 << 3,
  AGS_PAD_MAPPED_RECALL       = 1 << 4,
  AGS_PAD_PREMAPPED_RECALL    = 1 << 5,
}AgsPadFlags;
</ENUM>
<STRUCT>
<NAME>AgsPad</NAME>
struct _AgsPad
{
  GtkVBox vbox;

  guint flags;

  gchar *name;

  gchar *version;
  gchar *build_id;

  AgsChannel *channel;

  guint cols;
  AgsExpanderSet *expander_set;

  GtkToggleButton *group;
  GtkToggleButton *mute;
  GtkToggleButton *solo;

  GtkToggleButton *play;
};
</STRUCT>
<STRUCT>
<NAME>AgsPadClass</NAME>
struct _AgsPadClass
{
  GtkVBoxClass vbox;

  void (*set_channel)(AgsPad *pad, AgsChannel *channel);

  void (*resize_lines)(AgsPad *pad, GType line_type,
		       guint audio_channels, guint audio_channels_old);
  void (*map_recall)(AgsPad *pad,
		     guint output_pad_start);
  GList* (*find_port)(AgsPad *pad);
};
</STRUCT>
<FUNCTION>
<NAME>ags_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_set_channel</NAME>
<RETURNS>void  </RETURNS>
AgsPad *pad, AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_resize_lines</NAME>
<RETURNS>void  </RETURNS>
AgsPad *pad, GType line_type, guint audio_channels, guint audio_channels_old 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_map_recall</NAME>
<RETURNS>void  </RETURNS>
AgsPad *pad, guint output_pad_start 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_find_port</NAME>
<RETURNS>GList * </RETURNS>
AgsPad *pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_new</NAME>
<RETURNS>AgsPad * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_collection_editor_parent_set_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsLinkCollectionEditor *link_collection_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_collection_editor_link_callback</NAME>
<RETURNS>void  </RETURNS>
GtkComboBox *combo, AgsLinkCollectionEditor *link_collection_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_collection_editor_first_line_callback</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton *spin_button, AgsLinkCollectionEditor *link_collection_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_collection_editor_first_link_callback</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton *spin_button, AgsLinkCollectionEditor *link_collection_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_collection_editor_count_callback</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton *spin_button, AgsLinkCollectionEditor *link_collection_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_generic_preferences_autosave_thread_clicked_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *check_button, AgsGenericPreferences *generic_preferences 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_EXPORT_WINDOW</NAME>
#define AGS_TYPE_EXPORT_WINDOW                (ags_export_window_get_type())
</MACRO>
<MACRO>
<NAME>AGS_EXPORT_WINDOW</NAME>
#define AGS_EXPORT_WINDOW(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_EXPORT_WINDOW, AgsExportWindow))
</MACRO>
<MACRO>
<NAME>AGS_EXPORT_WINDOW_CLASS</NAME>
#define AGS_EXPORT_WINDOW_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_EXPORT_WINDOW, AgsExportWindowClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_EXPORT_WINDOW</NAME>
#define AGS_IS_EXPORT_WINDOW(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_EXPORT_WINDOW))
</MACRO>
<MACRO>
<NAME>AGS_IS_EXPORT_WINDOW_CLASS</NAME>
#define AGS_IS_EXPORT_WINDOW_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_EXPORT_WINDOW))
</MACRO>
<MACRO>
<NAME>AGS_EXPORT_WINDOW_GET_CLASS</NAME>
#define AGS_EXPORT_WINDOW_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_EXPORT_WINDOW, AgsExportWindowClass))
</MACRO>
<ENUM>
<NAME>AgsExportWindowFlags</NAME>
typedef enum{
  AGS_EXPORT_WINDOW_LIVE_EXPORT   = 1,
}AgsExportWindowFlags;
</ENUM>
<STRUCT>
<NAME>AgsExportWindow</NAME>
struct _AgsExportWindow
{
  GtkWindow window;

  guint flags;

  GtkWindow *parent;
  GObject *soundcard;

  GtkCheckButton *live_export;

  GtkEntry *filename;
  GtkFileChooserButton *file_chooser_button;

  GtkComboBoxText *mode;
  GtkSpinButton *tact;
  GtkLabel *duration;
  GtkComboBoxText *output_format;

  GtkToggleButton *export;
};
</STRUCT>
<STRUCT>
<NAME>AgsExportWindowClass</NAME>
struct _AgsExportWindowClass
{
  GtkWindowClass window;
};
</STRUCT>
<FUNCTION>
<NAME>ags_export_window_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_export_window_new</NAME>
<RETURNS>AgsExportWindow * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_parent_set_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsPad *pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_option_changed_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsPad *pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_group_clicked_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsPad *pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_mute_clicked_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsPad *pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_solo_clicked_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsPad *pad 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LINE</NAME>
#define AGS_TYPE_LINE                (ags_line_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LINE</NAME>
#define AGS_LINE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LINE, AgsLine))
</MACRO>
<MACRO>
<NAME>AGS_LINE_CLASS</NAME>
#define AGS_LINE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LINE, AgsLineClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINE</NAME>
#define AGS_IS_LINE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LINE))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINE_CLASS</NAME>
#define AGS_IS_LINE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LINE))
</MACRO>
<MACRO>
<NAME>AGS_LINE_GET_CLASS</NAME>
#define AGS_LINE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_LINE, AgsLineClass))
</MACRO>
<MACRO>
<NAME>AGS_LINE_DEFAULT_VERSION</NAME>
#define AGS_LINE_DEFAULT_VERSION "0.4.2\0"
</MACRO>
<MACRO>
<NAME>AGS_LINE_DEFAULT_BUILD_ID</NAME>
#define AGS_LINE_DEFAULT_BUILD_ID "CEST 02-10-2014 19:36\0"
</MACRO>
<ENUM>
<NAME>AgsLineFlags</NAME>
typedef enum{
  AGS_LINE_CONNECTED         = 1,
  AGS_LINE_GROUPED           = 1 << 1,
  AGS_LINE_MAPPED_RECALL     = 1 << 2,
  AGS_LINE_PREMAPPED_RECALL  = 1 << 3,
}AgsLineFlags;
</ENUM>
<STRUCT>
<NAME>AgsLine</NAME>
struct _AgsLine
{
  GtkVBox vbox;

  guint flags;

  gchar *version;
  gchar *build_id;

  gchar *name;

  AgsChannel *channel;

  GtkWidget *pad;

  GtkLabel *label;
  GtkToggleButton *group;

  AgsExpander *expander;
};
</STRUCT>
<STRUCT>
<NAME>AgsLineClass</NAME>
struct _AgsLineClass
{
  GtkVBoxClass vbox;

  void (*set_channel)(AgsLine *line, AgsChannel *channel);

  void (*group_changed)(AgsLine *line);
  
  GList* (*add_effect)(AgsLine *line,
		     gchar *filename,
		     gchar *effect);
  void (*remove_effect)(AgsLine *line,
			guint nth);
  
  void (*map_recall)(AgsLine *line,
		     guint output_pad_start);
  GList (*find_port)(AgsLine *line);
};
</STRUCT>
<FUNCTION>
<NAME>ags_line_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_set_channel</NAME>
<RETURNS>void  </RETURNS>
AgsLine *line, AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_group_changed</NAME>
<RETURNS>void  </RETURNS>
AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_find_next_grouped</NAME>
<RETURNS>GList * </RETURNS>
GList *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_add_effect</NAME>
<RETURNS>GList * </RETURNS>
AgsLine *line, gchar *filename, gchar *effect 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_remove_effect</NAME>
<RETURNS>void  </RETURNS>
AgsLine *line, guint nth 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_map_recall</NAME>
<RETURNS>void  </RETURNS>
AgsLine *line, guint output_pad_start 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_find_port</NAME>
<RETURNS>GList * </RETURNS>
AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_new</NAME>
<RETURNS>AgsLine * </RETURNS>
GtkWidget *pad, AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_BULK_MEMBER</NAME>
#define AGS_TYPE_BULK_MEMBER                (ags_bulk_member_get_type())
</MACRO>
<MACRO>
<NAME>AGS_BULK_MEMBER</NAME>
#define AGS_BULK_MEMBER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_BULK_MEMBER, AgsBulkMember))
</MACRO>
<MACRO>
<NAME>AGS_BULK_MEMBER_CLASS</NAME>
#define AGS_BULK_MEMBER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_BULK_MEMBER, AgsBulkMemberClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_BULK_MEMBER</NAME>
#define AGS_IS_BULK_MEMBER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_BULK_MEMBER))
</MACRO>
<MACRO>
<NAME>AGS_IS_BULK_MEMBER_CLASS</NAME>
#define AGS_IS_BULK_MEMBER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_BULK_MEMBER))
</MACRO>
<MACRO>
<NAME>AGS_BULK_MEMBER_GET_CLASS</NAME>
#define AGS_BULK_MEMBER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_BULK_MEMBER, AgsBulkMemberClass))
</MACRO>
<MACRO>
<NAME>AGS_BULK_PORT</NAME>
#define AGS_BULK_PORT(ptr) ((AgsBulkPort *)(ptr))
</MACRO>
<ENUM>
<NAME>AgsBulkMemberFlags</NAME>
typedef enum{
  AGS_BULK_MEMBER_DEFAULT_TEMPLATE      = 1,
  AGS_BULK_MEMBER_RESET_BY_ATOMIC       = 1 << 1,
  AGS_BULK_MEMBER_RESET_BY_TASK         = 1 << 2,
  AGS_BULK_MEMBER_APPLY_RECALL          = 1 << 3,
}AgsBulkMemberFlags;
</ENUM>
<STRUCT>
<NAME>AgsBulkMember</NAME>
struct _AgsBulkMember
{
  GtkFrame frame;

  guint flags;

  GType widget_type;
  gchar *widget_label;

  gchar *filename;
  gchar *effect;
  
  gchar *plugin_name;
  gchar *specifier;

  gchar *control_port;

  GList *bulk_port;
  
  GType task_type;
};
</STRUCT>
<STRUCT>
<NAME>AgsBulkMemberClass</NAME>
struct _AgsBulkMemberClass
{
  GtkFrameClass frame;

  void (*change_port)(AgsBulkMember *bulk_member,
		      gpointer port_data);
};
</STRUCT>
<STRUCT>
<NAME>AgsBulkPort</NAME>
struct _AgsBulkPort
{
  AgsPort *port;
  gpointer port_data;
  gboolean active;

  AgsPort *recall_port;
  gpointer recall_port_data;
  gboolean recall_active;
};
</STRUCT>
<FUNCTION>
<NAME>ags_bulk_member_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_port_alloc</NAME>
<RETURNS>AgsBulkPort * </RETURNS>
AgsPort *port, AgsPort *recall_port 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_get_widget</NAME>
<RETURNS>GtkWidget * </RETURNS>
AgsBulkMember *bulk_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_set_label</NAME>
<RETURNS>void  </RETURNS>
AgsBulkMember *bulk_member, gchar *label 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_change_port</NAME>
<RETURNS>void  </RETURNS>
AgsBulkMember *bulk_member, gpointer port_data 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_find_port</NAME>
<RETURNS>void  </RETURNS>
AgsBulkMember *bulk_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_bulk_member_new</NAME>
<RETURNS>AgsBulkMember * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MACHINE</NAME>
#define AGS_TYPE_MACHINE                (ags_machine_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MACHINE</NAME>
#define AGS_MACHINE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MACHINE, AgsMachine))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_CLASS</NAME>
#define AGS_MACHINE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MACHINE, AgsMachineClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MACHINE</NAME>
#define AGS_IS_MACHINE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_MACHINE))
</MACRO>
<MACRO>
<NAME>AGS_IS_MACHINE_CLASS</NAME>
#define AGS_IS_MACHINE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_MACHINE))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_GET_CLASS</NAME>
#define AGS_MACHINE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_MACHINE, AgsMachineClass))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_DEFAULT_VERSION</NAME>
#define AGS_MACHINE_DEFAULT_VERSION "0.4.2\0"
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_DEFAULT_BUILD_ID</NAME>
#define AGS_MACHINE_DEFAULT_BUILD_ID "CEST 02-10-2014 19:36\0"
</MACRO>
<ENUM>
<NAME>AgsMachineFlags</NAME>
typedef enum{
  AGS_MACHINE_SOLO              = 1,
  AGS_MACHINE_IS_EFFECT         = 1 <<  1,
  AGS_MACHINE_IS_SEQUENCER      = 1 <<  2,
  AGS_MACHINE_IS_SYNTHESIZER    = 1 <<  3,
  AGS_MACHINE_TAKES_FILE_INPUT  = 1 <<  4,
  AGS_MACHINE_MAPPED_RECALL     = 1 <<  5,
  AGS_MACHINE_PREMAPPED_RECALL  = 1 <<  6,
  AGS_MACHINE_BLOCK_PLAY        = 1 <<  7,
  AGS_MACHINE_BLOCK_STOP        = 1 <<  8,
  AGS_MACHINE_CONNECTED         = 1 <<  9,
}AgsMachineFlags;
</ENUM>
<ENUM>
<NAME>AgsMachineFileInputFlags</NAME>
typedef enum{
  AGS_MACHINE_ACCEPT_WAV          = 1,
  AGS_MACHINE_ACCEPT_OGG          = 1 <<  1,
  AGS_MACHINE_ACCEPT_SOUNDFONT2   = 1 <<  2,
}AgsMachineFileInputFlags;
</ENUM>
<STRUCT>
<NAME>AgsMachine</NAME>
struct _AgsMachine
{
  GtkHandleBox handle_box;

  GObject *ags_main;

  char *name;

  gchar *version;
  gchar *build_id;

  guint flags;
  guint file_input_flags;

  AgsAudio *audio;

  GtkToggleButton *play;

  GType output_pad_type;
  GType output_line_type;
  GtkContainer *output;

  GType input_pad_type;
  GType input_line_type;
  GtkContainer *input;

  GtkContainer *bridge;
  
  GList *port;

  GtkMenu *popup;
  GtkDialog *properties;
  GtkDialog *rename;
};
</STRUCT>
<STRUCT>
<NAME>AgsMachineClass</NAME>
struct _AgsMachineClass
{
  GtkHandleBoxClass handle_box;

  void (*map_recall)(AgsMachine *machine);
  GList* (*find_port)(AgsMachine *machine);
};
</STRUCT>
<FUNCTION>
<NAME>ags_machine_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_set_audio_channels</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, guint audio_channels, guint audio_channels_old, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_set_pads</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GType type, guint pads, guint pads_old, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_add_default_recalls</NAME>
<DEPRECATED/>
<RETURNS>void  </RETURNS>
AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_map_recall</NAME>
<RETURNS>void  </RETURNS>
AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_get_possible_links</NAME>
<RETURNS>GtkListStore * </RETURNS>
AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_find_by_name</NAME>
<RETURNS>AgsMachine * </RETURNS>
GList *list, char *name 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_find_port</NAME>
<RETURNS>GList * </RETURNS>
AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_set_run</NAME>
<RETURNS>void  </RETURNS>
AgsMachine *machine, gboolean run 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_file_chooser_dialog_new</NAME>
<RETURNS>GtkFileChooserDialog * </RETURNS>
AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_open_files</NAME>
<RETURNS>void  </RETURNS>
AgsMachine *machine, GSList *filenames, gboolean overwrite_channels, gboolean create_channels 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_new</NAME>
<RETURNS>AgsMachine * </RETURNS>
GObject *soundcard 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUTOMATION_EDITOR</NAME>
#define AGS_TYPE_AUTOMATION_EDITOR                (ags_automation_editor_get_type())
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_EDITOR</NAME>
#define AGS_AUTOMATION_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUTOMATION_EDITOR, AgsAutomationEditor))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_EDITOR_CLASS</NAME>
#define AGS_AUTOMATION_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_AUTOMATION_EDITOR, AgsAutomationEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUTOMATION_EDITOR</NAME>
#define AGS_IS_AUTOMATION_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_AUTOMATION_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUTOMATION_EDITOR_CLASS</NAME>
#define AGS_IS_AUTOMATION_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_AUTOMATION_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_EDITOR_GET_CLASS</NAME>
#define AGS_AUTOMATION_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_AUTOMATION_EDITOR, AgsAutomationEditorClass))
</MACRO>
<STRUCT>
<NAME>AgsAutomationEditor</NAME>
struct _AgsAutomationEditor
{
  GtkDialog dialog;

  gchar *version;
  gchar *build_id;

  GObject *window;

  AgsMachineSelector *machine_selector;
  AgsMachine *selected_machine;
  gulong set_audio_channels_handler;
  gulong set_pads_handler;

  AgsAutomationToolbar *automation_toolbar;

  AgsAutomationEdit *automation_edit;
};
</STRUCT>
<STRUCT>
<NAME>AgsAutomationEditorClass</NAME>
struct _AgsAutomationEditorClass
{
  GtkDialogClass dialog;

  void (*machine_changed)(AgsAutomationEditor *automation_editor,
			  AgsMachine *machine);
};
</STRUCT>
<FUNCTION>
<NAME>ags_automation_editor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_editor_machine_changed</NAME>
<RETURNS>void  </RETURNS>
AgsAutomationEditor *automation_editor, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_editor_new</NAME>
<RETURNS>AgsAutomationEditor * </RETURNS>
GObject *window 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MACHINE_EDITOR</NAME>
#define AGS_TYPE_MACHINE_EDITOR                (ags_machine_editor_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_EDITOR</NAME>
#define AGS_MACHINE_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MACHINE_EDITOR, AgsMachineEditor))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_EDITOR_CLASS</NAME>
#define AGS_MACHINE_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MACHINE_EDITOR, AgsMachineEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MACHINE_EDITOR</NAME>
#define AGS_IS_MACHINE_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_MACHINE_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_MACHINE_EDITOR_CLASS</NAME>
#define AGS_IS_MACHINE_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MACHINE_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_EDITOR_GET_CLASS</NAME>
#define AGS_MACHINE_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_MACHINE_EDITOR, AgsMachineEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_EDITOR_DEFAULT_VERSION</NAME>
#define AGS_MACHINE_EDITOR_DEFAULT_VERSION "0.4.2\0"
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_EDITOR_DEFAULT_BUILD_ID</NAME>
#define AGS_MACHINE_EDITOR_DEFAULT_BUILD_ID "CEST 02-10-2014 19:36\0"
</MACRO>
<ENUM>
<NAME>AgsMachineEditorFlags</NAME>
typedef enum{
  AGS_MACHINE_EDITOR_CLOSING   =  1,
}AgsMachineEditorFlags;
</ENUM>
<STRUCT>
<NAME>AgsMachineEditor</NAME>
struct _AgsMachineEditor
{
  GtkDialog dialog;

  guint flags;

  gchar *version;
  gchar *build_id;

  GtkWindow *parent;
  AgsMachine *machine;

  GtkNotebook *notebook;

  GtkScrolledWindow *output_scrolled_window;
  AgsListingEditor *output_editor;

  GtkScrolledWindow *input_scrolled_window;
  AgsListingEditor *input_editor;

  GtkScrolledWindow *output_link_editor_scrolled_window;
  AgsPropertyCollectionEditor *output_link_editor;

  GtkScrolledWindow *input_link_editor_scrolled_window;
  AgsPropertyCollectionEditor *input_link_editor;

  GtkScrolledWindow *resize_editor_scrolled_window;
  AgsResizeEditor *resize_editor;

  GtkButton *add;
  GtkButton *remove;
  GtkButton *apply;
  GtkButton *ok;
  GtkButton *cancel;
};
</STRUCT>
<STRUCT>
<NAME>AgsMachineEditorClass</NAME>
struct _AgsMachineEditorClass
{
  GtkDialogClass dialog;

  void (*set_machine)(AgsMachineEditor *machine_editor,
		      AgsMachine *machine);
};
</STRUCT>
<FUNCTION>
<NAME>ags_machine_editor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_add_children</NAME>
<RETURNS>void  </RETURNS>
AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_set_machine</NAME>
<RETURNS>void  </RETURNS>
AgsMachineEditor *machine_editor, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_add_input</NAME>
<RETURNS>void  </RETURNS>
AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_add_output</NAME>
<RETURNS>void  </RETURNS>
AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_remove_input</NAME>
<RETURNS>void  </RETURNS>
AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_remove_output</NAME>
<RETURNS>void  </RETURNS>
AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_new</NAME>
<RETURNS>AgsMachineEditor * </RETURNS>
AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_editor_destroy_callback</NAME>
<RETURNS>int  </RETURNS>
GtkObject *object, AgsLineEditor *line_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_editor_show_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsLineEditor *line_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_editor_parent_set_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsLineEditor *line_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_browser_plugin_filename_callback</NAME>
<RETURNS>void  </RETURNS>
GtkComboBoxText *combo_box, AgsLv2Browser *lv2_browser 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_browser_plugin_uri_callback</NAME>
<RETURNS>void  </RETURNS>
GtkComboBoxText *combo_box, AgsLv2Browser *lv2_browser 
</FUNCTION>
<FUNCTION>
<NAME>ags_property_editor_enable_callback</NAME>
<RETURNS>void  </RETURNS>
GtkToggleButton *toggle, AgsPropertyEditor *property_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_editor_delete_event_callback</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *automation_editor, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_editor_set_audio_channels_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, guint audio_channels, guint audio_channels_old, AgsAutomationEditor *automation_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_editor_set_pads_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GType channel_type, guint pads, guint pads_old, AgsAutomationEditor *automation_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_editor_machine_changed_callback</NAME>
<RETURNS>void  </RETURNS>
AgsMachineSelector *machine_selector, AgsMachine *machine, AgsAutomationEditor *automation_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_editor_change_position_callback</NAME>
<RETURNS>void  </RETURNS>
AgsNavigation *navigation, gdouble tact, AgsAutomationEditor *automation_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_editor_edit_vscrollbar_value_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *note_edit, AgsAutomationEditor *automation_editor 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_EFFECT_PAD</NAME>
#define AGS_TYPE_EFFECT_PAD                (ags_effect_pad_get_type())
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_PAD</NAME>
#define AGS_EFFECT_PAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_EFFECT_PAD, AgsEffectPad))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_PAD_CLASS</NAME>
#define AGS_EFFECT_PAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_EFFECT_PAD, AgsEffectPadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_EFFECT_PAD</NAME>
#define AGS_IS_EFFECT_PAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_EFFECT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_EFFECT_PAD_CLASS</NAME>
#define AGS_IS_EFFECT_PAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_EFFECT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_PAD_GET_CLASS</NAME>
#define AGS_EFFECT_PAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_EFFECT_PAD, AgsEffectPadClass))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_PAD_DEFAULT_VERSION</NAME>
#define AGS_EFFECT_PAD_DEFAULT_VERSION "0.4.3\0"
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_PAD_DEFAULT_BUILD_ID</NAME>
#define AGS_EFFECT_PAD_DEFAULT_BUILD_ID "CEST 20-03-2015 08:24\0"
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_PAD_COLUMNS_COUNT</NAME>
#define AGS_EFFECT_PAD_COLUMNS_COUNT (2)
</MACRO>
<ENUM>
<NAME>AgsEffectPadFlags</NAME>
typedef enum{
  AGS_EFFECT_PAD_CONNECTED           = 1,
  AGS_EFFECT_PAD_SHOW_GROUPING       = 1 << 1,
  AGS_EFFECT_PAD_GROUP_ALL           = 1 << 2,
  AGS_EFFECT_PAD_GROUP_LINE          = 1 << 3,
  AGS_EFFECT_PAD_MAPPED_RECALL       = 1 << 4,
  AGS_EFFECT_PAD_PREMAPPED_RECALL    = 1 << 5,
}AgsEffectPadFlags;
</ENUM>
<STRUCT>
<NAME>AgsEffectPad</NAME>
struct _AgsEffectPad
{
  GtkVBox vbox;

  guint flags;

  gchar *name;

  gchar *version;
  gchar *build_id;
  
  AgsChannel *channel;
  
  guint cols;
  GtkTable *table;
};
</STRUCT>
<STRUCT>
<NAME>AgsEffectPadClass</NAME>
struct _AgsEffectPadClass
{
  GtkVBoxClass vbox;

  void (*resize_lines)(AgsEffectPad *effect_pad, GType line_type,
		       guint audio_channels, guint audio_channels_old);
};
</STRUCT>
<FUNCTION>
<NAME>ags_effect_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_pad_resize_lines</NAME>
<RETURNS>void  </RETURNS>
AgsEffectPad *effect_pad, GType line_type, guint audio_channels, guint audio_channels_old 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_pad_new</NAME>
<RETURNS>AgsEffectPad * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LADSPA_BROWSER</NAME>
#define AGS_TYPE_LADSPA_BROWSER                (ags_ladspa_browser_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LADSPA_BROWSER</NAME>
#define AGS_LADSPA_BROWSER(obj)                (G_TYPE_CHECK_INSTANCE_CAST(obj, AGS_TYPE_LADSPA_BROWSER, AgsLadspaBrowser))
</MACRO>
<MACRO>
<NAME>AGS_LADSPA_BROWSER_CLASS</NAME>
#define AGS_LADSPA_BROWSER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_LADSPA_BROWSER, AgsLadspaBrowserClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LADSPA_BROWSER</NAME>
#define AGS_IS_LADSPA_BROWSER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LADSPA_BROWSER))
</MACRO>
<MACRO>
<NAME>AGS_IS_LADSPA_BROWSER_CLASS</NAME>
#define AGS_IS_LADSPA_BROWSER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LADSPA_BROWSER))
</MACRO>
<MACRO>
<NAME>AGS_LADSPA_BROWSER_GET_CLASS</NAME>
#define AGS_LADSPA_BROWSER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_LADSPA_BROWSER, AgsLadspaBrowserClass))
</MACRO>
<STRUCT>
<NAME>AgsLadspaBrowser</NAME>
struct _AgsLadspaBrowser
{
  GtkVBox vbox;

  gchar *path;

  GtkHBox *plugin;
  GtkVBox *description;

  GtkWidget *preview;
};
</STRUCT>
<STRUCT>
<NAME>AgsLadspaBrowserClass</NAME>
struct _AgsLadspaBrowserClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_ladspa_browser_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_browser_get_plugin_filename</NAME>
<RETURNS>gchar * </RETURNS>
AgsLadspaBrowser *ladspa_browser 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_browser_get_plugin_effect</NAME>
<RETURNS>gchar * </RETURNS>
AgsLadspaBrowser *ladspa_browser 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_browser_combo_box_controls_new</NAME>
<RETURNS>GtkWidget * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_browser_preview_new</NAME>
<RETURNS>GtkWidget * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_browser_new</NAME>
<RETURNS>AgsLadspaBrowser * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_EFFECT_BRIDGE</NAME>
#define AGS_TYPE_EFFECT_BRIDGE                (ags_effect_bridge_get_type())
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BRIDGE</NAME>
#define AGS_EFFECT_BRIDGE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_EFFECT_BRIDGE, AgsEffectBridge))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BRIDGE_CLASS</NAME>
#define AGS_EFFECT_BRIDGE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_EFFECT_BRIDGE, AgsEffectBridgeClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_EFFECT_BRIDGE</NAME>
#define AGS_IS_EFFECT_BRIDGE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_EFFECT_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_IS_EFFECT_BRIDGE_CLASS</NAME>
#define AGS_IS_EFFECT_BRIDGE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_EFFECT_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BRIDGE_GET_CLASS</NAME>
#define AGS_EFFECT_BRIDGE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_EFFECT_BRIDGE, AgsEffectBridgeClass))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BRIDGE_DEFAULT_VERSION</NAME>
#define AGS_EFFECT_BRIDGE_DEFAULT_VERSION "0.4.3\0"
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BRIDGE_DEFAULT_BUILD_ID</NAME>
#define AGS_EFFECT_BRIDGE_DEFAULT_BUILD_ID "CEST 15-03-2015 13:40\0"
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BRIDGE_MAX_COLUMNS</NAME>
#define AGS_EFFECT_BRIDGE_MAX_COLUMNS (2)
</MACRO>
<ENUM>
<NAME>AgsEffectBridgeFlags</NAME>
typedef enum{
  AGS_EFFECT_BRIDGE_CONNECTED        = 1,
  AGS_EFFECT_BRIDGE_DISPLAY_INPUT    = 1 <<  1,
  AGS_EFFECT_BRIDGE_BULK_OUTPUT      = 1 <<  2,
  AGS_EFFECT_BRIDGE_DISPLAY_OUTPUT   = 1 <<  3,
  AGS_EFFECT_BRIDGE_BULK_INPUT       = 1 <<  4,
}AgsEffectBridgeFlags;
</ENUM>
<STRUCT>
<NAME>AgsEffectBridge</NAME>
struct _AgsEffectBridge
{
  GtkVBox vbox;

  guint flags;

  gchar *name;

  gchar *version;
  gchar *build_id;
  
  AgsAudio *audio;
  gulong set_audio_channels_handler;
  gulong set_pads_handler;
  
  GType bulk_output_type;
  GtkWidget *bulk_output;
  
  GType output_pad_type;
  GType output_line_type;
  GtkHBox *output;
  
  GType bulk_input_type;
  GtkWidget *bulk_input;

  GType input_pad_type;
  GType input_line_type;
  GtkHBox *input;
};
</STRUCT>
<STRUCT>
<NAME>AgsEffectBridgeClass</NAME>
struct _AgsEffectBridgeClass
{
  GtkVBoxClass vbox;

  void (*resize_audio_channels)(AgsEffectBridge *effect_bridge,
				guint new_size, guint old_size);
  void (*resize_pads)(AgsEffectBridge *effect_bridge,
		      GType channel_type,
		      guint new_size, guint old_size);
};
</STRUCT>
<FUNCTION>
<NAME>ags_effect_bridge_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bridge_resize_audio_channels</NAME>
<RETURNS>void  </RETURNS>
AgsEffectBridge *effect_bridge, guint new_size, guint old_size 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bridge_resize_pads</NAME>
<RETURNS>void  </RETURNS>
AgsEffectBridge *effect_bridge, GType channel_type, guint new_size, guint old_size 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bridge_new</NAME>
<RETURNS>AgsEffectBridge * </RETURNS>
AgsAudio *audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bridge_set_audio_channels_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, guint audio_channels, guint audio_channels_old, AgsEffectBridge *effect_bridge 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bridge_set_pads_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GType channel_type, guint pads, guint pads_old, AgsEffectBridge *effect_bridge 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_parent_set_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_add_effect_callback</NAME>
<RETURNS>GList * </RETURNS>
AgsChannel *channel, gchar *filename, gchar *effect, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_remove_recall_callback</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_group_clicked_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_volume_callback</NAME>
<RETURNS>void  </RETURNS>
GtkRange *range, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_peak_run_post_callback</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *peak_channel, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_copy_pattern_done</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_copy_pattern_cancel</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_recall_volume_done</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_recall_volume_cancel</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_channel_done_callback</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_play_channel_run_cancel</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_play_volume_done</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_play_volume_cancel</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsLine *line 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LINE_MEMBER</NAME>
#define AGS_TYPE_LINE_MEMBER                (ags_line_member_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LINE_MEMBER</NAME>
#define AGS_LINE_MEMBER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LINE_MEMBER, AgsLineMember))
</MACRO>
<MACRO>
<NAME>AGS_LINE_MEMBER_CLASS</NAME>
#define AGS_LINE_MEMBER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LINE_MEMBER, AgsLineMemberClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINE_MEMBER</NAME>
#define AGS_IS_LINE_MEMBER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LINE_MEMBER))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINE_MEMBER_CLASS</NAME>
#define AGS_IS_LINE_MEMBER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LINE_MEMBER))
</MACRO>
<MACRO>
<NAME>AGS_LINE_MEMBER_GET_CLASS</NAME>
#define AGS_LINE_MEMBER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_LINE_MEMBER, AgsLineMemberClass))
</MACRO>
<ENUM>
<NAME>AgsLineMemberFlags</NAME>
typedef enum{
  AGS_LINE_MEMBER_DEFAULT_TEMPLATE      = 1,
  AGS_LINE_MEMBER_RESET_BY_ATOMIC       = 1 << 1,
  AGS_LINE_MEMBER_RESET_BY_TASK         = 1 << 2,
  AGS_LINE_MEMBER_APPLY_RECALL          = 1 << 3,
  AGS_LINE_MEMBER_PLAY_CALLBACK_WRITE   = 1 << 4,
  AGS_LINE_MEMBER_RECALL_CALLBACK_WRITE = 1 << 5,
  AGS_LINE_MEMBER_CALLBACK_READ_BLOCK   = 1 << 6,
  AGS_LINE_MEMBER_CALLBACK_WRITE_BLOCK  = 1 << 7,
}AgsLineMemberFlags;
</ENUM>
<STRUCT>
<NAME>AgsLineMember</NAME>
struct _AgsLineMember
{
  GtkFrame frame;

  guint flags;

  GType widget_type;
  gchar *widget_label;

  gchar *plugin_name;
  gchar *specifier;

  gchar *control_port;
  
  AgsPort *port;
  gpointer port_data;
  gboolean active;

  AgsPort *recall_port;
  gpointer recall_port_data;
  gboolean recall_active;

  GType task_type;
};
</STRUCT>
<STRUCT>
<NAME>AgsLineMemberClass</NAME>
struct _AgsLineMemberClass
{
  GtkFrameClass frame;

  void (*change_port)(AgsLineMember *line_member,
		      gpointer port_data);
};
</STRUCT>
<FUNCTION>
<NAME>ags_line_member_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_get_widget</NAME>
<RETURNS>GtkWidget * </RETURNS>
AgsLineMember *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_set_label</NAME>
<RETURNS>void  </RETURNS>
AgsLineMember *line_member, gchar *label 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_change_port</NAME>
<RETURNS>void  </RETURNS>
AgsLineMember *line_member, gpointer port_data 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_find_port</NAME>
<RETURNS>void  </RETURNS>
AgsLineMember *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_new</NAME>
<RETURNS>AgsLineMember * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PROPERTY_EDITOR</NAME>
#define AGS_TYPE_PROPERTY_EDITOR                (ags_property_editor_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PROPERTY_EDITOR</NAME>
#define AGS_PROPERTY_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PROPERTY_EDITOR, AgsPropertyEditor))
</MACRO>
<MACRO>
<NAME>AGS_PROPERTY_EDITOR_CLASS</NAME>
#define AGS_PROPERTY_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PROPERTY_EDITOR, AgsPropertyEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PROPERTY_EDITOR</NAME>
#define AGS_IS_PROPERTY_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PROPERTY_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_PROPERTY_EDITOR_CLASS</NAME>
#define AGS_IS_PROPERTY_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PROPERTY_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_PROPERTY_EDITOR_GET_CLASS</NAME>
#define AGS_PROPERTY_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PROPERTY_EDITOR, AgsPropertyEditorClass))
</MACRO>
<ENUM>
<NAME>AgsPropertyEditorFlags</NAME>
typedef enum{
  AGS_PROPERTY_EDITOR_ENABLED   =  1,
}AgsPropertyEditorFlags;
</ENUM>
<STRUCT>
<NAME>AgsPropertyEditor</NAME>
struct _AgsPropertyEditor
{
  GtkVBox vbox;

  guint flags;

  GtkCheckButton *enabled;
};
</STRUCT>
<STRUCT>
<NAME>AgsPropertyEditorClass</NAME>
struct _AgsPropertyEditorClass
{
  GtkVBoxClass vbox;

  void (*apply)(AgsPropertyEditor *property_editor);
};
</STRUCT>
<FUNCTION>
<NAME>ags_property_editor_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_property_editor_new</NAME>
<RETURNS>AgsPropertyEditor * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_GENERIC_PREFERENCES</NAME>
#define AGS_TYPE_GENERIC_PREFERENCES                (ags_generic_preferences_get_type())
</MACRO>
<MACRO>
<NAME>AGS_GENERIC_PREFERENCES</NAME>
#define AGS_GENERIC_PREFERENCES(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_GENERIC_PREFERENCES, AgsGenericPreferences))
</MACRO>
<MACRO>
<NAME>AGS_GENERIC_PREFERENCES_CLASS</NAME>
#define AGS_GENERIC_PREFERENCES_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_GENERIC_PREFERENCES, AgsGenericPreferencesClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_GENERIC_PREFERENCES</NAME>
#define AGS_IS_GENERIC_PREFERENCES(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_GENERIC_PREFERENCES))
</MACRO>
<MACRO>
<NAME>AGS_IS_GENERIC_PREFERENCES_CLASS</NAME>
#define AGS_IS_GENERIC_PREFERENCES_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_GENERIC_PREFERENCES))
</MACRO>
<MACRO>
<NAME>AGS_GENERIC_PREFERENCES_GET_CLASS</NAME>
#define AGS_GENERIC_PREFERENCES_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_GENERIC_PREFERENCES, AgsGenericPreferencesClass))
</MACRO>
<STRUCT>
<NAME>AgsGenericPreferences</NAME>
struct _AgsGenericPreferences
{
  GtkVBox vbox;

  GtkCheckButton *autosave_thread;

  GtkComboBox *audio_output_module;
};
</STRUCT>
<STRUCT>
<NAME>AgsGenericPreferencesClass</NAME>
struct _AgsGenericPreferencesClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_generic_preferences_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_generic_preferences_new</NAME>
<RETURNS>AgsGenericPreferences * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_parent_set_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_destroy_callback</NAME>
<RETURNS>int  </RETURNS>
GtkObject *object, AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_show_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_switch_page_callback</NAME>
<RETURNS>int  </RETURNS>
GtkNotebook *notebook, GtkNotebookPage *page, guint page_num, AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_add_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_remove_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_back_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *button, AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_apply_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_ok_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_editor_cancel_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsMachineEditor *machine_editor 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_EFFECT_BULK</NAME>
#define AGS_TYPE_EFFECT_BULK                (ags_effect_bulk_get_type())
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BULK</NAME>
#define AGS_EFFECT_BULK(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_EFFECT_BULK, AgsEffectBulk))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BULK_CLASS</NAME>
#define AGS_EFFECT_BULK_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_EFFECT_BULK, AgsEffectBulkClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_EFFECT_BULK</NAME>
#define AGS_IS_EFFECT_BULK(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_EFFECT_BULK))
</MACRO>
<MACRO>
<NAME>AGS_IS_EFFECT_BULK_CLASS</NAME>
#define AGS_IS_EFFECT_BULK_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_EFFECT_BULK))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BULK_GET_CLASS</NAME>
#define AGS_EFFECT_BULK_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_EFFECT_BULK, AgsEffectBulkClass))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BULK_PLUGIN</NAME>
#define AGS_EFFECT_BULK_PLUGIN(ptr) ((AgsEffectBulkPlugin *)(ptr))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BULK_DEFAULT_VERSION</NAME>
#define AGS_EFFECT_BULK_DEFAULT_VERSION "0.4.3\0"
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BULK_DEFAULT_BUILD_ID</NAME>
#define AGS_EFFECT_BULK_DEFAULT_BUILD_ID "CEST 20-03-2015 08:24\0"
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_BULK_COLUMNS_COUNT</NAME>
#define AGS_EFFECT_BULK_COLUMNS_COUNT (4)
</MACRO>
<ENUM>
<NAME>AgsEffectBulkFlags</NAME>
typedef enum{
  AGS_EFFECT_BULK_CONNECTED        = 1,
  AGS_EFFECT_BULK_HIDE_BUTTONS     = 1 << 1,
  AGS_EFFECT_BULK_HIDE_ENTRIES     = 1 << 2,
  AGS_EFFECT_BULK_SHOW_LABELS      = 1 << 3,
}AgsEffectBulkFlags;
</ENUM>
<STRUCT>
<NAME>AgsEffectBulk</NAME>
struct _AgsEffectBulk
{
  GtkVBox vbox;

  guint flags;

  gchar *name;

  gchar *version;
  gchar *build_id;

  GType *channel_type;
  AgsAudio *audio;
  gulong set_audio_channels_handler;
  gulong set_pads_handler;

  GtkButton *add;
  GtkButton *remove;

  GtkVBox *bulk_member;
  GtkTable *table;

  GList *plugin;
  GtkDialog *plugin_browser;
};
</STRUCT>
<STRUCT>
<NAME>AgsEffectBulkClass</NAME>
struct _AgsEffectBulkClass
{
  GtkVBoxClass vbox;

  GList* (*add_effect)(AgsEffectBulk *effect_bulk,
		       gchar *filename,
		       gchar *effect);
  void (*remove_effect)(AgsEffectBulk *effect_bulk,
			guint nth);

  void (*resize_audio_channels)(AgsEffectBulk *effect_bulk,
				guint new_size,
				guint old_size);
  void (*resize_pads)(AgsEffectBulk *effect_bulk,
		      guint new_size,
		      guint old_size);
};
</STRUCT>
<STRUCT>
<NAME>AgsEffectBulkPlugin</NAME>
struct _AgsEffectBulkPlugin
{
  gchar *filename;
  gchar *effect;
};
</STRUCT>
<FUNCTION>
<NAME>ags_effect_bulk_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bulk_plugin_alloc</NAME>
<RETURNS>AgsEffectBulkPlugin * </RETURNS>
gchar *filename, gchar *effect 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bulk_add_effect</NAME>
<RETURNS>GList * </RETURNS>
AgsEffectBulk *effect_bulk, gchar *filename, gchar *effect 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bulk_remove_effect</NAME>
<RETURNS>void  </RETURNS>
AgsEffectBulk *effect_bulk, guint nth 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bulk_resize_audio_channels</NAME>
<RETURNS>void  </RETURNS>
AgsEffectBulk *effect_bulk, guint new_size, guint old_size 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bulk_resize_pads</NAME>
<RETURNS>void  </RETURNS>
AgsEffectBulk *effect_bulk, guint new_size, guint old_size 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bulk_new</NAME>
<RETURNS>AgsEffectBulk * </RETURNS>
AgsAudio *audio, GType channel_type 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LINK_COLLECTION_EDITOR</NAME>
#define AGS_TYPE_LINK_COLLECTION_EDITOR                (ags_link_collection_editor_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LINK_COLLECTION_EDITOR</NAME>
#define AGS_LINK_COLLECTION_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LINK_COLLECTION_EDITOR, AgsLinkCollectionEditor))
</MACRO>
<MACRO>
<NAME>AGS_LINK_COLLECTION_EDITOR_CLASS</NAME>
#define AGS_LINK_COLLECTION_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LINK_COLLECTION_EDITOR, AgsLinkCollectionEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINK_COLLECTION_EDITOR</NAME>
#define AGS_IS_LINK_COLLECTION_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LINK_COLLECTION_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINK_COLLECTION_EDITOR_CLASS</NAME>
#define AGS_IS_LINK_COLLECTION_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LINK_COLLECTION_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_LINK_COLLECTION_EDITOR_GET_CLASS</NAME>
#define AGS_LINK_COLLECTION_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_LINK_COLLECTION_EDITOR, AgsLinkCollectionEditorClass))
</MACRO>
<STRUCT>
<NAME>AgsLinkCollectionEditor</NAME>
struct _AgsLinkCollectionEditor
{
  GtkTable table;

  GType channel_type;

  GtkComboBox *link;
  GtkSpinButton *first_line;
  GtkSpinButton *first_link;
  GtkSpinButton *count;
};
</STRUCT>
<STRUCT>
<NAME>AgsLinkCollectionEditorClass</NAME>
struct _AgsLinkCollectionEditorClass
{
  GtkTableClass table;
};
</STRUCT>
<FUNCTION>
<NAME>ags_link_collection_editor_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_collection_editor_check_first_line</NAME>
<RETURNS>void  </RETURNS>
AgsLinkCollectionEditor *link_collection_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_collection_editor_check_first_link</NAME>
<RETURNS>void  </RETURNS>
AgsLinkCollectionEditor *link_collection_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_collection_editor_check_count</NAME>
<RETURNS>void  </RETURNS>
AgsLinkCollectionEditor *link_collection_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_collection_editor_new</NAME>
<RETURNS>AgsLinkCollectionEditor * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_editor_parent_set_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsLinkEditor *link_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_editor_destroy_callback</NAME>
<RETURNS>int  </RETURNS>
GtkObject *object, AgsLinkEditor *link_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_editor_show_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsLinkEditor *link_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_editor_combo_callback</NAME>
<RETURNS>void  </RETURNS>
GtkComboBox *combo, AgsLinkEditor *link_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_window_delete_event_callback</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, gpointer data 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLUGIN_BROWSER</NAME>
#define AGS_TYPE_PLUGIN_BROWSER                (ags_plugin_browser_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLUGIN_BROWSER</NAME>
#define AGS_PLUGIN_BROWSER(obj)                (G_TYPE_CHECK_INSTANCE_CAST(obj, AGS_TYPE_PLUGIN_BROWSER, AgsPluginBrowser))
</MACRO>
<MACRO>
<NAME>AGS_PLUGIN_BROWSER_CLASS</NAME>
#define AGS_PLUGIN_BROWSER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_PLUGIN_BROWSER, AgsPluginBrowserClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLUGIN_BROWSER</NAME>
#define AGS_IS_PLUGIN_BROWSER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PLUGIN_BROWSER))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLUGIN_BROWSER_CLASS</NAME>
#define AGS_IS_PLUGIN_BROWSER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PLUGIN_BROWSER))
</MACRO>
<MACRO>
<NAME>AGS_PLUGIN_BROWSER_GET_CLASS</NAME>
#define AGS_PLUGIN_BROWSER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_PLUGIN_BROWSER, AgsPluginBrowserClass))
</MACRO>
<STRUCT>
<NAME>AgsPluginBrowser</NAME>
struct _AgsPluginBrowser
{
  GtkDialog dialog;

  GtkWidget *parent;

  GtkComboBoxText *plugin_type;

  GtkWidget *active_browser;
  
  GtkWidget *lv2_browser;
  GtkWidget *ladspa_browser;
  
  GtkButton *apply;
  GtkButton *ok;
  GtkButton *cancel;
};
</STRUCT>
<STRUCT>
<NAME>AgsPluginBrowserClass</NAME>
struct _AgsPluginBrowserClass
{
  GtkDialogClass dialog;
};
</STRUCT>
<FUNCTION>
<NAME>ags_plugin_browser_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_browser_get_plugin_filename</NAME>
<RETURNS>gchar * </RETURNS>
AgsPluginBrowser *plugin_browser 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_browser_get_plugin_effect</NAME>
<RETURNS>gchar * </RETURNS>
AgsPluginBrowser *plugin_browser 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_browser_new</NAME>
<RETURNS>AgsPluginBrowser * </RETURNS>
GtkWidget *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_preferences_card_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkComboBox *combo, AgsAudioPreferences *audio_preferences 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_preferences_audio_channels_changed</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton *spin_button, AgsAudioPreferences *audio_preferences 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_preferences_samplerate_changed</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton *spin_button, AgsAudioPreferences *audio_preferences 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_preferences_buffer_size_changed</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton *spin_button, AgsAudioPreferences *audio_preferences 
</FUNCTION>
<FUNCTION>
<NAME>ags_preferences_response_callback</NAME>
<RETURNS>void  </RETURNS>
GtkDialog *dialog, gint response_id, gpointer user_data 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_browser_plugin_type_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *combo_box, AgsPluginBrowser *plugin_browser 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_browser_ok_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *button, AgsPluginBrowser *plugin_browser 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_browser_cancel_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *button, AgsPluginBrowser *plugin_browser 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_EFFECT_LINE</NAME>
#define AGS_TYPE_EFFECT_LINE                (ags_effect_line_get_type())
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_LINE</NAME>
#define AGS_EFFECT_LINE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_EFFECT_LINE, AgsEffectLine))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_LINE_CLASS</NAME>
#define AGS_EFFECT_LINE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_EFFECT_LINE, AgsEffectLineClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_EFFECT_LINE</NAME>
#define AGS_IS_EFFECT_LINE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_EFFECT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_IS_EFFECT_LINE_CLASS</NAME>
#define AGS_IS_EFFECT_LINE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_EFFECT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_LINE_GET_CLASS</NAME>
#define AGS_EFFECT_LINE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_EFFECT_LINE, AgsEffectLineClass))
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_LINE_DEFAULT_VERSION</NAME>
#define AGS_EFFECT_LINE_DEFAULT_VERSION "0.4.3\0"
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_LINE_DEFAULT_BUILD_ID</NAME>
#define AGS_EFFECT_LINE_DEFAULT_BUILD_ID "CEST 20-03-2015 08:24\0"
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_LINE_COLUMNS_COUNT</NAME>
#define AGS_EFFECT_LINE_COLUMNS_COUNT (2)
</MACRO>
<ENUM>
<NAME>AgsEffectLineFlags</NAME>
typedef enum{
  AGS_EFFECT_LINE_CONNECTED        = 1,
}AgsEffectLineFlags;
</ENUM>
<STRUCT>
<NAME>AgsEffectLine</NAME>
struct _AgsEffectLine
{
  GtkVBox vbox;

  guint flags;

  gchar *name;

  gchar *version;
  gchar *build_id;
  
  AgsChannel *channel;

  GtkLabel *label;
  
  GtkTable *table;
};
</STRUCT>
<STRUCT>
<NAME>AgsEffectLineClass</NAME>
struct _AgsEffectLineClass
{
  GtkVBoxClass vbox;

  GList* (*add_effect)(AgsEffectLine *effect_line,
		       gchar *filename,
		       gchar *effect);
  void (*remove_effect)(AgsEffectLine *effect_line,
			guint nth);
};
</STRUCT>
<FUNCTION>
<NAME>ags_effect_line_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_line_add_effect</NAME>
<RETURNS>GList * </RETURNS>
AgsEffectLine *effect_line, gchar *filename, gchar *effect 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_line_remove_effect</NAME>
<RETURNS>void  </RETURNS>
AgsEffectLine *effect_line, guint nth 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_line_new</NAME>
<RETURNS>AgsEffectLine * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_parent_set_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_destroy_callback</NAME>
<RETURNS>int  </RETURNS>
GtkObject *object, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_button_press_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *handle_box, GdkEventButton *event, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_popup_move_up_activate_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_popup_move_down_activate_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_popup_hide_activate_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_popup_show_activate_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_popup_destroy_activate_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_popup_rename_activate_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_popup_properties_activate_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_open_response_callback</NAME>
<RETURNS>void  </RETURNS>
GtkDialog *dialog, gint response, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_play_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *toggle_button, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_tact_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_done_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_start_failure_callback</NAME>
<RETURNS>void  </RETURNS>
AgsTask *task, GError *error, AgsMachine *machine 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LINE_MEMBER_EDITOR</NAME>
#define AGS_TYPE_LINE_MEMBER_EDITOR                (ags_line_member_editor_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LINE_MEMBER_EDITOR</NAME>
#define AGS_LINE_MEMBER_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LINE_MEMBER_EDITOR, AgsLineMemberEditor))
</MACRO>
<MACRO>
<NAME>AGS_LINE_MEMBER_EDITOR_CLASS</NAME>
#define AGS_LINE_MEMBER_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LINE_MEMBER_EDITOR, AgsLineMemberEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINE_MEMBER_EDITOR</NAME>
#define AGS_IS_LINE_MEMBER_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LINE_MEMBER_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINE_MEMBER_EDITOR_CLASS</NAME>
#define AGS_IS_LINE_MEMBER_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LINE_MEMBER_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_LINE_MEMBER_EDITOR_GET_CLASS</NAME>
#define AGS_LINE_MEMBER_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_LINE_MEMBER_EDITOR, AgsLineMemberEditorClass))
</MACRO>
<STRUCT>
<NAME>AgsLineMemberEditor</NAME>
struct _AgsLineMemberEditor
{
  GtkVBox vbox;

  GtkVBox *line_member;

  GtkButton *add;
  GtkMenu *popup;

  GtkButton *remove;

  AgsPluginBrowser *plugin_browser;
};
</STRUCT>
<STRUCT>
<NAME>AgsLineMemberEditorClass</NAME>
struct _AgsLineMemberEditorClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_line_member_editor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_line_member_editor_new</NAME>
<RETURNS>AgsLineMemberEditor * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RESIZE_EDITOR</NAME>
#define AGS_TYPE_RESIZE_EDITOR                (ags_resize_editor_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RESIZE_EDITOR</NAME>
#define AGS_RESIZE_EDITOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RESIZE_EDITOR, AgsResizeEditor))
</MACRO>
<MACRO>
<NAME>AGS_RESIZE_EDITOR_CLASS</NAME>
#define AGS_RESIZE_EDITOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RESIZE_EDITOR, AgsResizeEditorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RESIZE_EDITOR</NAME>
#define AGS_IS_RESIZE_EDITOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RESIZE_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_RESIZE_EDITOR_CLASS</NAME>
#define AGS_IS_RESIZE_EDITOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RESIZE_EDITOR))
</MACRO>
<MACRO>
<NAME>AGS_RESIZE_EDITOR_GET_CLASS</NAME>
#define AGS_RESIZE_EDITOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_RESIZE_EDITOR, AgsResizeEditorClass))
</MACRO>
<STRUCT>
<NAME>AgsResizeEditor</NAME>
struct _AgsResizeEditor
{
  AgsPropertyEditor property_editor;

  GtkSpinButton *audio_channels;

  GtkSpinButton *input_pads;
  GtkSpinButton *output_pads;
};
</STRUCT>
<STRUCT>
<NAME>AgsResizeEditorClass</NAME>
struct _AgsResizeEditorClass
{
  AgsPropertyEditorClass property_editor;
};
</STRUCT>
<FUNCTION>
<NAME>ags_resize_editor_new</NAME>
<RETURNS>AgsResizeEditor * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_destroy_callback</NAME>
<RETURNS>gboolean  </RETURNS>
GtkObject *object, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_show_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_open_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_save_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_save_as_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_export_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_import_midi_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_quit_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_add_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_add_panel_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_add_mixer_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_add_drum_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_add_matrix_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_add_synth_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_add_ffplayer_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_add_replicator_bridge_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_add_ladspa_bridge_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_add_lv2_bridge_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_remove_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_automation_editor_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_preferences_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_menu_bar_about_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_line_add_effect_callback</NAME>
<RETURNS>GList * </RETURNS>
AgsChannel *channel, gchar *filename, gchar *effect, AgsEffectLine *effect_line 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bulk_add_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *button, AgsEffectBulk *effect_bulk 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bulk_remove_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *button, AgsEffectBulk *effect_bulk 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bulk_plugin_browser_response_callback</NAME>
<RETURNS>void  </RETURNS>
GtkDialog *dialog, gint response, AgsEffectBulk *effect_bulk 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bulk_set_audio_channels_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, guint audio_channels, guint audio_channels_old, AgsEffectBulk *effect_bulk 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bulk_set_pads_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GType channel_type, guint pads, guint pads_old, AgsEffectBulk *effect_bulk 
</FUNCTION>
<FUNCTION>
<NAME>ags_effect_bulk_lv2ui_write_function</NAME>
<RETURNS>void  </RETURNS>
LV2UI_Controller controller, uint32_t port_index, uint32_t buffer_size, uint32_t port_protocol, const void *buffer 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_editor_parent_set_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsPadEditor *pad_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_editor_destroy_callback</NAME>
<RETURNS>int  </RETURNS>
GtkObject *object, AgsPadEditor *pad_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_pad_editor_show_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, AgsPadEditor *pad_editor 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_ADD_LINE_MEMBER</NAME>
#define AGS_TYPE_ADD_LINE_MEMBER                (ags_add_line_member_get_type())
</MACRO>
<MACRO>
<NAME>AGS_ADD_LINE_MEMBER</NAME>
#define AGS_ADD_LINE_MEMBER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_ADD_LINE_MEMBER, AgsAddLineMember))
</MACRO>
<MACRO>
<NAME>AGS_ADD_LINE_MEMBER_CLASS</NAME>
#define AGS_ADD_LINE_MEMBER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_ADD_LINE_MEMBER, AgsAddLineMemberClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_LINE_MEMBER</NAME>
#define AGS_IS_ADD_LINE_MEMBER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_ADD_LINE_MEMBER))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_LINE_MEMBER_CLASS</NAME>
#define AGS_IS_ADD_LINE_MEMBER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_ADD_LINE_MEMBER))
</MACRO>
<MACRO>
<NAME>AGS_ADD_LINE_MEMBER_GET_CLASS</NAME>
#define AGS_ADD_LINE_MEMBER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_ADD_LINE_MEMBER, AgsAddLineMemberClass))
</MACRO>
<STRUCT>
<NAME>AgsAddLineMember</NAME>
struct _AgsAddLineMember
{
  AgsTask task;

  GtkWidget *line;
  AgsLineMember *line_member;

  guint x;
  guint y;
  guint width;
  guint height;
};
</STRUCT>
<STRUCT>
<NAME>AgsAddLineMemberClass</NAME>
struct _AgsAddLineMemberClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_add_line_member_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_add_line_member_new</NAME>
<RETURNS>AgsAddLineMember * </RETURNS>
GtkWidget *line, AgsLineMember *line_member, guint x, guint y, guint width, guint height 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SCROLL_ON_PLAY</NAME>
#define AGS_TYPE_SCROLL_ON_PLAY                (ags_scroll_on_play_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SCROLL_ON_PLAY</NAME>
#define AGS_SCROLL_ON_PLAY(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SCROLL_ON_PLAY, AgsScrollOnPlay))
</MACRO>
<MACRO>
<NAME>AGS_SCROLL_ON_PLAY_CLASS</NAME>
#define AGS_SCROLL_ON_PLAY_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SCROLL_ON_PLAY, AgsScrollOnPlayClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SCROLL_ON_PLAY</NAME>
#define AGS_IS_SCROLL_ON_PLAY(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SCROLL_ON_PLAY))
</MACRO>
<MACRO>
<NAME>AGS_IS_SCROLL_ON_PLAY_CLASS</NAME>
#define AGS_IS_SCROLL_ON_PLAY_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SCROLL_ON_PLAY))
</MACRO>
<MACRO>
<NAME>AGS_SCROLL_ON_PLAY_GET_CLASS</NAME>
#define AGS_SCROLL_ON_PLAY_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SCROLL_ON_PLAY, AgsScrollOnPlayClass))
</MACRO>
<STRUCT>
<NAME>AgsScrollOnPlay</NAME>
struct _AgsScrollOnPlay
{
  AgsTask task;

  GtkWidget *editor;
};
</STRUCT>
<STRUCT>
<NAME>AgsScrollOnPlayClass</NAME>
struct _AgsScrollOnPlayClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_scroll_on_play_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_scroll_on_play_new</NAME>
<RETURNS>AgsScrollOnPlay * </RETURNS>
GtkWidget *editor 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_DISPLAY_TACT</NAME>
#define AGS_TYPE_DISPLAY_TACT                (ags_display_tact_get_type())
</MACRO>
<MACRO>
<NAME>AGS_DISPLAY_TACT</NAME>
#define AGS_DISPLAY_TACT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_DISPLAY_TACT, AgsDisplayTact))
</MACRO>
<MACRO>
<NAME>AGS_DISPLAY_TACT_CLASS</NAME>
#define AGS_DISPLAY_TACT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_DISPLAY_TACT, AgsDisplayTactClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_DISPLAY_TACT</NAME>
#define AGS_IS_DISPLAY_TACT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_DISPLAY_TACT))
</MACRO>
<MACRO>
<NAME>AGS_IS_DISPLAY_TACT_CLASS</NAME>
#define AGS_IS_DISPLAY_TACT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_DISPLAY_TACT))
</MACRO>
<MACRO>
<NAME>AGS_DISPLAY_TACT_GET_CLASS</NAME>
#define AGS_DISPLAY_TACT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_DISPLAY_TACT, AgsDisplayTactClass))
</MACRO>
<STRUCT>
<NAME>AgsDisplayTact</NAME>
struct _AgsDisplayTact
{
  AgsTask task;

  GtkWidget *navigation;
};
</STRUCT>
<STRUCT>
<NAME>AgsDisplayTactClass</NAME>
struct _AgsDisplayTactClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_display_tact_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_display_tact_new</NAME>
<RETURNS>AgsDisplayTact * </RETURNS>
GtkWidget *navigation 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CHANGE_TACT</NAME>
#define AGS_TYPE_CHANGE_TACT                (ags_change_tact_get_type())
</MACRO>
<MACRO>
<NAME>AGS_CHANGE_TACT</NAME>
#define AGS_CHANGE_TACT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CHANGE_TACT, AgsChangeTact))
</MACRO>
<MACRO>
<NAME>AGS_CHANGE_TACT_CLASS</NAME>
#define AGS_CHANGE_TACT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_CHANGE_TACT, AgsChangeTactClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_CHANGE_TACT</NAME>
#define AGS_IS_CHANGE_TACT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_CHANGE_TACT))
</MACRO>
<MACRO>
<NAME>AGS_IS_CHANGE_TACT_CLASS</NAME>
#define AGS_IS_CHANGE_TACT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_CHANGE_TACT))
</MACRO>
<MACRO>
<NAME>AGS_CHANGE_TACT_GET_CLASS</NAME>
#define AGS_CHANGE_TACT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_CHANGE_TACT, AgsChangeTactClass))
</MACRO>
<STRUCT>
<NAME>AgsChangeTact</NAME>
struct _AgsChangeTact
{
  AgsTask task;

  AgsNavigation *navigation;
};
</STRUCT>
<STRUCT>
<NAME>AgsChangeTactClass</NAME>
struct _AgsChangeTactClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_change_tact_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_change_tact_new</NAME>
<RETURNS>AgsChangeTact * </RETURNS>
AgsNavigation *navigation 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_ADD_BULK_MEMBER</NAME>
#define AGS_TYPE_ADD_BULK_MEMBER                (ags_add_bulk_member_get_type())
</MACRO>
<MACRO>
<NAME>AGS_ADD_BULK_MEMBER</NAME>
#define AGS_ADD_BULK_MEMBER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_ADD_BULK_MEMBER, AgsAddBulkMember))
</MACRO>
<MACRO>
<NAME>AGS_ADD_BULK_MEMBER_CLASS</NAME>
#define AGS_ADD_BULK_MEMBER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_ADD_BULK_MEMBER, AgsAddBulkMemberClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_BULK_MEMBER</NAME>
#define AGS_IS_ADD_BULK_MEMBER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_ADD_BULK_MEMBER))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_BULK_MEMBER_CLASS</NAME>
#define AGS_IS_ADD_BULK_MEMBER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_ADD_BULK_MEMBER))
</MACRO>
<MACRO>
<NAME>AGS_ADD_BULK_MEMBER_GET_CLASS</NAME>
#define AGS_ADD_BULK_MEMBER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_ADD_BULK_MEMBER, AgsAddBulkMemberClass))
</MACRO>
<STRUCT>
<NAME>AgsAddBulkMember</NAME>
struct _AgsAddBulkMember
{
  AgsTask task;

  GtkWidget *effect_bulk;
  AgsLineMember *bulk_member;

  guint x;
  guint y;
  guint width;
  guint height;
};
</STRUCT>
<STRUCT>
<NAME>AgsAddBulkMemberClass</NAME>
struct _AgsAddBulkMemberClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_add_bulk_member_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_add_bulk_member_new</NAME>
<RETURNS>AgsAddBulkMember * </RETURNS>
GtkWidget *effect_bulk, AgsLineMember *bulk_member, guint x, guint y, guint width, guint height 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CHANGE_INDICATOR</NAME>
#define AGS_TYPE_CHANGE_INDICATOR                (ags_change_indicator_get_type())
</MACRO>
<MACRO>
<NAME>AGS_CHANGE_INDICATOR</NAME>
#define AGS_CHANGE_INDICATOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CHANGE_INDICATOR, AgsChangeIndicator))
</MACRO>
<MACRO>
<NAME>AGS_CHANGE_INDICATOR_CLASS</NAME>
#define AGS_CHANGE_INDICATOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_CHANGE_INDICATOR, AgsChangeIndicatorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_CHANGE_INDICATOR</NAME>
#define AGS_IS_CHANGE_INDICATOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_CHANGE_INDICATOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_CHANGE_INDICATOR_CLASS</NAME>
#define AGS_IS_CHANGE_INDICATOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_CHANGE_INDICATOR))
</MACRO>
<MACRO>
<NAME>AGS_CHANGE_INDICATOR_GET_CLASS</NAME>
#define AGS_CHANGE_INDICATOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_CHANGE_INDICATOR, AgsChangeIndicatorClass))
</MACRO>
<STRUCT>
<NAME>AgsChangeIndicator</NAME>
struct _AgsChangeIndicator
{
  AgsTask task;

  AgsIndicator *indicator;
  gdouble value;
};
</STRUCT>
<STRUCT>
<NAME>AgsChangeIndicatorClass</NAME>
struct _AgsChangeIndicatorClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_change_indicator_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_change_indicator_new</NAME>
<RETURNS>AgsChangeIndicator * </RETURNS>
AgsIndicator *indicator, gdouble value 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TOGGLE_LED</NAME>
#define AGS_TYPE_TOGGLE_LED                (ags_toggle_led_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TOGGLE_LED</NAME>
#define AGS_TOGGLE_LED(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TOGGLE_LED, AgsToggleLed))
</MACRO>
<MACRO>
<NAME>AGS_TOGGLE_LED_CLASS</NAME>
#define AGS_TOGGLE_LED_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_TOGGLE_LED, AgsToggleLedClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_TOGGLE_LED</NAME>
#define AGS_IS_TOGGLE_LED(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_TOGGLE_LED))
</MACRO>
<MACRO>
<NAME>AGS_IS_TOGGLE_LED_CLASS</NAME>
#define AGS_IS_TOGGLE_LED_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_TOGGLE_LED))
</MACRO>
<MACRO>
<NAME>AGS_TOGGLE_LED_GET_CLASS</NAME>
#define AGS_TOGGLE_LED_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_TOGGLE_LED, AgsToggleLedClass))
</MACRO>
<STRUCT>
<NAME>AgsToggleLed</NAME>
struct _AgsToggleLed
{
  AgsTask task;

  GList *led;
  guint set_active;
  guint unset_active;
};
</STRUCT>
<STRUCT>
<NAME>AgsToggleLedClass</NAME>
struct _AgsToggleLedClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_toggle_led_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_toggle_led_new</NAME>
<RETURNS>AgsToggleLed * </RETURNS>
GList *led, guint set_active, guint unset_active 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_UPDATE_BULK_MEMBER</NAME>
#define AGS_TYPE_UPDATE_BULK_MEMBER                (ags_update_bulk_member_get_type())
</MACRO>
<MACRO>
<NAME>AGS_UPDATE_BULK_MEMBER</NAME>
#define AGS_UPDATE_BULK_MEMBER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_UPDATE_BULK_MEMBER, AgsUpdateBulkMember))
</MACRO>
<MACRO>
<NAME>AGS_UPDATE_BULK_MEMBER_CLASS</NAME>
#define AGS_UPDATE_BULK_MEMBER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_UPDATE_BULK_MEMBER, AgsUpdateBulkMemberClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_UPDATE_BULK_MEMBER</NAME>
#define AGS_IS_UPDATE_BULK_MEMBER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_UPDATE_BULK_MEMBER))
</MACRO>
<MACRO>
<NAME>AGS_IS_UPDATE_BULK_MEMBER_CLASS</NAME>
#define AGS_IS_UPDATE_BULK_MEMBER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_UPDATE_BULK_MEMBER))
</MACRO>
<MACRO>
<NAME>AGS_UPDATE_BULK_MEMBER_GET_CLASS</NAME>
#define AGS_UPDATE_BULK_MEMBER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_UPDATE_BULK_MEMBER, AgsUpdateBulkMemberClass))
</MACRO>
<STRUCT>
<NAME>AgsUpdateBulkMember</NAME>
struct _AgsUpdateBulkMember
{
  AgsTask task;

  GtkWidget *effect_bulk;
  AgsBulkMember *bulk_member;

  guint new_size;
  guint old_size;

  gboolean pads;
};
</STRUCT>
<STRUCT>
<NAME>AgsUpdateBulkMemberClass</NAME>
struct _AgsUpdateBulkMemberClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_update_bulk_member_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_update_bulk_member_new</NAME>
<RETURNS>AgsUpdateBulkMember * </RETURNS>
GtkWidget *effect_bulk, AgsBulkMember *bulk_member, guint new_size, guint old_size, gboolean pads 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_widget</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GtkWidget *widget 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_widget</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GtkWidget *widget 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_window</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsWindow **window 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_window</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsWindow *window 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_menu_bar</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsMenuBar **menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_menu_bar</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsMenuBar *menu_bar 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_machine_counter</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsMachineCounter **machine_counter 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_machine_counter</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsMachineCounter *machine_counter 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_machine_counter_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **machine_counter 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_machine_counter_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *machine_counter 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_machine</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsMachine **machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_machine</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_machine_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_machine_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_machine_resolve_audio</NAME>
<RETURNS>void  </RETURNS>
AgsFileLookup *file_lookup, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_pad</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsPad **pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_pad</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsPad *pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_pad_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_pad_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_mixer_input_pad</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsPad *mixer_input_pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_mixer_input_pad</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsPad *mixer_input_pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_mixer_output_pad</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsPad *mixer_output_pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_mixer_output_pad</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsPad *mixer_output_pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_line</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsLine **line 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_line</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsLine *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_line_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **line 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_line_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *line 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_line_member</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsLineMember **line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_line_member</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsLineMember *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_line_member_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_line_member_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *line_member 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_dialog</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GtkDialog **dialog 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_dialog</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GtkDialog *dialog 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_dialog_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **dialog 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_dialog_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *dialog 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_machine_editor</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsMachineEditor **machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_machine_editor</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsMachineEditor *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_machine_editor_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_machine_editor_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *machine_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_pad_editor</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsPadEditor **pad_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_pad_editor</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsPadEditor *pad_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_line_editor</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsLineEditor **line_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_line_editor</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsLineEditor *line_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_link_editor</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsLinkEditor **link_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_link_editor</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsLinkEditor *link_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_line_member_editor</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsLineMemberEditor **line_member_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_line_member_editor</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsLineMemberEditor *line_member_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_link_collection_editor</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsLinkCollectionEditor **link_collection_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_link_collection_editor</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsLinkCollectionEditor *link_collection_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_resize_editor</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsResizeEditor **resize_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_resize_editor</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsResizeEditor *resize_editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_editor</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsEditor **editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_editor</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsEditor *editor 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_toolbar</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsToolbar **toolbar 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_toolbar</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsToolbar *toolbar 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_machine_selector</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *parent, AgsMachineSelector **machine_selector 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_machine_selector</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *node, AgsMachineSelector *machine_selector 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_notebook</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsNotebook **notebook 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_notebook</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsNotebook *notebook 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_notebook_tab_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **notebook_tab_list 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_notebook_tab_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *notebook_tab_list 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_notebook_tab</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsNotebookTab **notebook_tab 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_notebook_tab</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsNotebookTab *notebook_tab 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_navigation</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsNavigation **navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_navigation</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsNavigation *navigation 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_selector_popup_add_tab_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMachineSelector *machine_selector 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_selector_popup_remove_tab_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMachineSelector *machine_selector 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_selector_popup_add_index_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMachineSelector *machine_selector 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_selector_popup_remove_index_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMachineSelector *machine_selector 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_selector_popup_link_index_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsMachineSelector *machine_selector 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_selector_radio_changed</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *radio_button, AgsMachineSelector *machine_selector 
</FUNCTION>
<FUNCTION>
<NAME>ags_port_selection_ports_toggled_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *menu_item, AgsPortSelection *selection 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUTOMATION_EDIT</NAME>
#define AGS_TYPE_AUTOMATION_EDIT                (ags_automation_edit_get_type())
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_EDIT</NAME>
#define AGS_AUTOMATION_EDIT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUTOMATION_EDIT, AgsAutomationEdit))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_EDIT_CLASS</NAME>
#define AGS_AUTOMATION_EDIT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_AUTOMATION_EDIT, AgsAutomationEditClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUTOMATION_EDIT</NAME>
#define AGS_IS_AUTOMATION_EDIT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_AUTOMATION_EDIT))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUTOMATION_EDIT_CLASS</NAME>
#define AGS_IS_AUTOMATION_EDIT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_AUTOMATION_EDIT))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_EDIT_GET_CLASS</NAME>
#define AGS_AUTOMATION_EDIT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_AUTOMATION_EDIT, AgsAutomationEditClass))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_EDIT_MAX_CONTROLS</NAME>
#define AGS_AUTOMATION_EDIT_MAX_CONTROLS 1200
</MACRO>
<ENUM>
<NAME>AgsAutomationEditFlags</NAME>
typedef enum{
  AGS_AUTOMATION_EDIT_RESETING_VERTICALLY    = 1,
  AGS_AUTOMATION_EDIT_RESETING_HORIZONTALLY  = 1 <<  1,
  AGS_AUTOMATION_EDIT_POSITION_CURSOR        = 1 <<  2,
  AGS_AUTOMATION_EDIT_ADDING_AUTOMATION         = 1 <<  3,
  AGS_AUTOMATION_EDIT_DELETING_AUTOMATION       = 1 <<  4,
  AGS_AUTOMATION_EDIT_SELECTING_AUTOMATIONS     = 1 <<  5,
}AgsAutomationEditFlags;
</ENUM>
<ENUM>
<NAME>AgsAutomationEditResetFlags</NAME>
typedef enum{
  AGS_AUTOMATION_EDIT_RESET_VSCROLLBAR   = 1,
  AGS_AUTOMATION_EDIT_RESET_HSCROLLBAR   = 1 <<  1,
  AGS_AUTOMATION_EDIT_RESET_WIDTH        = 1 <<  2,
  AGS_AUTOMATION_EDIT_RESET_HEIGHT       = 1 <<  3, // reserved
}AgsAutomationEditResetFlags;
</ENUM>
<STRUCT>
<NAME>AgsAutomationEdit</NAME>
struct _AgsAutomationEdit
{
  GtkTable table;

  guint flags;

  AgsRuler *ruler;

  guint map_width;
  guint map_height;

  GtkScrolledWindow *scrolled_window;
  GtkVBox *drawing_area;
};
</STRUCT>
<STRUCT>
<NAME>AgsAutomationEditClass</NAME>
struct _AgsAutomationEditClass
{
  GtkTableClass table;
};
</STRUCT>
<FUNCTION>
<NAME>ags_automation_edit_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_reset_vertically</NAME>
<RETURNS>void  </RETURNS>
AgsAutomationEdit *automation_edit, guint flags 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_reset_horizontally</NAME>
<RETURNS>void  </RETURNS>
AgsAutomationEdit *automation_edit, guint flags 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_draw_position</NAME>
<RETURNS>void  </RETURNS>
GtkVBox *drawing_area 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_draw_scroll</NAME>
<RETURNS>void  </RETURNS>
GtkVBox *drawing_area, gdouble position 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_add_area</NAME>
<RETURNS>GtkDrawingArea * </RETURNS>
AgsAutomationEdit *automation_edit, AgsAutomation *automation 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_new</NAME>
<RETURNS>AgsAutomationEdit * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MACHINE_RADIO_BUTTON</NAME>
#define AGS_TYPE_MACHINE_RADIO_BUTTON                (ags_machine_radio_button_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_RADIO_BUTTON</NAME>
#define AGS_MACHINE_RADIO_BUTTON(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MACHINE_RADIO_BUTTON, AgsMachineRadioButton))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_RADIO_BUTTON_CLASS</NAME>
#define AGS_MACHINE_RADIO_BUTTON_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MACHINE_RADIO_BUTTON, AgsMachineRadioButtonClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MACHINE_RADIO_BUTTON</NAME>
#define AGS_IS_MACHINE_RADIO_BUTTON(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_MACHINE_RADIO_BUTTON))
</MACRO>
<MACRO>
<NAME>AGS_IS_MACHINE_RADIO_BUTTON_CLASS</NAME>
#define AGS_IS_MACHINE_RADIO_BUTTON_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MACHINE_RADIO_BUTTON))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_RADIO_BUTTON_GET_CLASS</NAME>
#define AGS_MACHINE_RADIO_BUTTON_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_MACHINE_RADIO_BUTTON, AgsMachineRadioButtonClass))
</MACRO>
<STRUCT>
<NAME>AgsMachineRadioButton</NAME>
struct _AgsMachineRadioButton
{
  GtkRadioButton radio_button;

  AgsMachine *machine;
};
</STRUCT>
<STRUCT>
<NAME>AgsMachineRadioButtonClass</NAME>
struct _AgsMachineRadioButtonClass
{
  GtkRadioButtonClass radio_button;
};
</STRUCT>
<FUNCTION>
<NAME>ags_machine_radio_button_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_radio_button_new</NAME>
<RETURNS>AgsMachineRadioButton * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SOUNDSET</NAME>
#define AGS_TYPE_SOUNDSET                (ags_soundset_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SOUNDSET</NAME>
#define AGS_SOUNDSET(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SOUNDSET, AgsSoundset))
</MACRO>
<MACRO>
<NAME>AGS_SOUNDSET_CLASS</NAME>
#define AGS_SOUNDSET_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SOUNDSET, AgsSoundsetClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SOUNDSET</NAME>
#define AGS_IS_SOUNDSET(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_SOUNDSET))
</MACRO>
<MACRO>
<NAME>AGS_IS_SOUNDSET_CLASS</NAME>
#define AGS_IS_SOUNDSET_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_SOUNDSET))
</MACRO>
<MACRO>
<NAME>AGS_SOUNDSET_GET_CLASS</NAME>
#define AGS_SOUNDSET_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_SOUNDSET, AgsSoundsetClass))
</MACRO>
<STRUCT>
<NAME>AgsSoundset</NAME>
struct _AgsSoundset
{
  GtkDrawingArea drawing_area;
};
</STRUCT>
<STRUCT>
<NAME>AgsSoundsetClass</NAME>
struct _AgsSoundsetClass
{
  GtkDrawingAreaClass drawing_area;
};
</STRUCT>
<FUNCTION>
<NAME>ags_soundset_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundset_sound_string</NAME>
<RETURNS>char * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundset_paint</NAME>
<RETURNS>void  </RETURNS>
AgsSoundset *soundset 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundset_new</NAME>
<RETURNS>AgsSoundset * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_sf2_chooser_preset_changed</NAME>
<RETURNS>void  </RETURNS>
GtkComboBox *combo_box, AgsSF2Chooser *sf2_chooser 
</FUNCTION>
<FUNCTION>
<NAME>ags_sf2_chooser_instrument_changed</NAME>
<RETURNS>void  </RETURNS>
GtkComboBox *combo_box, AgsSF2Chooser *sf2_chooser 
</FUNCTION>
<FUNCTION>
<NAME>ags_sf2_chooser_sample_changed</NAME>
<RETURNS>void  </RETURNS>
GtkComboBox *combo_box, AgsSF2Chooser *sf2_chooser 
</FUNCTION>
<FUNCTION>
<NAME>ags_piano_expose_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventExpose *event, AgsPiano *piano 
</FUNCTION>
<FUNCTION>
<NAME>ags_piano_configure_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventConfigure *event, AgsPiano *piano 
</FUNCTION>
<MACRO>
<NAME>AGS_TOOLBAR_MODE_SINGLE_CHANNEL</NAME>
#define AGS_TOOLBAR_MODE_SINGLE_CHANNEL "single channel\0"
</MACRO>
<MACRO>
<NAME>AGS_TOOLBAR_MODE_MULTI_CHANNEL</NAME>
#define AGS_TOOLBAR_MODE_MULTI_CHANNEL "multi channel\0"
</MACRO>
<MACRO>
<NAME>AGS_TOOLBAR_MODE_ALL_CHANNELS</NAME>
#define AGS_TOOLBAR_MODE_ALL_CHANNELS "all channels\0"
</MACRO>
<MACRO>
<NAME>AGS_TYPE_PATTERN_EDIT</NAME>
#define AGS_TYPE_PATTERN_EDIT                (ags_pattern_edit_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PATTERN_EDIT</NAME>
#define AGS_PATTERN_EDIT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PATTERN_EDIT, AgsPatternEdit))
</MACRO>
<MACRO>
<NAME>AGS_PATTERN_EDIT_CLASS</NAME>
#define AGS_PATTERN_EDIT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PATTERN_EDIT, AgsPatternEditClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PATTERN_EDIT</NAME>
#define AGS_IS_PATTERN_EDIT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PATTERN_EDIT))
</MACRO>
<MACRO>
<NAME>AGS_IS_PATTERN_EDIT_CLASS</NAME>
#define AGS_IS_PATTERN_EDIT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PATTERN_EDIT))
</MACRO>
<MACRO>
<NAME>AGS_PATTERN_EDIT_GET_CLASS</NAME>
#define AGS_PATTERN_EDIT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_PATTERN_EDIT, AgsPatternEditClass))
</MACRO>
<MACRO>
<NAME>AGS_PATTERN_EDIT_MAX_CONTROLS</NAME>
#define AGS_PATTERN_EDIT_MAX_CONTROLS 1200
</MACRO>
<ENUM>
<NAME>AgsPatternEditFlags</NAME>
typedef enum{
  AGS_PATTERN_EDIT_RESETING_VERTICALLY    = 1,
  AGS_PATTERN_EDIT_RESETING_HORIZONTALLY  = 1 <<  1,
  AGS_PATTERN_EDIT_POSITION_CURSOR        = 1 <<  2,
  AGS_PATTERN_EDIT_ADDING_NOTE            = 1 <<  3,
  AGS_PATTERN_EDIT_DELETING_NOTE          = 1 <<  4,
  AGS_PATTERN_EDIT_SELECTING_NOTES        = 1 <<  5,
}AgsPatternEditFlags;
</ENUM>
<ENUM>
<NAME>AgsPatternEditResetFlags</NAME>
typedef enum{
  AGS_PATTERN_EDIT_RESET_VSCROLLBAR   = 1,
  AGS_PATTERN_EDIT_RESET_HSCROLLBAR   = 1 <<  1,
  AGS_PATTERN_EDIT_RESET_WIDTH        = 1 <<  2,
  AGS_PATTERN_EDIT_RESET_HEIGHT       = 1 <<  3, // reserved
}AgsPatternEditResetFlags;
</ENUM>
<STRUCT>
<NAME>AgsPatternEdit</NAME>
struct _AgsPatternEdit
{
  GtkTable table;

  guint flags;

  AgsRuler *ruler;
  GtkDrawingArea *drawing_area;

  struct _AgsPatternEditControl{ // values retrieved by mouse pressed and released callback
    AgsNote *note;

    guint x0_offset;
    guint y0_offset;
    guint x0;
    guint y0;

    guint x1_offset;
    guint y1_offset;
    guint x1;
    guint y1;
  }control;

  guint width;
  guint height;
  guint map_width;
  guint map_height;

  guint control_height;
  guint control_margin_y;

  guint control_width;

  guint y0;
  guint y1;

  guint nth_y;
  guint stop_y;

  struct _AgsPatternEditControlCurrent{ // values for drawing refering to current tic and zoom
    guint control_count;

    guint control_width;

    guint x0;
    guint x1;

    guint nth_x;
  }control_current;

  struct _AgsPatternEditControlUnit{ // values for drawing refering to smallest tic and current zoom
    guint control_count;

    guint control_width;

    guint x0;
    guint x1;

    guint nth_x;
    guint stop_x;
  }control_unit;

  guint selected_x;
  guint selected_y;
  
  GtkVScrollbar *vscrollbar;
  GtkHScrollbar *hscrollbar;
};
</STRUCT>
<STRUCT>
<NAME>AgsPatternEditClass</NAME>
struct _AgsPatternEditClass
{
  GtkTableClass table;
};
</STRUCT>
<FUNCTION>
<NAME>ags_pattern_edit_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_set_map_height</NAME>
<RETURNS>void  </RETURNS>
AgsPatternEdit *pattern_edit, guint map_height 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_reset_vertically</NAME>
<RETURNS>void  </RETURNS>
AgsPatternEdit *pattern_edit, guint flags 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_reset_horizontally</NAME>
<RETURNS>void  </RETURNS>
AgsPatternEdit *pattern_edit, guint flags 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_draw_segment</NAME>
<RETURNS>void  </RETURNS>
AgsPatternEdit *pattern_edit, cairo_t *cr 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_draw_position</NAME>
<RETURNS>void  </RETURNS>
AgsPatternEdit *pattern_edit, cairo_t *cr 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_draw_notation</NAME>
<RETURNS>void  </RETURNS>
AgsPatternEdit *pattern_edit, cairo_t *cr 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_draw_scroll</NAME>
<RETURNS>void  </RETURNS>
AgsPatternEdit *pattern_edit, cairo_t *cr, gdouble position 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_new</NAME>
<RETURNS>AgsPatternEdit * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PORT_SELECTION</NAME>
#define AGS_TYPE_PORT_SELECTION                (ags_port_selection_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PORT_SELECTION</NAME>
#define AGS_PORT_SELECTION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PORT_SELECTION, AgsPortSelection))
</MACRO>
<MACRO>
<NAME>AGS_PORT_SELECTION_CLASS</NAME>
#define AGS_PORT_SELECTION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PORT_SELECTION, AgsPortSelectionClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PORT_SELECTION</NAME>
#define AGS_IS_PORT_SELECTION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PORT_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_IS_PORT_SELECTION_CLASS</NAME>
#define AGS_IS_PORT_SELECTION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PORT_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_PORT_SELECTION_GET_CLASS</NAME>
#define AGS_PORT_SELECTION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_PORT_SELECTION, AgsPortSelectionClass))
</MACRO>
<MACRO>
<NAME>AGS_PORT_SELECTION_DATA_CHANNEL</NAME>
#define AGS_PORT_SELECTION_DATA_CHANNEL "ags-channel\0"
</MACRO>
<MACRO>
<NAME>AGS_PORT_SELECTION_DATA_PORT</NAME>
#define AGS_PORT_SELECTION_DATA_PORT "ags-port\0"
</MACRO>
<STRUCT>
<NAME>AgsPortSelection</NAME>
struct _AgsPortSelection
{
  GtkMenuToolButton menu_tool_button;
};
</STRUCT>
<STRUCT>
<NAME>AgsPortSelectionClass</NAME>
struct _AgsPortSelectionClass
{
  GtkMenuToolButtonClass menu_tool_button;

  void (*add_port)(AgsPortSelection *port_selection,
		   AgsPort *port);
};
</STRUCT>
<FUNCTION>
<NAME>ags_port_selection_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_port_selection_load_ports</NAME>
<RETURNS>void  </RETURNS>
AgsPortSelection *selection 
</FUNCTION>
<FUNCTION>
<NAME>ags_port_selection_enable_ports</NAME>
<RETURNS>void  </RETURNS>
AgsPortSelection *selection, GList *ports 
</FUNCTION>
<FUNCTION>
<NAME>ags_port_selection_add_port</NAME>
<RETURNS>void  </RETURNS>
AgsPortSelection *port_selection, AgsPort *port 
</FUNCTION>
<FUNCTION>
<NAME>ags_port_selection_new</NAME>
<RETURNS>AgsPortSelection * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_INLINE_PLAYER</NAME>
#define AGS_TYPE_INLINE_PLAYER                (ags_inline_player_get_type ())
</MACRO>
<MACRO>
<NAME>AGS_INLINE_PLAYER</NAME>
#define AGS_INLINE_PLAYER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_INLINE_PLAYER, AgsInlinePlayer))
</MACRO>
<MACRO>
<NAME>AGS_INLINE_PLAYER_CLASS</NAME>
#define AGS_INLINE_PLAYER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_INLINE_PLAYER, AgsInlinePlayerClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_INLINE_PLAYER</NAME>
#define AGS_IS_INLINE_PLAYER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_INLINE_PLAYER))
</MACRO>
<MACRO>
<NAME>AGS_IS_INLINE_PLAYER_CLASS</NAME>
#define AGS_IS_INLINE_PLAYER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_INLINE_PLAYER))
</MACRO>
<MACRO>
<NAME>AGS_INLINE_PLAYER_GET_CLASS</NAME>
#define AGS_INLINE_PLAYER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_INLINE_PLAYER, AgsInlinePlayerClass))
</MACRO>
<STRUCT>
<NAME>AgsInlinePlayer</NAME>
struct _AgsInlinePlayer
{
  GtkHBox vbox;

  AgsPlayable *playable;

  GtkToggleButton *play;
  GtkHScale *position;
  GtkVolumeButton *volume;
};
</STRUCT>
<STRUCT>
<NAME>AgsInlinePlayerClass</NAME>
struct _AgsInlinePlayerClass
{
  GtkHBoxClass vbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_inline_player_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_inline_player_new</NAME>
<RETURNS>AgsInlinePlayer * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUTOMATION_AREA</NAME>
#define AGS_TYPE_AUTOMATION_AREA                (ags_automation_area_get_type())
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_AREA</NAME>
#define AGS_AUTOMATION_AREA(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUTOMATION_AREA, AgsAutomationArea))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_AREA_CLASS</NAME>
#define AGS_AUTOMATION_AREA_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_AUTOMATION_AREA, AgsAutomationAreaClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUTOMATION_AREA</NAME>
#define AGS_IS_AUTOMATION_AREA(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_AUTOMATION_AREA))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUTOMATION_AREA_CLASS</NAME>
#define AGS_IS_AUTOMATION_AREA_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_AUTOMATION_AREA))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_AREA_GET_CLASS</NAME>
#define AGS_AUTOMATION_AREA_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_AUTOMATION_AREA, AgsAutomationAreaClass))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_AREA_DEFAULT_HEIGHT</NAME>
#define AGS_AUTOMATION_AREA_DEFAULT_HEIGHT (128)
</MACRO>
<STRUCT>
<NAME>AgsAutomationArea</NAME>
struct _AgsAutomationArea
{
  GtkDrawingArea drawing_area;

  AgsAutomation *automation;
};
</STRUCT>
<STRUCT>
<NAME>AgsAutomationAreaClass</NAME>
struct _AgsAutomationAreaClass
{
  GtkDrawingAreaClass drawing_area;
};
</STRUCT>
<FUNCTION>
<NAME>ags_automation_area_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_area_draw_strip</NAME>
<RETURNS>void  </RETURNS>
AgsAutomationArea *automation_area, cairo_t *cr 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_area_draw_scale</NAME>
<RETURNS>void  </RETURNS>
AgsAutomationArea *automation_area, cairo_t *cr 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_area_draw_automation</NAME>
<RETURNS>void  </RETURNS>
AgsAutomationArea *automation_area, cairo_t *cr 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_area_draw_surface</NAME>
<RETURNS>void  </RETURNS>
AgsAutomationArea *automation_area, cairo_t *cr, gdouble x0, gdouble y0, gdouble x1, gdouble y1 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_area_new</NAME>
<RETURNS>AgsAutomationArea * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TOOLBAR</NAME>
#define AGS_TYPE_TOOLBAR                (ags_toolbar_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TOOLBAR</NAME>
#define AGS_TOOLBAR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TOOLBAR, AgsToolbar))
</MACRO>
<MACRO>
<NAME>AGS_TOOLBAR_CLASS</NAME>
#define AGS_TOOLBAR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_TOOLBAR, AgsToolbarClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_TOOLBAR</NAME>
#define AGS_IS_TOOLBAR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_TOOLBAR))
</MACRO>
<MACRO>
<NAME>AGS_IS_TOOLBAR_CLASS</NAME>
#define AGS_IS_TOOLBAR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_TOOLBAR))
</MACRO>
<MACRO>
<NAME>AGS_TOOLBAR_GET_CLASS</NAME>
#define AGS_TOOLBAR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_TOOLBAR, AgsToolbarClass))
</MACRO>
<STRUCT>
<NAME>AgsToolbar</NAME>
struct _AgsToolbar
{
  GtkToolbar toolbar;

  GtkToggleButton *selected_edit_mode;
  GtkToggleButton *position;
  GtkToggleButton *edit;
  GtkToggleButton *clear;
  GtkToggleButton *select;

  GtkButton *copy;
  GtkButton *cut;
  GtkButton *paste;

  guint zoom_history;
  GtkComboBoxText *zoom;

  GtkComboBoxText *mode;
};
</STRUCT>
<STRUCT>
<NAME>AgsToolbarClass</NAME>
struct _AgsToolbarClass
{
  GtkToolbarClass toolbar;
};
</STRUCT>
<FUNCTION>
<NAME>ags_toolbar_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_toolbar_new</NAME>
<RETURNS>AgsToolbar * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_drawing_area_expose_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventExpose *event, AgsNoteEdit *note_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_drawing_area_configure_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventConfigure *event, AgsNoteEdit *note_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_drawing_area_button_press_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventButton *event, AgsNoteEdit *note_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_drawing_area_button_release_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventButton *event, AgsNoteEdit *note_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_drawing_area_motion_notify_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventMotion *event, AgsNoteEdit *note_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_vscrollbar_value_changed</NAME>
<RETURNS>void  </RETURNS>
GtkRange *range, AgsNoteEdit *note_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_hscrollbar_value_changed</NAME>
<RETURNS>void  </RETURNS>
GtkRange *range, AgsNoteEdit *note_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundset_expose_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventExpose *event, AgsSoundset *soundset 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundset_configure_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventConfigure *event, AgsSoundset *soundset 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_FILE_SELECTION</NAME>
#define AGS_TYPE_FILE_SELECTION                (ags_file_selection_get_type())
</MACRO>
<MACRO>
<NAME>AGS_FILE_SELECTION</NAME>
#define AGS_FILE_SELECTION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_FILE_SELECTION, AgsFileSelection))
</MACRO>
<MACRO>
<NAME>AGS_FILE_SELECTION_CLASS</NAME>
#define AGS_FILE_SELECTION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_FILE_SELECTION, AgsFileSelectionClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_FILE_SELECTION</NAME>
#define AGS_IS_FILE_SELECTION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_FILE_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_IS_FILE_SELECTION_CLASS</NAME>
#define AGS_IS_FILE_SELECTION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_FILE_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_FILE_SELECTION_GET_CLASS</NAME>
#define AGS_FILE_SELECTION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_FILE_SELECTION, AgsFileSelectionClass))
</MACRO>
<MACRO>
<NAME>AGS_FILE_SELECTION_ENTRY</NAME>
#define AGS_FILE_SELECTION_ENTRY(strct)        ((AgsFileSelectionEntry *) (strct))
</MACRO>
<ENUM>
<NAME>AgsFileSelectionFlags</NAME>
typedef enum{
  AGS_FILE_SELECTION_COMPLETED   = 1,
}AgsFileSelectionFlags;
</ENUM>
<STRUCT>
<NAME>AgsFileSelection</NAME>
struct _AgsFileSelection
{
  GtkVBox vbox;
  
  guint flags;

  gchar *directory;

  guint entry_count;
  GList *entry;

  GtkLabel *chosed;
  GtkLabel *selected;
};
</STRUCT>
<STRUCT>
<NAME>AgsFileSelectionClass</NAME>
struct _AgsFileSelectionClass
{
  GtkVBoxClass vbox;

  void (*add_entry)(AgsFileSelection *file_selection, GtkWidget *widget);
  void (*remove_entry)(AgsFileSelection *file_selection, GtkWidget *widget);

  void (*completed)(AgsFileSelection *file_selection);
};
</STRUCT>
<STRUCT>
<NAME>AgsFileSelectionEntry</NAME>
struct _AgsFileSelectionEntry
{
  GtkTable *table;

  GtkWidget *entry;

  gboolean chosed;
  gchar *filename;

  GtkSpinButton *nth_sample;
  GtkSpinButton *nth_channel;
  GtkSpinButton *count;
};
</STRUCT>
<FUNCTION>
<NAME>ags_file_selection_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_selection_entry_alloc</NAME>
<RETURNS>AgsFileSelectionEntry * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_selection_set_entry</NAME>
<RETURNS>void  </RETURNS>
AgsFileSelection *file_selection, GList *entry 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_selection_add_entry</NAME>
<RETURNS>void  </RETURNS>
AgsFileSelection *file_selection, GtkWidget *widget 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_selection_remove_entry</NAME>
<RETURNS>void  </RETURNS>
AgsFileSelection *file_selection, GtkWidget *widget 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_selection_contains_file</NAME>
<RETURNS>gboolean  </RETURNS>
AgsFileSelection *file_selection, gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_selection_completed</NAME>
<RETURNS>void  </RETURNS>
AgsFileSelection *file_selection 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_selection_new</NAME>
<RETURNS>AgsFileSelection * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_drawing_area_expose_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventExpose *event, AgsPatternEdit *pattern_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_drawing_area_configure_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventConfigure *event, AgsPatternEdit *pattern_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_drawing_area_button_press_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventButton *event, AgsPatternEdit *pattern_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_drawing_area_button_release_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventButton *event, AgsPatternEdit *pattern_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_drawing_area_motion_notify_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventMotion *event, AgsPatternEdit *pattern_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_vscrollbar_value_changed</NAME>
<RETURNS>void  </RETURNS>
GtkRange *range, AgsPatternEdit *pattern_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_edit_hscrollbar_value_changed</NAME>
<RETURNS>void  </RETURNS>
GtkRange *range, AgsPatternEdit *pattern_edit 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MACHINE_SELECTOR</NAME>
#define AGS_TYPE_MACHINE_SELECTOR                (ags_machine_selector_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_SELECTOR</NAME>
#define AGS_MACHINE_SELECTOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MACHINE_SELECTOR, AgsMachineSelector))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_SELECTOR_CLASS</NAME>
#define AGS_MACHINE_SELECTOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MACHINE_SELECTOR, AgsMachineSelectorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MACHINE_SELECTOR</NAME>
#define AGS_IS_MACHINE_SELECTOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_MACHINE_SELECTOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_MACHINE_SELECTOR_CLASS</NAME>
#define AGS_IS_MACHINE_SELECTOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MACHINE_SELECTOR))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_SELECTOR_GET_CLASS</NAME>
#define AGS_MACHINE_SELECTOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_MACHINE_SELECTOR, AgsMachineSelectorClass))
</MACRO>
<STRUCT>
<NAME>AgsMachineSelector</NAME>
struct _AgsMachineSelector
{
  GtkVBox vbox;

  GtkMenu *popup;
};
</STRUCT>
<STRUCT>
<NAME>AgsMachineSelectorClass</NAME>
struct _AgsMachineSelectorClass
{
  GtkVBoxClass vbox;

  void (*changed)(AgsMachineSelector *machine_selector, AgsMachine *machine);
};
</STRUCT>
<FUNCTION>
<NAME>ags_machine_selector_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_selector_changed</NAME>
<RETURNS>void  </RETURNS>
AgsMachineSelector *machine_selector, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_selector_popup_new</NAME>
<RETURNS>GtkMenu * </RETURNS>
AgsMachineSelector *machine_selector 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_selector_new</NAME>
<RETURNS>AgsMachineSelector * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MACHINE_SELECTION</NAME>
#define AGS_TYPE_MACHINE_SELECTION                (ags_machine_selection_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_SELECTION</NAME>
#define AGS_MACHINE_SELECTION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MACHINE_SELECTION, AgsMachineSelection))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_SELECTION_CLASS</NAME>
#define AGS_MACHINE_SELECTION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MACHINE_SELECTION, AgsMachineSelectionClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MACHINE_SELECTION</NAME>
#define AGS_IS_MACHINE_SELECTION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_MACHINE_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_IS_MACHINE_SELECTION_CLASS</NAME>
#define AGS_IS_MACHINE_SELECTION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MACHINE_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_MACHINE_SELECTION_GET_CLASS</NAME>
#define AGS_MACHINE_SELECTION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_MACHINE_SELECTION, AgsMachineSelectionClass))
</MACRO>
<STRUCT>
<NAME>AgsMachineSelection</NAME>
struct _AgsMachineSelection
{
  GtkDialog dialog;

  AgsWindow *window;
  GList *machine;
};
</STRUCT>
<STRUCT>
<NAME>AgsMachineSelectionClass</NAME>
struct _AgsMachineSelectionClass
{
  GtkDialogClass dialog;
};
</STRUCT>
<FUNCTION>
<NAME>ags_machine_selection_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_selection_load_default</NAME>
<RETURNS>void  </RETURNS>
AgsMachineSelection *machine_selection 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_selection_run</NAME>
<RETURNS>AgsMachine * </RETURNS>
AgsMachineSelection *machine_selection 
</FUNCTION>
<FUNCTION>
<NAME>ags_machine_selection_new</NAME>
<RETURNS>AgsMachineSelection * </RETURNS>
AgsWindow *window 
</FUNCTION>
<FUNCTION>
<NAME>ags_toolbar_destroy_callback</NAME>
<RETURNS>gboolean  </RETURNS>
GtkObject *object, AgsToolbar *toolbar 
</FUNCTION>
<FUNCTION>
<NAME>ags_toolbar_show_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsToolbar *toolbar 
</FUNCTION>
<FUNCTION>
<NAME>ags_toolbar_position_callback</NAME>
<RETURNS>void  </RETURNS>
GtkToggleButton *toggle_button, AgsToolbar *toolbar 
</FUNCTION>
<FUNCTION>
<NAME>ags_toolbar_edit_callback</NAME>
<RETURNS>void  </RETURNS>
GtkToggleButton *toggle_button, AgsToolbar *toolbar 
</FUNCTION>
<FUNCTION>
<NAME>ags_toolbar_clear_callback</NAME>
<RETURNS>void  </RETURNS>
GtkToggleButton *toggle_button, AgsToolbar *toolbar 
</FUNCTION>
<FUNCTION>
<NAME>ags_toolbar_select_callback</NAME>
<RETURNS>void  </RETURNS>
GtkToggleButton *toggle_button, AgsToolbar *toolbar 
</FUNCTION>
<FUNCTION>
<NAME>ags_toolbar_copy_or_cut_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsToolbar *toolbar 
</FUNCTION>
<FUNCTION>
<NAME>ags_toolbar_paste_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsToolbar *toolbar 
</FUNCTION>
<FUNCTION>
<NAME>ags_toolbar_zoom_callback</NAME>
<RETURNS>void  </RETURNS>
GtkComboBox *combo_box, AgsToolbar *toolbar 
</FUNCTION>
<FUNCTION>
<NAME>ags_toolbar_mode_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsToolbar *toolbar 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUTOMATION_TOOLBAR</NAME>
#define AGS_TYPE_AUTOMATION_TOOLBAR                (ags_automation_toolbar_get_type())
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_TOOLBAR</NAME>
#define AGS_AUTOMATION_TOOLBAR(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUTOMATION_TOOLBAR, AgsAutomationToolbar))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_TOOLBAR_CLASS</NAME>
#define AGS_AUTOMATION_TOOLBAR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_AUTOMATION_TOOLBAR, AgsAutomationToolbarClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUTOMATION_TOOLBAR</NAME>
#define AGS_IS_AUTOMATION_TOOLBAR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_AUTOMATION_TOOLBAR))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUTOMATION_TOOLBAR_CLASS</NAME>
#define AGS_IS_AUTOMATION_TOOLBAR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_AUTOMATION_TOOLBAR))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_TOOLBAR_GET_CLASS</NAME>
#define AGS_AUTOMATION_TOOLBAR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_AUTOMATION_TOOLBAR, AgsAutomationToolbarClass))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_TOOLBAR_DATA_CHANNEL</NAME>
#define AGS_AUTOMATION_TOOLBAR_DATA_CHANNEL "ags-channel\0"
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_TOOLBAR_DATA_PORT</NAME>
#define AGS_AUTOMATION_TOOLBAR_DATA_PORT "ags-port\0"
</MACRO>
<STRUCT>
<NAME>AgsAutomationToolbar</NAME>
struct _AgsAutomationToolbar
{
  GtkToolbar toolbar;

  GtkToggleButton *selected_edit_mode;
  GtkToggleButton *position;
  GtkToggleButton *edit;
  GtkToggleButton *clear;
  GtkToggleButton *select;

  GtkMenuItem *copy;
  GtkMenuItem *cut;
  GtkMenuItem *paste;

  GtkComboBox *zoom;

  AgsPortSelection *port_selection;
};
</STRUCT>
<STRUCT>
<NAME>AgsAutomationToolbarClass</NAME>
struct _AgsAutomationToolbarClass
{
  GtkToolbarClass toolbar;
};
</STRUCT>
<FUNCTION>
<NAME>ags_automation_toolbar_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_toolbar_new</NAME>
<RETURNS>AgsAutomationToolbar * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_NOTE_EDIT</NAME>
#define AGS_TYPE_NOTE_EDIT                (ags_note_edit_get_type())
</MACRO>
<MACRO>
<NAME>AGS_NOTE_EDIT</NAME>
#define AGS_NOTE_EDIT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_NOTE_EDIT, AgsNoteEdit))
</MACRO>
<MACRO>
<NAME>AGS_NOTE_EDIT_CLASS</NAME>
#define AGS_NOTE_EDIT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_NOTE_EDIT, AgsNoteEditClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_NOTE_EDIT</NAME>
#define AGS_IS_NOTE_EDIT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_NOTE_EDIT))
</MACRO>
<MACRO>
<NAME>AGS_IS_NOTE_EDIT_CLASS</NAME>
#define AGS_IS_NOTE_EDIT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_NOTE_EDIT))
</MACRO>
<MACRO>
<NAME>AGS_NOTE_EDIT_GET_CLASS</NAME>
#define AGS_NOTE_EDIT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_NOTE_EDIT, AgsNoteEditClass))
</MACRO>
<MACRO>
<NAME>AGS_NOTE_EDIT_MAX_CONTROLS</NAME>
#define AGS_NOTE_EDIT_MAX_CONTROLS (1200) // gives you 1200 * 16
</MACRO>
<ENUM>
<NAME>AgsNoteEditFlags</NAME>
typedef enum{
  AGS_NOTE_EDIT_RESETING_VERTICALLY    = 1,
  AGS_NOTE_EDIT_RESETING_HORIZONTALLY  = 1 <<  1,
  AGS_NOTE_EDIT_POSITION_CURSOR        = 1 <<  2,
  AGS_NOTE_EDIT_ADDING_NOTE            = 1 <<  3,
  AGS_NOTE_EDIT_DELETING_NOTE          = 1 <<  4,
  AGS_NOTE_EDIT_SELECTING_NOTES        = 1 <<  5,
}AgsNoteEditFlags;
</ENUM>
<ENUM>
<NAME>AgsNoteEditResetFlags</NAME>
typedef enum{
  AGS_NOTE_EDIT_RESET_VSCROLLBAR   = 1,
  AGS_NOTE_EDIT_RESET_HSCROLLBAR   = 1 <<  1,
  AGS_NOTE_EDIT_RESET_WIDTH        = 1 <<  2,
  AGS_NOTE_EDIT_RESET_HEIGHT       = 1 <<  3, // reserved
}AgsNoteEditResetFlags;
</ENUM>
<STRUCT>
<NAME>AgsNoteEdit</NAME>
struct _AgsNoteEdit
{
  GtkTable table;

  guint flags;

  AgsRuler *ruler;
  GtkDrawingArea *drawing_area;

  struct _AgsNoteEditControl{ // values retrieved by mouse pressed and released callback
    AgsNote *note;

    guint x0_offset;
    guint y0_offset;
    guint x0;
    guint y0;

    guint x1_offset;
    guint y1_offset;
    guint x1;
    guint y1;
  }control;

  guint width;
  guint height;
  guint map_width;
  guint map_height;

  guint control_height;
  guint control_margin_y;

  guint control_width;

  guint y0;
  guint y1;

  guint nth_y;
  guint stop_y;

  struct _AgsNoteEditControlCurrent{ // values for drawing refering to current tic and zoom
    guint control_count;

    guint control_width;

    guint x0;
    guint x1;

    guint nth_x;
  }control_current;

  struct _AgsNoteEditControlUnit{ // values for drawing refering to smallest tic and current zoom
    guint control_count;

    guint control_width;

    guint x0;
    guint x1;

    guint nth_x;
    guint stop_x;
  }control_unit;

  guint selected_x;
  guint selected_y;
  
  GtkVScrollbar *vscrollbar;
  GtkHScrollbar *hscrollbar;
};
</STRUCT>
<STRUCT>
<NAME>AgsNoteEditClass</NAME>
struct _AgsNoteEditClass
{
  GtkTableClass table;
};
</STRUCT>
<FUNCTION>
<NAME>ags_note_edit_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_set_map_height</NAME>
<RETURNS>void  </RETURNS>
AgsNoteEdit *note_edit, guint map_height 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_reset_vertically</NAME>
<RETURNS>void  </RETURNS>
AgsNoteEdit *note_edit, guint flags 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_reset_horizontally</NAME>
<RETURNS>void  </RETURNS>
AgsNoteEdit *note_edit, guint flags 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_draw_segment</NAME>
<RETURNS>void  </RETURNS>
AgsNoteEdit *note_edit, cairo_t *cr 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_draw_position</NAME>
<RETURNS>void  </RETURNS>
AgsNoteEdit *note_edit, cairo_t *cr 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_draw_notation</NAME>
<RETURNS>void  </RETURNS>
AgsNoteEdit *note_edit, cairo_t *cr 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_draw_scroll</NAME>
<RETURNS>void  </RETURNS>
AgsNoteEdit *note_edit, cairo_t *cr, gdouble position 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_edit_new</NAME>
<RETURNS>AgsNoteEdit * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_scrolled_window_expose_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventExpose *event, AgsAutomationEdit *automation_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_scrolled_window_configure_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventConfigure *event, AgsAutomationEdit *automation_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_scrolled_window_button_press_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventButton *event, AgsAutomationEdit *automation_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_scrolled_window_button_release_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventButton *event, AgsAutomationEdit *automation_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_scrolled_window_motion_notify_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventMotion *event, AgsAutomationEdit *automation_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_vscrollbar_value_changed</NAME>
<RETURNS>void  </RETURNS>
GtkRange *range, AgsAutomationEdit *automation_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_edit_hscrollbar_value_changed</NAME>
<RETURNS>void  </RETURNS>
GtkRange *range, AgsAutomationEdit *automation_edit 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_toolbar_machine_changed_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAutomationEditor *automation_editor, AgsMachine *machine, AgsAutomationToolbar *toolbar 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_NOTEBOOK</NAME>
#define AGS_TYPE_NOTEBOOK                (ags_notebook_get_type())
</MACRO>
<MACRO>
<NAME>AGS_NOTEBOOK</NAME>
#define AGS_NOTEBOOK(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_NOTEBOOK, AgsNotebook))
</MACRO>
<MACRO>
<NAME>AGS_NOTEBOOK_CLASS</NAME>
#define AGS_NOTEBOOK_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_NOTEBOOK, AgsNotebookClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_NOTEBOOK</NAME>
#define AGS_IS_NOTEBOOK(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_NOTEBOOK))
</MACRO>
<MACRO>
<NAME>AGS_IS_NOTEBOOK_CLASS</NAME>
#define AGS_IS_NOTEBOOK_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_NOTEBOOK))
</MACRO>
<MACRO>
<NAME>AGS_NOTEBOOK_GET_CLASS</NAME>
#define AGS_NOTEBOOK_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_NOTEBOOK, AgsNotebookClass))
</MACRO>
<MACRO>
<NAME>AGS_NOTEBOOK_TAB</NAME>
#define AGS_NOTEBOOK_TAB(x) ((AgsNotebookTab *)(x))
</MACRO>
<ENUM>
<NAME>AgsNotebookTabFlags</NAME>
typedef enum{
  AGS_NOTEBOOK_TAB_VISIBLE           = 1,
  AGS_NOTEBOOK_TAB_MODE_NORMAL       = 1 << 1,
  AGS_NOTEBOOK_TAB_MODE_OVERLAY      = 1 << 2,
}AgsNotebookTabFlags;
</ENUM>
<STRUCT>
<NAME>AgsNotebook</NAME>
struct _AgsNotebook
{
  GtkVBox vbox;

  guint flags;

  GtkHBox *hbox;

  GList *tabs;
  GtkWidget *child;
};
</STRUCT>
<STRUCT>
<NAME>AgsNotebookClass</NAME>
struct _AgsNotebookClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<STRUCT>
<NAME>AgsNotebookTab</NAME>
struct _AgsNotebookTab
{
  guint flags;

  GtkToggleButton *toggle;
  GObject *notation;
};
</STRUCT>
<FUNCTION>
<NAME>ags_notebook_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_notebook_tab_index</NAME>
<RETURNS>gint  </RETURNS>
AgsNotebook *notebook, GObject *notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_notebook_next_active_tab</NAME>
<RETURNS>gint  </RETURNS>
AgsNotebook *notebook, gint position 
</FUNCTION>
<FUNCTION>
<NAME>ags_notebook_add_tab</NAME>
<RETURNS>gint  </RETURNS>
AgsNotebook *notebook 
</FUNCTION>
<FUNCTION>
<NAME>ags_notebook_insert_tab</NAME>
<RETURNS>void  </RETURNS>
AgsNotebook *notebook, gint position 
</FUNCTION>
<FUNCTION>
<NAME>ags_notebook_remove_tab</NAME>
<RETURNS>void  </RETURNS>
AgsNotebook *notebook, gint nth 
</FUNCTION>
<FUNCTION>
<NAME>ags_notebook_add_child</NAME>
<RETURNS>void  </RETURNS>
AgsNotebook *notebook, GtkWidget *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_notebook_remove_child</NAME>
<RETURNS>void  </RETURNS>
AgsNotebook *notebook, GtkWidget *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_notebook_new</NAME>
<RETURNS>AgsNotebook * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_selection_remove_callback</NAME>
<RETURNS>void  </RETURNS>
GtkButton *button, GtkTable *hbox 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_area_expose_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventExpose *event, AgsAutomationArea *automation_area 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_area_configure_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventConfigure *event, AgsAutomationArea *automation_area 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_area_button_press_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventButton *event, AgsAutomationArea *automation_area 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_area_button_release_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventButton *event, AgsAutomationArea *automation_area 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_area_motion_notify_event</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventMotion *event, AgsAutomationArea *automation_area 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PIANO</NAME>
#define AGS_TYPE_PIANO                (ags_piano_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PIANO</NAME>
#define AGS_PIANO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PIANO, AgsPiano))
</MACRO>
<MACRO>
<NAME>AGS_PIANO_CLASS</NAME>
#define AGS_PIANO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PIANO, AgsPianoClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PIANO</NAME>
#define AGS_IS_PIANO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PIANO))
</MACRO>
<MACRO>
<NAME>AGS_IS_PIANO_CLASS</NAME>
#define AGS_IS_PIANO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PIANO))
</MACRO>
<MACRO>
<NAME>AGS_PIANO_GET_CLASS</NAME>
#define AGS_PIANO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_PIANO, AgsPianoClass))
</MACRO>
<STRUCT>
<NAME>AgsPiano</NAME>
struct _AgsPiano
{
  GtkDrawingArea drawing_area;
};
</STRUCT>
<STRUCT>
<NAME>AgsPianoClass</NAME>
struct _AgsPianoClass
{
  GtkDrawingAreaClass drawing_area;
};
</STRUCT>
<FUNCTION>
<NAME>ags_piano_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_piano_sound_string</NAME>
<RETURNS>char * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_piano_paint</NAME>
<RETURNS>void  </RETURNS>
AgsPiano *piano 
</FUNCTION>
<FUNCTION>
<NAME>ags_piano_new</NAME>
<RETURNS>AgsPiano * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_notebook_machine_changed_callback</NAME>
<RETURNS>void  </RETURNS>
AgsEditor *editor, AgsMachine *machine, AgsNotebook *notebook 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SF2_CHOOSER</NAME>
#define AGS_TYPE_SF2_CHOOSER                (ags_sf2_chooser_get_type ())
</MACRO>
<MACRO>
<NAME>AGS_SF2_CHOOSER</NAME>
#define AGS_SF2_CHOOSER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SF2_CHOOSER, AgsSF2Chooser))
</MACRO>
<MACRO>
<NAME>AGS_SF2_CHOOSER_CLASS</NAME>
#define AGS_SF2_CHOOSER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SF2_CHOOSER, AgsSF2ChooserClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SF2_CHOOSER</NAME>
#define AGS_IS_SF2_CHOOSER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SF2_CHOOSER))
</MACRO>
<MACRO>
<NAME>AGS_IS_SF2_CHOOSER_CLASS</NAME>
#define AGS_IS_SF2_CHOOSER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SF2_CHOOSER))
</MACRO>
<MACRO>
<NAME>AGS_SF2_CHOOSER_GET_CLASS</NAME>
#define AGS_SF2_CHOOSER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SF2_CHOOSER, AgsSF2ChooserClass))
</MACRO>
<STRUCT>
<NAME>AgsSF2Chooser</NAME>
struct _AgsSF2Chooser
{
  GtkVBox vbox;

  AgsIpatch *ipatch;

  GtkComboBoxText *preset;
  GtkComboBoxText *instrument;
  GtkComboBoxText *sample;
};
</STRUCT>
<STRUCT>
<NAME>AgsSF2ChooserClass</NAME>
struct _AgsSF2ChooserClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_sf2_chooser_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_sf2_chooser_open</NAME>
<RETURNS>void  </RETURNS>
AgsSF2Chooser *sf2_chooser, gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>ags_sf2_chooser_completed</NAME>
<RETURNS>gboolean  </RETURNS>
AgsSF2Chooser *sf2_chooser 
</FUNCTION>
<FUNCTION>
<NAME>ags_sf2_chooser_remove_all_from_combo</NAME>
<RETURNS>void  </RETURNS>
GtkComboBoxText *combo 
</FUNCTION>
<FUNCTION>
<NAME>ags_sf2_chooser_new</NAME>
<RETURNS>AgsSF2Chooser * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_output_pad_play_done</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsRecallID *recall_id, AgsDrumOutputPad *drum_output_pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_output_pad_play_cancel</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsRecallID *recall_id, AgsDrumOutputPad *drum_output_pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_parent_set_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsFFPlayer *ffplayer 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_open_clicked_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsFFPlayer *ffplayer 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_open_dialog_response_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, gint response, AgsMachine *machine 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_preset_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkComboBox *preset, AgsFFPlayer *ffplayer 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_instrument_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkComboBox *instrument, AgsFFPlayer *ffplayer 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_drawing_area_expose_callback</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventExpose *event, AgsFFPlayer *ffplayer 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_drawing_area_configure_callback</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventConfigure *event, AgsFFPlayer *ffplayer 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_drawing_area_button_press_callback</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, AgsFFPlayer *ffplayer 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_hscrollbar_value_changed</NAME>
<RETURNS>void  </RETURNS>
GtkAdjustment *adjustment, AgsFFPlayer *ffplayers 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SYNTH_BRIDGE</NAME>
#define AGS_TYPE_SYNTH_BRIDGE                (ags_synth_bridge_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_BRIDGE</NAME>
#define AGS_SYNTH_BRIDGE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SYNTH_BRIDGE, AgsSynthBridge))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_BRIDGE_CLASS</NAME>
#define AGS_SYNTH_BRIDGE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SYNTH_BRIDGE, AgsSynthBridgeClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_BRIDGE</NAME>
#define AGS_IS_SYNTH_BRIDGE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SYNTH_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_BRIDGE_CLASS</NAME>
#define AGS_IS_SYNTH_BRIDGE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_SYNTH_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_BRIDGE_GET_CLASS</NAME>
#define AGS_SYNTH_BRIDGE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_SYNTH_BRIDGE, AgsSynthBridgeClass))
</MACRO>
<STRUCT>
<NAME>AgsSynthBridge</NAME>
struct _AgsSynthBridge
{
  AgsEffectBridge effect_bridge;
};
</STRUCT>
<STRUCT>
<NAME>AgsSynthBridgeClass</NAME>
struct _AgsSynthBridgeClass
{
  AgsEffectBridgeClass effect_bridge;
};
</STRUCT>
<FUNCTION>
<NAME>ags_synth_bridge_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_bridge_new</NAME>
<RETURNS>AgsSynthBridge * </RETURNS>
AgsAudio *audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_parent_set_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsDrum *drum 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_open_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *toggle_button, AgsDrum *drum 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_loop_button_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *button, AgsDrum *drum 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_length_spin_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *spin_button, AgsDrum *drum 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_index0_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *toggle_button, AgsDrum *drum 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_index1_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *toggle_button, AgsDrum *drum 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_pad_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *toggle_button, AgsDrum *drum 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_offset_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsDrum *drum 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_tact_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id, AgsDrum *drum 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_done_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id, AgsDrum *drum 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MATRIX_BULK_INPUT</NAME>
#define AGS_TYPE_MATRIX_BULK_INPUT                (ags_matrix_bulk_input_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MATRIX_BULK_INPUT</NAME>
#define AGS_MATRIX_BULK_INPUT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MATRIX_BULK_INPUT, AgsMatrixBulkInput))
</MACRO>
<MACRO>
<NAME>AGS_MATRIX_BULK_INPUT_CLASS</NAME>
#define AGS_MATRIX_BULK_INPUT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MATRIX_BULK_INPUT, AgsMatrixBulkInputClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MATRIX_BULK_INPUT</NAME>
#define AGS_IS_MATRIX_BULK_INPUT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_MATRIX_BULK_INPUT))
</MACRO>
<MACRO>
<NAME>AGS_IS_MATRIX_BULK_INPUT_CLASS</NAME>
#define AGS_IS_MATRIX_BULK_INPUT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_MATRIX_BULK_INPUT))
</MACRO>
<MACRO>
<NAME>AGS_MATRIX_BULK_INPUT_GET_CLASS</NAME>
#define AGS_MATRIX_BULK_INPUT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_MATRIX_BULK_INPUT, AgsMatrixBulkInputClass))
</MACRO>
<STRUCT>
<NAME>AgsMatrixBulkInput</NAME>
struct _AgsMatrixBulkInput
{
  AgsEffectBulk effect_bulk;
};
</STRUCT>
<STRUCT>
<NAME>AgsMatrixBulkInputClass</NAME>
struct _AgsMatrixBulkInputClass
{
  AgsEffectBulkClass effect_bulk;
};
</STRUCT>
<FUNCTION>
<NAME>ags_matrix_bulk_input_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_bulk_input_new</NAME>
<RETURNS>AgsMatrixBulkInput * </RETURNS>
AgsAudio *audio, GType channel_type 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PANEL_INPUT_LINE</NAME>
#define AGS_TYPE_PANEL_INPUT_LINE                (ags_panel_input_line_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PANEL_INPUT_LINE</NAME>
#define AGS_PANEL_INPUT_LINE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PANEL_INPUT_LINE, AgsPanelInputLine))
</MACRO>
<MACRO>
<NAME>AGS_PANEL_INPUT_LINE_CLASS</NAME>
#define AGS_PANEL_INPUT_LINE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_PANEL_INPUT_LINE, AgsPanelInputLineClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PANEL_INPUT_LINE</NAME>
#define AGS_IS_PANEL_INPUT_LINE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PANEL_INPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_IS_PANEL_INPUT_LINE_CLASS</NAME>
#define AGS_IS_PANEL_INPUT_LINE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_PANEL_INPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_PANEL_INPUT_LINE_GET_CLASS</NAME>
#define AGS_PANEL_INPUT_LINE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_PANEL_INPUT_LINE, AgsPanelInputLineClass))
</MACRO>
<STRUCT>
<NAME>AgsPanelInputLine</NAME>
struct _AgsPanelInputLine
{
  AgsLine line;

  gchar *name;
  gchar *xml_type;
};
</STRUCT>
<STRUCT>
<NAME>AgsPanelInputLineClass</NAME>
struct _AgsPanelInputLineClass
{
  AgsLineClass line;
};
</STRUCT>
<FUNCTION>
<NAME>ags_panel_input_line_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_panel_input_line_new</NAME>
<RETURNS>AgsPanelInputLine * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_FFPLAYER_BRIDGE</NAME>
#define AGS_TYPE_FFPLAYER_BRIDGE                (ags_ffplayer_bridge_get_type())
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_BRIDGE</NAME>
#define AGS_FFPLAYER_BRIDGE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_FFPLAYER_BRIDGE, AgsFFPlayerBridge))
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_BRIDGE_CLASS</NAME>
#define AGS_FFPLAYER_BRIDGE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_FFPLAYER_BRIDGE, AgsFFPlayerBridgeClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_FFPLAYER_BRIDGE</NAME>
#define AGS_IS_FFPLAYER_BRIDGE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_FFPLAYER_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_IS_FFPLAYER_BRIDGE_CLASS</NAME>
#define AGS_IS_FFPLAYER_BRIDGE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_FFPLAYER_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_BRIDGE_GET_CLASS</NAME>
#define AGS_FFPLAYER_BRIDGE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_FFPLAYER_BRIDGE, AgsFFPlayerBridgeClass))
</MACRO>
<STRUCT>
<NAME>AgsFFPlayerBridge</NAME>
struct _AgsFFPlayerBridge
{
  AgsEffectBridge effect_bridge;
};
</STRUCT>
<STRUCT>
<NAME>AgsFFPlayerBridgeClass</NAME>
struct _AgsFFPlayerBridgeClass
{
  AgsEffectBridgeClass effect_bridge;
};
</STRUCT>
<FUNCTION>
<NAME>ags_ffplayer_bridge_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_bridge_new</NAME>
<RETURNS>AgsFFPlayerBridge * </RETURNS>
AgsAudio *audio 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LADSPA_BRIDGE</NAME>
#define AGS_TYPE_LADSPA_BRIDGE                (ags_ladspa_bridge_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LADSPA_BRIDGE</NAME>
#define AGS_LADSPA_BRIDGE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LADSPA_BRIDGE, AgsLadspaBridge))
</MACRO>
<MACRO>
<NAME>AGS_LADSPA_BRIDGE_CLASS</NAME>
#define AGS_LADSPA_BRIDGE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LADSPA_BRIDGE, AgsLadspaBridgeClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LADSPA_BRIDGE</NAME>
#define AGS_IS_LADSPA_BRIDGE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_LADSPA_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_IS_LADSPA_BRIDGE_CLASS</NAME>
#define AGS_IS_LADSPA_BRIDGE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_LADSPA_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_LADSPA_BRIDGE_GET_CLASS</NAME>
#define AGS_LADSPA_BRIDGE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_LADSPA_BRIDGE, AgsLadspaBridgeClass))
</MACRO>
<MACRO>
<NAME>AGS_LADSPA_BRIDGE_DEFAULT_VERSION</NAME>
#define AGS_LADSPA_BRIDGE_DEFAULT_VERSION "0.4.3\0"
</MACRO>
<MACRO>
<NAME>AGS_LADSPA_BRIDGE_DEFAULT_BUILD_ID</NAME>
#define AGS_LADSPA_BRIDGE_DEFAULT_BUILD_ID "CEST 15-03-2015 13:40\0"
</MACRO>
<ENUM>
<NAME>AgsLadspaBridgeFlags</NAME>
typedef enum{
  AGS_LADSPA_BRIDGE_DISPLAY_INPUT    = 1,
  AGS_LADSPA_BRIDGE_BULK_OUTPUT      = 1 <<  1,
  AGS_LADSPA_BRIDGE_DISPLAY_OUTPUT   = 1 <<  2,
  AGS_LADSPA_BRIDGE_BULK_INPUT       = 1 <<  3,
}AgsLadspaBridgeFlags;
</ENUM>
<STRUCT>
<NAME>AgsLadspaBridge</NAME>
struct _AgsLadspaBridge
{
  AgsMachine machine;

  guint flags;

  gchar *name;

  gchar *version;
  gchar *build_id;

  guint mapped_output;
  guint mapped_input;

  gchar *filename;
  gchar *effect;
  unsigned long effect_index;
};
</STRUCT>
<STRUCT>
<NAME>AgsLadspaBridgeClass</NAME>
struct _AgsLadspaBridgeClass
{
  AgsMachineClass machine;
};
</STRUCT>
<FUNCTION>
<NAME>ags_ladspa_bridge_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_bridge_load</NAME>
<RETURNS>void  </RETURNS>
AgsLadspaBridge *ladspa_bridge 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_bridge_new</NAME>
<RETURNS>AgsLadspaBridge * </RETURNS>
GObject *soundcard, gchar *filename, gchar *effect 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SYNTH_INPUT_LINE</NAME>
#define AGS_TYPE_SYNTH_INPUT_LINE                (ags_synth_input_line_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_INPUT_LINE</NAME>
#define AGS_SYNTH_INPUT_LINE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SYNTH_INPUT_LINE, AgsSynthInputLine))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_INPUT_LINE_CLASS</NAME>
#define AGS_SYNTH_INPUT_LINE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_SYNTH_INPUT_LINE, AgsSynthInputLineClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_INPUT_LINE</NAME>
#define AGS_IS_SYNTH_INPUT_LINE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SYNTH_INPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_INPUT_LINE_CLASS</NAME>
#define AGS_IS_SYNTH_INPUT_LINE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SYNTH_INPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_INPUT_LINE_GET_CLASS</NAME>
#define AGS_SYNTH_INPUT_LINE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_SYNTH_INPUT_LINE, AgsSynthInputLineClass))
</MACRO>
<STRUCT>
<NAME>AgsSynthInputLine</NAME>
struct _AgsSynthInputLine
{
  AgsLine line;

  gchar *name;
  gchar *xml_type;

  AgsOscillator *oscillator;
};
</STRUCT>
<STRUCT>
<NAME>AgsSynthInputLineClass</NAME>
struct _AgsSynthInputLineClass
{
  AgsLineClass line;
};
</STRUCT>
<FUNCTION>
<NAME>ags_synth_input_line_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_input_line_new</NAME>
<RETURNS>AgsSynthInputLine * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_parent_set_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsSynth *synth 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_lower_callback</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton *spin_button, AgsSynth *synth 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_auto_update_callback</NAME>
<RETURNS>void  </RETURNS>
GtkToggleButton *toggle, AgsSynth *synth 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_update_callback</NAME>
<RETURNS>void  </RETURNS>
GtkButton *button, AgsSynth *synth 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MATRIX_BRIDGE</NAME>
#define AGS_TYPE_MATRIX_BRIDGE                (ags_matrix_bridge_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MATRIX_BRIDGE</NAME>
#define AGS_MATRIX_BRIDGE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MATRIX_BRIDGE, AgsMatrixBridge))
</MACRO>
<MACRO>
<NAME>AGS_MATRIX_BRIDGE_CLASS</NAME>
#define AGS_MATRIX_BRIDGE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MATRIX_BRIDGE, AgsMatrixBridgeClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MATRIX_BRIDGE</NAME>
#define AGS_IS_MATRIX_BRIDGE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_MATRIX_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_IS_MATRIX_BRIDGE_CLASS</NAME>
#define AGS_IS_MATRIX_BRIDGE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MATRIX_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_MATRIX_BRIDGE_GET_CLASS</NAME>
#define AGS_MATRIX_BRIDGE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_MATRIX_BRIDGE, AgsMatrixBridgeClass))
</MACRO>
<STRUCT>
<NAME>AgsMatrixBridge</NAME>
struct _AgsMatrixBridge
{
  AgsEffectBridge effect_bridge;
};
</STRUCT>
<STRUCT>
<NAME>AgsMatrixBridgeClass</NAME>
struct _AgsMatrixBridgeClass
{
  AgsEffectBridgeClass effect_bridge;
};
</STRUCT>
<FUNCTION>
<NAME>ags_matrix_bridge_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_bridge_new</NAME>
<RETURNS>AgsMatrixBridge * </RETURNS>
AgsAudio *audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_parent_set_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsMatrix *matrix 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_index_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsMatrix *matrix 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_drawing_area_expose_callback</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventExpose *event, AgsMatrix *matrix 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_drawing_area_button_press_callback</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget *widget, GdkEventButton *event, AgsMatrix *matrix 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_adjustment_value_changed_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, AgsMatrix *matrix 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_bpm_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *spin_button, AgsMatrix *matrix 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_length_spin_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *spin_button, AgsMatrix *matrix 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_loop_button_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *button, AgsMatrix *matrix 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_tact_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id, AgsMatrix *matrix 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_done_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id, AgsMatrix *matrix 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SYNTH_OUTPUT_LINE</NAME>
#define AGS_TYPE_SYNTH_OUTPUT_LINE                (ags_synth_output_line_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_OUTPUT_LINE</NAME>
#define AGS_SYNTH_OUTPUT_LINE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SYNTH_OUTPUT_LINE, AgsSynthOutputLine))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_OUTPUT_LINE_CLASS</NAME>
#define AGS_SYNTH_OUTPUT_LINE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SYNTH_OUTPUT_LINE, AgsSynthOutputLineClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_OUTPUT_LINE</NAME>
#define AGS_IS_SYNTH_OUTPUT_LINE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SYNTH_OUTPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_OUTPUT_LINE_CLASS</NAME>
#define AGS_IS_SYNTH_OUTPUT_LINE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SYNTH_OUTPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_OUTPUT_LINE_GET_CLASS</NAME>
#define AGS_SYNTH_OUTPUT_LINE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SYNTH_OUTPUT_LINE, AgsSynthOutputLineClass))
</MACRO>
<STRUCT>
<NAME>AgsSynthOutputLine</NAME>
struct _AgsSynthOutputLine
{
  AgsEffectLine effect_line;
};
</STRUCT>
<STRUCT>
<NAME>AgsSynthOutputLineClass</NAME>
struct _AgsSynthOutputLineClass
{
  AgsEffectLineClass effect_line;
};
</STRUCT>
<FUNCTION>
<NAME>ags_synth_output_line_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_output_line_new</NAME>
<RETURNS>AgsSynthOutputLine * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_DRUM_OUTPUT_LINE</NAME>
#define AGS_TYPE_DRUM_OUTPUT_LINE                (ags_drum_output_line_get_type())
</MACRO>
<MACRO>
<NAME>AGS_DRUM_OUTPUT_LINE</NAME>
#define AGS_DRUM_OUTPUT_LINE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_DRUM_OUTPUT_LINE, AgsDrumOutputLine))
</MACRO>
<MACRO>
<NAME>AGS_DRUM_OUTPUT_LINE_CLASS</NAME>
#define AGS_DRUM_OUTPUT_LINE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_DRUM_OUTPUT_LINE, AgsDrumOutputLineClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_DRUM_OUTPUT_LINE</NAME>
#define AGS_IS_DRUM_OUTPUT_LINE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_DRUM_OUTPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_IS_DRUM_OUTPUT_LINE_CLASS</NAME>
#define AGS_IS_DRUM_OUTPUT_LINE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_DRUM_OUTPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_DRUM_OUTPUT_LINE_GET_CLASS</NAME>
#define AGS_DRUM_OUTPUT_LINE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_DRUM_OUTPUT_LINE, AgsDrumOutputLineClass))
</MACRO>
<STRUCT>
<NAME>AgsDrumOutputLine</NAME>
struct _AgsDrumOutputLine
{
  AgsLine line;

  gchar *name;
  gchar *xml_type;
};
</STRUCT>
<STRUCT>
<NAME>AgsDrumOutputLineClass</NAME>
struct _AgsDrumOutputLineClass
{
  AgsLineClass line;
};
</STRUCT>
<FUNCTION>
<NAME>ags_drum_output_line_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_output_line_new</NAME>
<RETURNS>AgsDrumOutputLine * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_panel_parent_set_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsPanel *panel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PANEL_INPUT_PAD</NAME>
#define AGS_TYPE_PANEL_INPUT_PAD                (ags_panel_input_pad_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PANEL_INPUT_PAD</NAME>
#define AGS_PANEL_INPUT_PAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PANEL_INPUT_PAD, AgsPanelInputPad))
</MACRO>
<MACRO>
<NAME>AGS_PANEL_INPUT_PAD_CLASS</NAME>
#define AGS_PANEL_INPUT_PAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_PANEL_INPUT_PAD, AgsPanelInputPadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PANEL_INPUT_PAD</NAME>
#define AGS_IS_PANEL_INPUT_PAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PANEL_INPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_PANEL_INPUT_PAD_CLASS</NAME>
#define AGS_IS_PANEL_INPUT_PAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_PANEL_INPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_PANEL_INPUT_PAD_GET_CLASS</NAME>
#define AGS_PANEL_INPUT_PAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_PANEL_INPUT_PAD, AgsPanelInputPadClass))
</MACRO>
<STRUCT>
<NAME>AgsPanelInputPad</NAME>
struct _AgsPanelInputPad
{
  AgsPad pad;

  gchar *name;
  gchar *xml_type;
};
</STRUCT>
<STRUCT>
<NAME>AgsPanelInputPadClass</NAME>
struct _AgsPanelInputPadClass
{
  AgsPadClass pad;
};
</STRUCT>
<FUNCTION>
<NAME>ags_panel_input_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_panel_input_pad_new</NAME>
<RETURNS>AgsPanelInputPad * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_FFPLAYER_INPUT_LINE</NAME>
#define AGS_TYPE_FFPLAYER_INPUT_LINE                (ags_ffplayer_input_line_get_type())
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_INPUT_LINE</NAME>
#define AGS_FFPLAYER_INPUT_LINE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_FFPLAYER_INPUT_LINE, AgsFFPlayerInputLine))
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_INPUT_LINE_CLASS</NAME>
#define AGS_FFPLAYER_INPUT_LINE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_FFPLAYER_INPUT_LINE, AgsFFPlayerInputLineClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_FFPLAYER_INPUT_LINE</NAME>
#define AGS_IS_FFPLAYER_INPUT_LINE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_FFPLAYER_INPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_IS_FFPLAYER_INPUT_LINE_CLASS</NAME>
#define AGS_IS_FFPLAYER_INPUT_LINE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_FFPLAYER_INPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_INPUT_LINE_GET_CLASS</NAME>
#define AGS_FFPLAYER_INPUT_LINE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_FFPLAYER_INPUT_LINE, AgsFFPlayerInputLineClass))
</MACRO>
<STRUCT>
<NAME>AgsFFPlayerInputLine</NAME>
struct _AgsFFPlayerInputLine
{
  AgsEffectLine effect_line;

  GtkLabel *label;
};
</STRUCT>
<STRUCT>
<NAME>AgsFFPlayerInputLineClass</NAME>
struct _AgsFFPlayerInputLineClass
{
  AgsEffectLineClass effect_line;
};
</STRUCT>
<FUNCTION>
<NAME>ags_ffplayer_input_line_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_input_line_new</NAME>
<RETURNS>AgsFFPlayerInputLine * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_FFPLAYER_BULK_INPUT</NAME>
#define AGS_TYPE_FFPLAYER_BULK_INPUT                (ags_ffplayer_bulk_input_get_type())
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_BULK_INPUT</NAME>
#define AGS_FFPLAYER_BULK_INPUT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_FFPLAYER_BULK_INPUT, AgsFFPlayerBulkInput))
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_BULK_INPUT_CLASS</NAME>
#define AGS_FFPLAYER_BULK_INPUT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_FFPLAYER_BULK_INPUT, AgsFFPlayerBulkInputClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_FFPLAYER_BULK_INPUT</NAME>
#define AGS_IS_FFPLAYER_BULK_INPUT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_FFPLAYER_BULK_INPUT))
</MACRO>
<MACRO>
<NAME>AGS_IS_FFPLAYER_BULK_INPUT_CLASS</NAME>
#define AGS_IS_FFPLAYER_BULK_INPUT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_FFPLAYER_BULK_INPUT))
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_BULK_INPUT_GET_CLASS</NAME>
#define AGS_FFPLAYER_BULK_INPUT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_FFPLAYER_BULK_INPUT, AgsFFPlayerBulkInputClass))
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_BULK_INPUT_DEFAULT_VERSION</NAME>
#define AGS_FFPLAYER_BULK_INPUT_DEFAULT_VERSION "0.4.3\0"
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_BULK_INPUT_DEFAULT_BUILD_ID</NAME>
#define AGS_FFPLAYER_BULK_INPUT_DEFAULT_BUILD_ID "CEST 20-03-2015 08:24\0"
</MACRO>
<ENUM>
<NAME>AgsFFPlayerBulkInputFlags</NAME>
typedef enum{
  AGS_FFPLAYER_BULK_INPUT_CONNECTED        = 1,
}AgsFFPlayerBulkInputFlags;
</ENUM>
<STRUCT>
<NAME>AgsFFPlayerBulkInput</NAME>
struct _AgsFFPlayerBulkInput
{
  AgsEffectBulk effect_bulk;
};
</STRUCT>
<STRUCT>
<NAME>AgsFFPlayerBulkInputClass</NAME>
struct _AgsFFPlayerBulkInputClass
{
  AgsEffectBulkClass effect_bulk;
};
</STRUCT>
<FUNCTION>
<NAME>ags_ffplayer_bulk_input_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_bulk_input_new</NAME>
<RETURNS>AgsFFPlayerBulkInput * </RETURNS>
AgsAudio *audio, GType channel_type 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SYNTH_BULK_OUTPUT</NAME>
#define AGS_TYPE_SYNTH_BULK_OUTPUT                (ags_synth_bulk_output_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_BULK_OUTPUT</NAME>
#define AGS_SYNTH_BULK_OUTPUT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SYNTH_BULK_OUTPUT, AgsSynthBulkOutput))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_BULK_OUTPUT_CLASS</NAME>
#define AGS_SYNTH_BULK_OUTPUT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SYNTH_BULK_OUTPUT, AgsSynthBulkOutputClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_BULK_OUTPUT</NAME>
#define AGS_IS_SYNTH_BULK_OUTPUT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SYNTH_BULK_OUTPUT))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_BULK_OUTPUT_CLASS</NAME>
#define AGS_IS_SYNTH_BULK_OUTPUT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SYNTH_BULK_OUTPUT))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_BULK_OUTPUT_GET_CLASS</NAME>
#define AGS_SYNTH_BULK_OUTPUT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SYNTH_BULK_OUTPUT, AgsSynthBulkOutputClass))
</MACRO>
<STRUCT>
<NAME>AgsSynthBulkOutput</NAME>
struct _AgsSynthBulkOutput
{
  AgsEffectBulk effect_bulk;
};
</STRUCT>
<STRUCT>
<NAME>AgsSynthBulkOutputClass</NAME>
struct _AgsSynthBulkOutputClass
{
  AgsEffectBulkClass effect_bulk;
};
</STRUCT>
<FUNCTION>
<NAME>ags_synth_bulk_output_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_bulk_output_new</NAME>
<RETURNS>AgsSynthBulkOutput * </RETURNS>
AgsAudio *audio, GType channel_type 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SYNTH</NAME>
#define AGS_TYPE_SYNTH                (ags_synth_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SYNTH</NAME>
#define AGS_SYNTH(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SYNTH, AgsSynth))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_CLASS</NAME>
#define AGS_SYNTH_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SYNTH, AgsSynthClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH</NAME>
#define AGS_IS_SYNTH(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SYNTH))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_CLASS</NAME>
#define AGS_IS_SYNTH_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SYNTH))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_GET_CLASS</NAME>
#define AGS_SYNTH_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SYNTH, AgsSynthClass))
</MACRO>
<ENUM>
<NAME>AgsSynthFlags</NAME>
typedef enum{
  AGS_SYNTH_AUTO_UPDATE          = 1,
}AgsSynthFlags;
</ENUM>
<STRUCT>
<NAME>AgsSynth</NAME>
struct _AgsSynth
{
  AgsMachine machine;

  guint flags;

  gchar *name;
  gchar *xml_type;

  guint mapped_input_pad;
  guint mapped_output_pad;

  GtkVBox *input_pad;

  GtkSpinButton *lower; // how many channels until to lowest freq
  GtkSpinButton *loop_start;
  GtkSpinButton *loop_end;

  GtkCheckButton *auto_update;
  GtkButton *update;
};
</STRUCT>
<STRUCT>
<NAME>AgsSynthClass</NAME>
struct _AgsSynthClass
{
  AgsMachineClass machine;
};
</STRUCT>
<FUNCTION>
<NAME>ags_synth_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_new</NAME>
<RETURNS>AgsSynth * </RETURNS>
GObject *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_input_line_notify_channel_callback</NAME>
<RETURNS>void  </RETURNS>
GObject *gobject, GParamSpec *pspec, gpointer user_data 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PANEL</NAME>
#define AGS_TYPE_PANEL                (ags_panel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PANEL</NAME>
#define AGS_PANEL(obj)                ((AgsPanel*) G_TYPE_CHECK_INSTANCE_CAST(obj, AGS_TYPE_PANEL, AgsPanel))
</MACRO>
<MACRO>
<NAME>AGS_PANEL_CLASS</NAME>
#define AGS_PANEL_CLASS(class)        ((AgsPanelClass*) G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_PANEL, AgsPanelClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PANEL</NAME>
#define AGS_IS_PANEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE(obj, AGS_TYPE_PANEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_PANEL_CLASS</NAME>
#define AGS_IS_PANEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_PANEL))
</MACRO>
<MACRO>
<NAME>AGS_PANEL_GET_CLASS</NAME>
#define AGS_PANEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PANEL, AgsPanelClass))
</MACRO>
<STRUCT>
<NAME>AgsPanel</NAME>
struct _AgsPanel
{
  AgsMachine machine;

  gchar *name;
  gchar *xml_type;

  GtkVBox *vbox;
};
</STRUCT>
<STRUCT>
<NAME>AgsPanelClass</NAME>
struct _AgsPanelClass
{
  AgsMachineClass machine;
};
</STRUCT>
<FUNCTION>
<NAME>ags_panel_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_panel_new</NAME>
<RETURNS>AgsPanel * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MIXER</NAME>
#define AGS_TYPE_MIXER                (ags_mixer_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MIXER</NAME>
#define AGS_MIXER(obj)                (G_TYPE_CHECK_INSTANCE_CAST(obj, AGS_TYPE_MIXER, AgsMixer))
</MACRO>
<MACRO>
<NAME>AGS_MIXER_CLASS</NAME>
#define AGS_MIXER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_MIXER, AgsMixerClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MIXER</NAME>
#define AGS_IS_MIXER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE(obj, AGS_TYPE_MIXER))
</MACRO>
<MACRO>
<NAME>AGS_IS_MIXER_CLASS</NAME>
#define AGS_IS_MIXER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_MIXER))
</MACRO>
<MACRO>
<NAME>AGS_MIXER_GET_CLASS</NAME>
#define AGS_MIXER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_MIXER, AgsMixerClass))
</MACRO>
<STRUCT>
<NAME>AgsMixer</NAME>
struct _AgsMixer
{
  AgsMachine machine;

  gchar *name;
  gchar *xml_type;

  GtkHBox *input_pad;
};
</STRUCT>
<STRUCT>
<NAME>AgsMixerClass</NAME>
struct _AgsMixerClass
{
  AgsMachineClass machine;
};
</STRUCT>
<FUNCTION>
<NAME>ags_mixer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_mixer_new</NAME>
<RETURNS>AgsMixer * </RETURNS>
GObject *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_input_line_parent_set_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsDrumInputLine *drum_input_line 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_input_line_channel_done_callback</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsDrumInputLine *drum_input_line 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_input_line_audio_set_pads_callback</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GType type, guint pads, guint pads_old, AgsDrumInputLine *drum_input_line 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SYNTH_INPUT_PAD</NAME>
#define AGS_TYPE_SYNTH_INPUT_PAD                (ags_synth_input_pad_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_INPUT_PAD</NAME>
#define AGS_SYNTH_INPUT_PAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SYNTH_INPUT_PAD, AgsSynthInputPad))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_INPUT_PAD_CLASS</NAME>
#define AGS_SYNTH_INPUT_PAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_SYNTH_INPUT_PAD, AgsSynthInputPadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_INPUT_PAD</NAME>
#define AGS_IS_SYNTH_INPUT_PAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SYNTH_INPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_INPUT_PAD_CLASS</NAME>
#define AGS_IS_SYNTH_INPUT_PAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SYNTH_INPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_INPUT_PAD_GET_CLASS</NAME>
#define AGS_SYNTH_INPUT_PAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_SYNTH_INPUT_PAD, AgsSynthInputPadClass))
</MACRO>
<STRUCT>
<NAME>AgsSynthInputPad</NAME>
struct _AgsSynthInputPad
{
  AgsPad pad;

  gchar *name;
  gchar *xml_type;
};
</STRUCT>
<STRUCT>
<NAME>AgsSynthInputPadClass</NAME>
struct _AgsSynthInputPadClass
{
  AgsPadClass pad;
};
</STRUCT>
<FUNCTION>
<NAME>ags_synth_input_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_input_pad_new</NAME>
<RETURNS>AgsSynthInputPad * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MIXER_INPUT_LINE</NAME>
#define AGS_TYPE_MIXER_INPUT_LINE                (ags_mixer_input_line_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MIXER_INPUT_LINE</NAME>
#define AGS_MIXER_INPUT_LINE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MIXER_INPUT_LINE, AgsMixerInputLine))
</MACRO>
<MACRO>
<NAME>AGS_MIXER_INPUT_LINE_CLASS</NAME>
#define AGS_MIXER_INPUT_LINE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_MIXER_INPUT_LINE, AgsMixerInputLineClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MIXER_INPUT_LINE</NAME>
#define AGS_IS_MIXER_INPUT_LINE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_MIXER_INPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_IS_MIXER_INPUT_LINE_CLASS</NAME>
#define AGS_IS_MIXER_INPUT_LINE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_MIXER_INPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_MIXER_INPUT_LINE_GET_CLASS</NAME>
#define AGS_MIXER_INPUT_LINE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_MIXER_INPUT_LINE, AgsMixerInputLineClass))
</MACRO>
<STRUCT>
<NAME>AgsMixerInputLine</NAME>
struct _AgsMixerInputLine
{
  AgsLine line;
};
</STRUCT>
<STRUCT>
<NAME>AgsMixerInputLineClass</NAME>
struct _AgsMixerInputLineClass
{
  AgsLineClass line;
};
</STRUCT>
<FUNCTION>
<NAME>ags_mixer_input_line_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_mixer_input_line_new</NAME>
<RETURNS>AgsMixerInputLine * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LV2_BRIDGE</NAME>
#define AGS_TYPE_LV2_BRIDGE                (ags_lv2_bridge_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LV2_BRIDGE</NAME>
#define AGS_LV2_BRIDGE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LV2_BRIDGE, AgsLv2Bridge))
</MACRO>
<MACRO>
<NAME>AGS_LV2_BRIDGE_CLASS</NAME>
#define AGS_LV2_BRIDGE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LV2_BRIDGE, AgsLv2BridgeClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LV2_BRIDGE</NAME>
#define AGS_IS_LV2_BRIDGE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_LV2_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_IS_LV2_BRIDGE_CLASS</NAME>
#define AGS_IS_LV2_BRIDGE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_LV2_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_LV2_BRIDGE_GET_CLASS</NAME>
#define AGS_LV2_BRIDGE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_LV2_BRIDGE, AgsLv2BridgeClass))
</MACRO>
<MACRO>
<NAME>AGS_LV2_BRIDGE_DEFAULT_VERSION</NAME>
#define AGS_LV2_BRIDGE_DEFAULT_VERSION "0.4.3\0"
</MACRO>
<MACRO>
<NAME>AGS_LV2_BRIDGE_DEFAULT_BUILD_ID</NAME>
#define AGS_LV2_BRIDGE_DEFAULT_BUILD_ID "CEST 13-05-2015 13:40\0"
</MACRO>
<ENUM>
<NAME>AgsLv2BridgeFlags</NAME>
typedef enum{
  AGS_LV2_BRIDGE_DISPLAY_INPUT    = 1,
  AGS_LV2_BRIDGE_BULK_OUTPUT      = 1 <<  1,
  AGS_LV2_BRIDGE_DISPLAY_OUTPUT   = 1 <<  2,
  AGS_LV2_BRIDGE_BULK_INPUT       = 1 <<  3,
}AgsLv2BridgeFlags;
</ENUM>
<STRUCT>
<NAME>AgsLv2Bridge</NAME>
struct _AgsLv2Bridge
{
  AgsMachine machine;

  guint flags;

  gchar *name;

  gchar *version;
  gchar *build_id;

  guint mapped_output;
  guint mapped_input;

  gchar *filename;
  gchar *uri;
  guint uri_index;
};
</STRUCT>
<STRUCT>
<NAME>AgsLv2BridgeClass</NAME>
struct _AgsLv2BridgeClass
{
  AgsMachineClass machine;
};
</STRUCT>
<FUNCTION>
<NAME>ags_lv2_bridge_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_bridge_load</NAME>
<RETURNS>void  </RETURNS>
AgsLv2Bridge *lv2_bridge 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_bridge_new</NAME>
<RETURNS>AgsLv2Bridge * </RETURNS>
GObject *soundcard, gchar *filename, gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>ags_mixer_parent_set_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, AgsMixer *mixer 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MIXER_INPUT_PAD</NAME>
#define AGS_TYPE_MIXER_INPUT_PAD                (ags_mixer_input_pad_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MIXER_INPUT_PAD</NAME>
#define AGS_MIXER_INPUT_PAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MIXER_INPUT_PAD, AgsMixerInputPad))
</MACRO>
<MACRO>
<NAME>AGS_MIXER_INPUT_PAD_CLASS</NAME>
#define AGS_MIXER_INPUT_PAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_MIXER_INPUT_PAD, AgsMixerInputPadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MIXER_INPUT_PAD</NAME>
#define AGS_IS_MIXER_INPUT_PAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_MIXER_INPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_MIXER_INPUT_PAD_CLASS</NAME>
#define AGS_IS_MIXER_INPUT_PAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_MIXER_INPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_MIXER_INPUT_PAD_GET_CLASS</NAME>
#define AGS_MIXER_INPUT_PAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_MIXER_INPUT_PAD, AgsMixerInputPadClass))
</MACRO>
<STRUCT>
<NAME>AgsMixerInputPad</NAME>
struct _AgsMixerInputPad
{
  AgsPad pad;
};
</STRUCT>
<STRUCT>
<NAME>AgsMixerInputPadClass</NAME>
struct _AgsMixerInputPadClass
{
  AgsPadClass pad;
};
</STRUCT>
<FUNCTION>
<NAME>ags_mixer_input_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_mixer_input_pad_new</NAME>
<RETURNS>AgsMixerInputPad * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MATRIX</NAME>
#define AGS_TYPE_MATRIX                (ags_matrix_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MATRIX</NAME>
#define AGS_MATRIX(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MATRIX, AgsMatrix))
</MACRO>
<MACRO>
<NAME>AGS_MATRIX_CLASS</NAME>
#define AGS_MATRIX_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MATRIX, AgsMatrixClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MATRIX</NAME>
#define AGS_IS_MATRIX(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_MATRIX))
</MACRO>
<MACRO>
<NAME>AGS_IS_MATRIX_CLASS</NAME>
#define AGS_IS_MATRIX_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_MATRIX))
</MACRO>
<MACRO>
<NAME>AGS_MATRIX_GET_CLASS</NAME>
#define AGS_MATRIX_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_MATRIX, AgsMatrixClass))
</MACRO>
<MACRO>
<NAME>AGS_MATRIX_PATTERN_CONTROLS</NAME>
#define AGS_MATRIX_PATTERN_CONTROLS (16)
</MACRO>
<MACRO>
<NAME>AGS_MATRIX_OCTAVE</NAME>
#define AGS_MATRIX_OCTAVE 10
</MACRO>
<MACRO>
<NAME>AGS_MATRIX_CELL_WIDTH</NAME>
#define AGS_MATRIX_CELL_WIDTH   12
</MACRO>
<MACRO>
<NAME>AGS_MATRIX_CELL_HEIGHT</NAME>
#define AGS_MATRIX_CELL_HEIGHT  10
</MACRO>
<STRUCT>
<NAME>AgsMatrix</NAME>
struct _AgsMatrix
{
  AgsMachine machine;

  guint flags;

  gchar *name;
  gchar *xml_type;

  guint mapped_output_pad;
  guint mapped_input_pad;

  GtkTable *table;

  GtkToggleButton *run;
  GtkToggleButton *selected;
  GtkToggleButton *index[9];

  GtkDrawingArea *drawing_area;
  guint active_led;
  GtkHBox *led;

  GtkAdjustment *adjustment;

  GtkSpinButton *length_spin;
  GtkCheckButton *loop_button;
};
</STRUCT>
<STRUCT>
<NAME>AgsMatrixClass</NAME>
struct _AgsMatrixClass
{
  AgsMachineClass machine;
};
</STRUCT>
<FUNCTION>
<NAME>ags_matrix_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_input_map_recall</NAME>
<RETURNS>void  </RETURNS>
AgsMatrix *matrix, guint input_pad_start 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_output_map_recall</NAME>
<RETURNS>void  </RETURNS>
AgsMatrix *matrix, guint output_pad_start 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_draw_gutter</NAME>
<RETURNS>void  </RETURNS>
AgsMatrix *matrix 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_draw_matrix</NAME>
<RETURNS>void  </RETURNS>
AgsMatrix *matrix 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_redraw_gutter_point</NAME>
<RETURNS>void  </RETURNS>
AgsMatrix *matrix, AgsChannel *channel, guint j, guint i 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_highlight_gutter_point</NAME>
<RETURNS>void  </RETURNS>
AgsMatrix *matrix, guint j, guint i 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_unpaint_gutter_point</NAME>
<RETURNS>void  </RETURNS>
AgsMatrix *matrix, guint j, guint i 
</FUNCTION>
<FUNCTION>
<NAME>ags_matrix_new</NAME>
<RETURNS>AgsMatrix * </RETURNS>
GObject *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_input_pad_open_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *button, AgsDrumInputPad *drum_input_pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_input_pad_play_callback</NAME>
<RETURNS>void  </RETURNS>
GtkToggleButton *button, AgsDrumInputPad *drum_input_pad 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_input_pad_edit_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *toggle_button, AgsDrumInputPad *drum_input_pad 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_REPLICATOR_BRIDGE</NAME>
#define AGS_TYPE_REPLICATOR_BRIDGE                (ags_replicator_bridge_get_type())
</MACRO>
<MACRO>
<NAME>AGS_REPLICATOR_BRIDGE</NAME>
#define AGS_REPLICATOR_BRIDGE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_REPLICATOR_BRIDGE, AgsReplicatorBridge))
</MACRO>
<MACRO>
<NAME>AGS_REPLICATOR_BRIDGE_CLASS</NAME>
#define AGS_REPLICATOR_BRIDGE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_REPLICATOR_BRIDGE, AgsReplicatorBridgeClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_REPLICATOR_BRIDGE</NAME>
#define AGS_IS_REPLICATOR_BRIDGE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_REPLICATOR_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_IS_REPLICATOR_BRIDGE_CLASS</NAME>
#define AGS_IS_REPLICATOR_BRIDGE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_REPLICATOR_BRIDGE))
</MACRO>
<MACRO>
<NAME>AGS_REPLICATOR_BRIDGE_GET_CLASS</NAME>
#define AGS_REPLICATOR_BRIDGE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_REPLICATOR_BRIDGE, AgsReplicatorBridgeClass))
</MACRO>
<MACRO>
<NAME>AGS_REPLICATOR_BRIDGE_DEFAULT_VERSION</NAME>
#define AGS_REPLICATOR_BRIDGE_DEFAULT_VERSION "0.4.3\0"
</MACRO>
<MACRO>
<NAME>AGS_REPLICATOR_BRIDGE_DEFAULT_BUILD_ID</NAME>
#define AGS_REPLICATOR_BRIDGE_DEFAULT_BUILD_ID "CEST 05-05-2015 17:30\0"
</MACRO>
<ENUM>
<NAME>AgsReplicatorBridgeFlags</NAME>
typedef enum{
  AGS_REPLICATOR_BRIDGE_PARSED_INPUT    = 1,
  AGS_REPLICATOR_BRIDGE_PARSED_MATRIX   = 1 <<  1,
}AgsReplicatorBridgeFlags;
</ENUM>
<STRUCT>
<NAME>AgsReplicatorBridge</NAME>
struct _AgsReplicatorBridge
{
  AgsMachine machine;

  guint flags;

  gchar *name;

  gchar *version;
  gchar *build_id;

  guint mapped_input;
  
  GtkTable *matrix;
  GtkTable *h_label;
  GtkTable *v_label;
};
</STRUCT>
<STRUCT>
<NAME>AgsReplicatorBridgeClass</NAME>
struct _AgsReplicatorBridgeClass
{
  AgsMachineClass machine;
};
</STRUCT>
<FUNCTION>
<NAME>ags_replicator_bridge_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_replicator_bridge_new</NAME>
<RETURNS>AgsReplicatorBridge * </RETURNS>
GObject *soundcard 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_DRUM_OUTPUT_PAD</NAME>
#define AGS_TYPE_DRUM_OUTPUT_PAD                (ags_drum_output_pad_get_type())
</MACRO>
<MACRO>
<NAME>AGS_DRUM_OUTPUT_PAD</NAME>
#define AGS_DRUM_OUTPUT_PAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_DRUM_OUTPUT_PAD, AgsDrumOutputPad))
</MACRO>
<MACRO>
<NAME>AGS_DRUM_OUTPUT_PAD_CLASS</NAME>
#define AGS_DRUM_OUTPUT_PAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_DRUM_OUTPUT_PAD, AgsDrumOutputPadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_DRUM_OUTPUT_PAD</NAME>
#define AGS_IS_DRUM_OUTPUT_PAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_DRUM_OUTPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_DRUM_OUTPUT_PAD_CLASS</NAME>
#define AGS_IS_DRUM_OUTPUT_PAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_DRUM_OUTPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_DRUM_OUTPUT_PAD_GET_CLASS</NAME>
#define AGS_DRUM_OUTPUT_PAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_DRUM_OUTPUT_PAD, AgsDrumOutputPadClass))
</MACRO>
<ENUM>
<NAME>AgsDrumOutputPadFlags</NAME>
typedef enum{
  AGS_DRUM_OUTPUT_PAD_PLAY_DONE  = 1,
}AgsDrumOutputPadFlags;
</ENUM>
<STRUCT>
<NAME>AgsDrumOutputPad</NAME>
struct _AgsDrumOutputPad
{
  AgsPad pad;

  guint flags;

  gchar *name;
  gchar *xml_type;
};
</STRUCT>
<STRUCT>
<NAME>AgsDrumOutputPadClass</NAME>
struct _AgsDrumOutputPadClass
{
  AgsPadClass pad;
};
</STRUCT>
<FUNCTION>
<NAME>ags_drum_output_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_output_pad_new</NAME>
<RETURNS>AgsDrumOutputPad * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_DRUM_INPUT_PAD</NAME>
#define AGS_TYPE_DRUM_INPUT_PAD                (ags_drum_input_pad_get_type())
</MACRO>
<MACRO>
<NAME>AGS_DRUM_INPUT_PAD</NAME>
#define AGS_DRUM_INPUT_PAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_DRUM_INPUT_PAD, AgsDrumInputPad))
</MACRO>
<MACRO>
<NAME>AGS_DRUM_INPUT_PAD_CLASS</NAME>
#define AGS_DRUM_INPUT_PAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_DRUM_INPUT_PAD, AgsDrumInputPadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_DRUM_INPUT_PAD</NAME>
#define AGS_IS_DRUM_INPUT_PAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_DRUM_INPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_DRUM_INPUT_PAD_CLASS</NAME>
#define AGS_IS_DRUM_INPUT_PAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_DRUM_INPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_DRUM_INPUT_PAD_GET_CLASS</NAME>
#define AGS_DRUM_INPUT_PAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_DRUM_INPUT_PAD, AgsDrumInputPadClass))
</MACRO>
<ENUM>
<NAME>AgsDrumInputPadFlags</NAME>
typedef enum{
  AGS_DRUM_INPUT_PAD_OPEN_PLAY_DONE   = 1,
}AgsDrumInputPadFlags;
</ENUM>
<STRUCT>
<NAME>AgsDrumInputPad</NAME>
struct _AgsDrumInputPad
{
  AgsPad pad;

  guint flags;

  gchar *name;
  gchar *xml_type;

  GtkButton *open;
  GtkToggleButton *play;
  GtkToggleButton *edit;

  GList *pad_open_recalls;
  guint pad_open_play_ref;

  GtkFileChooserDialog *file_chooser;

  guint pad_play_ref;
};
</STRUCT>
<STRUCT>
<NAME>AgsDrumInputPadClass</NAME>
struct _AgsDrumInputPadClass
{
  AgsPadClass pad;
};
</STRUCT>
<FUNCTION>
<NAME>ags_drum_input_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_input_pad_new</NAME>
<RETURNS>AgsDrumInputPad * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_DRUM</NAME>
#define AGS_TYPE_DRUM                (ags_drum_get_type())
</MACRO>
<MACRO>
<NAME>AGS_DRUM</NAME>
#define AGS_DRUM(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_DRUM, AgsDrum))
</MACRO>
<MACRO>
<NAME>AGS_DRUM_CLASS</NAME>
#define AGS_DRUM_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_DRUM, AgsDrumClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_DRUM</NAME>
#define AGS_IS_DRUM(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_DRUM))
</MACRO>
<MACRO>
<NAME>AGS_IS_DRUM_CLASS</NAME>
#define AGS_IS_DRUM_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_DRUM))
</MACRO>
<MACRO>
<NAME>AGS_DRUM_GET_CLASS</NAME>
#define AGS_DRUM_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_DRUM, AgsDrumClass))
</MACRO>
<MACRO>
<NAME>AGS_DRUM_PATTERN_CONTROLS</NAME>
#define AGS_DRUM_PATTERN_CONTROLS (16)
</MACRO>
<ENUM>
<NAME>AgsDrumFlags</NAME>
typedef enum{
  AGS_DRUM_BLOCK_PATTERN    =  1,
}AgsDrumFlags;
</ENUM>
<STRUCT>
<NAME>AgsDrum</NAME>
struct _AgsDrum
{
  AgsMachine machine;

  guint flags;

  gchar *name;
  gchar *xml_type;

  GtkButton *open;

  GtkCheckButton *loop_button;
  GtkSpinButton *length_spin;

  GtkToggleButton *run;

  GtkVBox *vbox;

  GtkHBox *input_pad;
  GtkVBox *output_pad;

  GtkToggleButton *selected_edit_button;

  AgsDrumInputPad *selected_pad;
  AgsLine *selected_line;

  GtkToggleButton *index0[4];
  GtkToggleButton *selected0;

  GtkToggleButton *index1[12];
  GtkToggleButton *selected1;

  guint active_led;
  GtkHBox *led;
  GtkHBox *pattern;

  GtkVBox *offset;
};
</STRUCT>
<STRUCT>
<NAME>AgsDrumClass</NAME>
struct _AgsDrumClass
{
  AgsMachineClass machine;
};
</STRUCT>
<FUNCTION>
<NAME>ags_drum_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_set_pattern</NAME>
<RETURNS>void  </RETURNS>
AgsDrum *drum 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_new</NAME>
<RETURNS>AgsDrum * </RETURNS>
GObject *soundcard 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_OSCILLATOR</NAME>
#define AGS_TYPE_OSCILLATOR                (ags_oscillator_get_type())
</MACRO>
<MACRO>
<NAME>AGS_OSCILLATOR</NAME>
#define AGS_OSCILLATOR(obj)                (G_TYPE_CHECK_INSTANCE_CAST(obj, AGS_TYPE_OSCILLATOR, AgsOscillator))
</MACRO>
<MACRO>
<NAME>AGS_OSCILLATOR_CLASS</NAME>
#define AGS_OSCILLATOR_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_OSCILLATOR, AgsOscillatorClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_OSCILLATOR</NAME>
#define AGS_IS_OSCILLATOR(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_OSCILLATOR))
</MACRO>
<MACRO>
<NAME>AGS_IS_OSCILLATOR_CLASS</NAME>
#define AGS_IS_OSCILLATOR_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_OSCILLATOR))
</MACRO>
<MACRO>
<NAME>AGS_OSCILLATOR_GET_CLASS</NAME>
#define AGS_OSCILLATOR_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_OSCILLATOR, AgsOscillatorClass))
</MACRO>
<MACRO>
<NAME>AGS_OSCILLATOR_DEFAULT_STEPS</NAME>
#define AGS_OSCILLATOR_DEFAULT_STEPS (15.0)
</MACRO>
<MACRO>
<NAME>AGS_OSCILLATOR_BASE_FREQUENCY</NAME>
#define AGS_OSCILLATOR_BASE_FREQUENCY (440.0 / (AGS_OSCILLATOR_DEFAULT_STEPS * exp((1.0 / 12.0) * log(2.0))))
</MACRO>
<STRUCT>
<NAME>AgsOscillator</NAME>
struct _AgsOscillator
{
  GtkFrame frame;

  GtkComboBox *wave;
  gulong wave_handler;

  GtkSpinButton *attack;
  gulong attack_handler;

  GtkSpinButton *frame_count;
  gulong frame_count_handler;

  GtkSpinButton *frequency;
  gulong frequency_handler;

  GtkSpinButton *phase;
  gulong phase_handler;

  GtkSpinButton *volume;
  gulong volume_handler;
};
</STRUCT>
<STRUCT>
<NAME>AgsOscillatorClass</NAME>
struct _AgsOscillatorClass
{
  GtkFrameClass frame;
};
</STRUCT>
<FUNCTION>
<NAME>ags_oscillator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_oscillator</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsOscillator **oscillator 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_oscillator</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsOscillator *oscillator 
</FUNCTION>
<FUNCTION>
<NAME>ags_oscillator_new</NAME>
<RETURNS>AgsOscillator * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_output_line_notify_channel_callback</NAME>
<RETURNS>void  </RETURNS>
GObject *gobject, GParamSpec *pspec, gpointer user_data 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_DRUM_INPUT_LINE</NAME>
#define AGS_TYPE_DRUM_INPUT_LINE                (ags_drum_input_line_get_type())
</MACRO>
<MACRO>
<NAME>AGS_DRUM_INPUT_LINE</NAME>
#define AGS_DRUM_INPUT_LINE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_DRUM_INPUT_LINE, AgsDrumInputLine))
</MACRO>
<MACRO>
<NAME>AGS_DRUM_INPUT_LINE_CLASS</NAME>
#define AGS_DRUM_INPUT_LINE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_DRUM_INPUT_LINE, AgsDrumInputLineClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_DRUM_INPUT_LINE</NAME>
#define AGS_IS_DRUM_INPUT_LINE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_DRUM_INPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_IS_DRUM_INPUT_LINE_CLASS</NAME>
#define AGS_IS_DRUM_INPUT_LINE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_DRUM_INPUT_LINE))
</MACRO>
<MACRO>
<NAME>AGS_DRUM_INPUT_LINE_GET_CLASS</NAME>
#define AGS_DRUM_INPUT_LINE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_DRUM_INPUT_LINE, AgsDrumInputLineClass))
</MACRO>
<STRUCT>
<NAME>AgsDrumInputLine</NAME>
struct _AgsDrumInputLine
{
  AgsLine line;

  gchar *name;
  gchar *xml_type;
};
</STRUCT>
<STRUCT>
<NAME>AgsDrumInputLineClass</NAME>
struct _AgsDrumInputLineClass
{
  AgsLineClass line;
};
</STRUCT>
<FUNCTION>
<NAME>ags_drum_input_line_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_input_line_new</NAME>
<RETURNS>AgsDrumInputLine * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_FFPLAYER</NAME>
#define AGS_TYPE_FFPLAYER                (ags_ffplayer_get_type())
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER</NAME>
#define AGS_FFPLAYER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_FFPLAYER, AgsFFPlayer))
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_CLASS</NAME>
#define AGS_FFPLAYER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_FFPLAYER, AgsFFPlayerClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_FFPLAYER</NAME>
#define AGS_IS_FFPLAYER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_FFPLAYER))
</MACRO>
<MACRO>
<NAME>AGS_IS_FFPLAYER_CLASS</NAME>
#define AGS_IS_FFPLAYER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_FFPLAYER))
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_GET_CLASS</NAME>
#define AGS_FFPLAYER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_FFPLAYER, AgsFFPlayerClass))
</MACRO>
<STRUCT>
<NAME>AgsFFPlayer</NAME>
struct _AgsFFPlayer
{
  AgsMachine machine;

  guint mapped_output_pad;
  guint mapped_input_pad;

  gchar *name;
  gchar *xml_type;

  GtkButton *open;

  guint control_width;
  guint control_height;
  
  GtkDrawingArea *drawing_area;
  GtkAdjustment *hadjustment;

  AgsIpatch *ipatch;
  GtkComboBoxText *preset;
  GtkComboBoxText *instrument;
};
</STRUCT>
<STRUCT>
<NAME>AgsFFPlayerClass</NAME>
struct _AgsFFPlayerClass
{
  AgsMachineClass machine;
};
</STRUCT>
<FUNCTION>
<NAME>ags_ffplayer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_paint</NAME>
<RETURNS>void  </RETURNS>
AgsFFPlayer *ffplayer 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_new</NAME>
<RETURNS>AgsFFPlayer * </RETURNS>
GObject *soundcard 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SYNTH_OUTPUT_PAD</NAME>
#define AGS_TYPE_SYNTH_OUTPUT_PAD                (ags_synth_output_pad_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_OUTPUT_PAD</NAME>
#define AGS_SYNTH_OUTPUT_PAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SYNTH_OUTPUT_PAD, AgsSynthOutputPad))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_OUTPUT_PAD_CLASS</NAME>
#define AGS_SYNTH_OUTPUT_PAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SYNTH_OUTPUT_PAD, AgsSynthOutputPadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_OUTPUT_PAD</NAME>
#define AGS_IS_SYNTH_OUTPUT_PAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SYNTH_OUTPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_SYNTH_OUTPUT_PAD_CLASS</NAME>
#define AGS_IS_SYNTH_OUTPUT_PAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SYNTH_OUTPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_SYNTH_OUTPUT_PAD_GET_CLASS</NAME>
#define AGS_SYNTH_OUTPUT_PAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SYNTH_OUTPUT_PAD, AgsSynthOutputPadClass))
</MACRO>
<STRUCT>
<NAME>AgsSynthOutputPad</NAME>
struct _AgsSynthOutputPad
{
  AgsEffectPad effect_pad;
};
</STRUCT>
<STRUCT>
<NAME>AgsSynthOutputPadClass</NAME>
struct _AgsSynthOutputPadClass
{
  AgsEffectPadClass effect_pad;
};
</STRUCT>
<FUNCTION>
<NAME>ags_synth_output_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_output_pad_new</NAME>
<RETURNS>AgsSynthOutputPad * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_drum_output_line_parent_set_callback</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *widget, GtkObject *old_parent, gpointer data 
</FUNCTION>
<FUNCTION>
<NAME>ags_oscillator_wave_callback</NAME>
<RETURNS>void  </RETURNS>
GtkComboBox *combo, AgsOscillator *oscillator 
</FUNCTION>
<FUNCTION>
<NAME>ags_oscillator_attack_callback</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton *spin_button, AgsOscillator *oscillator 
</FUNCTION>
<FUNCTION>
<NAME>ags_oscillator_frame_count_callback</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton *spin_button, AgsOscillator *oscillator 
</FUNCTION>
<FUNCTION>
<NAME>ags_oscillator_frequency_callback</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton *spin_button, AgsOscillator *oscillator 
</FUNCTION>
<FUNCTION>
<NAME>ags_oscillator_phase_callback</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton *spin_button, AgsOscillator *oscillator 
</FUNCTION>
<FUNCTION>
<NAME>ags_oscillator_volume_callback</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton *spin_button, AgsOscillator *oscillator 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_FFPLAYER_INPUT_PAD</NAME>
#define AGS_TYPE_FFPLAYER_INPUT_PAD                (ags_ffplayer_input_pad_get_type())
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_INPUT_PAD</NAME>
#define AGS_FFPLAYER_INPUT_PAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_FFPLAYER_INPUT_PAD, AgsFFPlayerInputPad))
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_INPUT_PAD_CLASS</NAME>
#define AGS_FFPLAYER_INPUT_PAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_FFPLAYER_INPUT_PAD, AgsFFPlayerInputPadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_FFPLAYER_INPUT_PAD</NAME>
#define AGS_IS_FFPLAYER_INPUT_PAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_FFPLAYER_INPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_FFPLAYER_INPUT_PAD_CLASS</NAME>
#define AGS_IS_FFPLAYER_INPUT_PAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_FFPLAYER_INPUT_PAD))
</MACRO>
<MACRO>
<NAME>AGS_FFPLAYER_INPUT_PAD_GET_CLASS</NAME>
#define AGS_FFPLAYER_INPUT_PAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_FFPLAYER_INPUT_PAD, AgsFFPlayerInputPadClass))
</MACRO>
<STRUCT>
<NAME>AgsFFPlayerInputPad</NAME>
struct _AgsFFPlayerInputPad
{
  AgsEffectPad effect_pad;
};
</STRUCT>
<STRUCT>
<NAME>AgsFFPlayerInputPadClass</NAME>
struct _AgsFFPlayerInputPadClass
{
  AgsEffectPadClass effect_pad;
};
</STRUCT>
<FUNCTION>
<NAME>ags_ffplayer_input_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_ffplayer_input_pad_new</NAME>
<RETURNS>AgsFFPlayerInputPad * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_GUI_THREAD</NAME>
#define AGS_TYPE_GUI_THREAD                (ags_gui_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_GUI_THREAD</NAME>
#define AGS_GUI_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_GUI_THREAD, AgsGuiThread))
</MACRO>
<MACRO>
<NAME>AGS_GUI_THREAD_CLASS</NAME>
#define AGS_GUI_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_GUI_THREAD, AgsGuiThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_GUI_THREAD</NAME>
#define AGS_IS_GUI_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_GUI_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_GUI_THREAD_CLASS</NAME>
#define AGS_IS_GUI_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_GUI_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_GUI_THREAD_GET_CLASS</NAME>
#define AGS_GUI_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_GUI_THREAD, AgsGuiThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_GUI_THREAD_DEFAULT_JIFFIE</NAME>
#define AGS_GUI_THREAD_DEFAULT_JIFFIE (60)
</MACRO>
<STRUCT>
<NAME>AgsGuiThread</NAME>
struct _AgsGuiThread
{
  AgsThread thread;

  GMutex mutex;
  GCond cond;
};
</STRUCT>
<STRUCT>
<NAME>AgsGuiThreadClass</NAME>
struct _AgsGuiThreadClass
{
  AgsThreadClass thread;
};
</STRUCT>
<FUNCTION>
<NAME>ags_gui_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_gui_thread_new</NAME>
<RETURNS>AgsGuiThread * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_import_wizard_response_callback</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *wizard, gint response, gpointer data 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TRACK_COLLECTION</NAME>
#define AGS_TYPE_TRACK_COLLECTION                (ags_track_collection_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TRACK_COLLECTION</NAME>
#define AGS_TRACK_COLLECTION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TRACK_COLLECTION, AgsTrackCollection))
</MACRO>
<MACRO>
<NAME>AGS_TRACK_COLLECTION_CLASS</NAME>
#define AGS_TRACK_COLLECTION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_TRACK_COLLECTION, AgsTrackCollectionClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_TRACK_COLLECTION</NAME>
#define AGS_IS_TRACK_COLLECTION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_TRACK_COLLECTION))
</MACRO>
<MACRO>
<NAME>AGS_IS_TRACK_COLLECTION_CLASS</NAME>
#define AGS_IS_TRACK_COLLECTION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_TRACK_COLLECTION))
</MACRO>
<MACRO>
<NAME>AGS_TRACK_COLLECTION_GET_CLASS</NAME>
#define AGS_TRACK_COLLECTION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_TRACK_COLLECTION, AgsTrackCollectionClass))
</MACRO>
<STRUCT>
<NAME>AgsTrackCollection</NAME>
struct _AgsTrackCollection
{
  GtkVBox vbox;

  xmlDoc *midi_doc;

  guint first_offset;
  gdouble bpm;
  
  GType child_type;
  guint child_parameter_count;
  GParameter *child_parameter;

  GtkVBox *child;
};
</STRUCT>
<STRUCT>
<NAME>AgsTrackCollectionClass</NAME>
struct _AgsTrackCollectionClass
{
  GtkVBoxClass vbox;
};
</STRUCT>
<FUNCTION>
<NAME>ags_track_collection_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_track_collection_parse</NAME>
<RETURNS>void  </RETURNS>
AgsTrackCollection *track_collection 
</FUNCTION>
<FUNCTION>
<NAME>ags_track_collection_add_mapper</NAME>
<RETURNS>void  </RETURNS>
AgsTrackCollection *track_collection, xmlNode *track, gchar *instrument, gchar *sequence 
</FUNCTION>
<FUNCTION>
<NAME>ags_track_collection_new</NAME>
<RETURNS>AgsTrackCollection * </RETURNS>
GType child_type, guint child_parameter_count, GParameter *child_parameter 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TRACK_COLLECTION_MAPPER</NAME>
#define AGS_TYPE_TRACK_COLLECTION_MAPPER                (ags_track_collection_mapper_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TRACK_COLLECTION_MAPPER</NAME>
#define AGS_TRACK_COLLECTION_MAPPER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TRACK_COLLECTION_MAPPER, AgsTrackCollectionMapper))
</MACRO>
<MACRO>
<NAME>AGS_TRACK_COLLECTION_MAPPER_CLASS</NAME>
#define AGS_TRACK_COLLECTION_MAPPER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_TRACK_COLLECTION_MAPPER, AgsTrackCollectionMapperClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_TRACK_COLLECTION_MAPPER</NAME>
#define AGS_IS_TRACK_COLLECTION_MAPPER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_TRACK_COLLECTION_MAPPER))
</MACRO>
<MACRO>
<NAME>AGS_IS_TRACK_COLLECTION_MAPPER_CLASS</NAME>
#define AGS_IS_TRACK_COLLECTION_MAPPER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_TRACK_COLLECTION_MAPPER))
</MACRO>
<MACRO>
<NAME>AGS_TRACK_COLLECTION_MAPPER_GET_CLASS</NAME>
#define AGS_TRACK_COLLECTION_MAPPER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_TRACK_COLLECTION_MAPPER, AgsTrackCollectionMapperClass))
</MACRO>
<MACRO>
<NAME>AGS_TRACK_COLLECTION_MAPPER_DEFAULT_BEATS</NAME>
#define AGS_TRACK_COLLECTION_MAPPER_DEFAULT_BEATS (16.0)
</MACRO>
<MACRO>
<NAME>AGS_MIDI_DEFAULT_BEATS</NAME>
#define AGS_MIDI_DEFAULT_BEATS (4.0)
</MACRO>
<STRUCT>
<NAME>AgsTrackCollectionMapper</NAME>
struct _AgsTrackCollectionMapper
{
  GtkTable table;

  gchar *instrument;
  gchar *sequence;
  
  GList *track;

  GList *notation;
  
  GtkCheckButton *enabled;

  GtkVBox *info;
  
  GtkComboBoxText *machine_type;
  GtkSpinButton *audio_channels;
  GtkSpinButton *offset;
};
</STRUCT>
<STRUCT>
<NAME>AgsTrackCollectionMapperClass</NAME>
struct _AgsTrackCollectionMapperClass
{
  GtkTableClass table;
};
</STRUCT>
<FUNCTION>
<NAME>ags_track_collection_mapper_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_track_collection_mapper_find_instrument_with_sequence</NAME>
<RETURNS>GList * </RETURNS>
GList *track_collection_mapper, gchar *instrument, gchar *sequence 
</FUNCTION>
<FUNCTION>
<NAME>ags_track_collection_mapper_map</NAME>
<RETURNS>void  </RETURNS>
AgsTrackCollectionMapper *track_collection_mapper 
</FUNCTION>
<FUNCTION>
<NAME>ags_track_collection_mapper_new</NAME>
<RETURNS>AgsTrackCollectionMapper * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MIDI_IMPORT_WIZARD</NAME>
#define AGS_TYPE_MIDI_IMPORT_WIZARD                (ags_midi_import_wizard_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MIDI_IMPORT_WIZARD</NAME>
#define AGS_MIDI_IMPORT_WIZARD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MIDI_IMPORT_WIZARD, AgsMidiImportWizard))
</MACRO>
<MACRO>
<NAME>AGS_MIDI_IMPORT_WIZARD_CLASS</NAME>
#define AGS_MIDI_IMPORT_WIZARD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MIDI_IMPORT_WIZARD, AgsMidiImportWizardClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MIDI_IMPORT_WIZARD</NAME>
#define AGS_IS_MIDI_IMPORT_WIZARD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_MIDI_IMPORT_WIZARD))
</MACRO>
<MACRO>
<NAME>AGS_IS_MIDI_IMPORT_WIZARD_CLASS</NAME>
#define AGS_IS_MIDI_IMPORT_WIZARD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MIDI_IMPORT_WIZARD))
</MACRO>
<MACRO>
<NAME>AGS_MIDI_IMPORT_WIZARD_GET_CLASS</NAME>
#define AGS_MIDI_IMPORT_WIZARD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_MIDI_IMPORT_WIZARD, AgsMidiImportWizardClass))
</MACRO>
<ENUM>
<NAME>AgsMidiImportWizardFlags</NAME>
typedef enum{
  AGS_MIDI_IMPORT_WIZARD_SHOW_FILE_CHOOSER       = 1,
  AGS_MIDI_IMPORT_WIZARD_SHOW_TRACK_COLLECTION   = 1 << 1,
}AgsMidiImportWizardFlags;
</ENUM>
<STRUCT>
<NAME>AgsMidiImportWizard</NAME>
struct _AgsMidiImportWizard
{
  GtkDialog dialog;

  guint flags;
  
  GtkWidget *parent;
  
  GtkWidget *file_chooser;
  GtkWidget *track_collection;
};
</STRUCT>
<STRUCT>
<NAME>AgsMidiImportWizardClass</NAME>
struct _AgsMidiImportWizardClass
{
  GtkDialogClass dialog;
};
</STRUCT>
<FUNCTION>
<NAME>ags_midi_import_wizard_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_import_wizard_new</NAME>
<RETURNS>AgsMidiImportWizard * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_REGISTRY</NAME>
#define AGS_TYPE_REGISTRY                (ags_registry_get_type())
</MACRO>
<MACRO>
<NAME>AGS_REGISTRY</NAME>
#define AGS_REGISTRY(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_REGISTRY, AgsRegistry))
</MACRO>
<MACRO>
<NAME>AGS_REGISTRY_CLASS</NAME>
#define AGS_REGISTRY_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_REGISTRY, AgsRegistryClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_REGISTRY</NAME>
#define AGS_IS_REGISTRY(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_REGISTRY))
</MACRO>
<MACRO>
<NAME>AGS_IS_REGISTRY_CLASS</NAME>
#define AGS_IS_REGISTRY_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_REGISTRY))
</MACRO>
<MACRO>
<NAME>AGS_REGISTRY_GET_CLASS</NAME>
#define AGS_REGISTRY_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_REGISTRY, AgsRegistryClass))
</MACRO>
<MACRO>
<NAME>AGS_REGISTRY_DEFAULT_ID_LENGTH</NAME>
#define AGS_REGISTRY_DEFAULT_ID_LENGTH 16
</MACRO>
<STRUCT>
<NAME>AgsRegistry</NAME>
struct _AgsRegistry
{
  GObject object;

  guint flags;

  pthread_mutex_t mutex;

  AgsFile *previous;
  AgsFile *current;

#ifdef AGS_WITH_XMLRPC_C
  xmlrpc_registry *registry;
#endif

  GObject *server;

  guint id_length;
  guint counter;

  GList *entry;
};
</STRUCT>
<STRUCT>
<NAME>AgsRegistryClass</NAME>
struct _AgsRegistryClass
{
  GObjectClass object;
};
</STRUCT>
<STRUCT>
<NAME>AgsRegistryEntry</NAME>
struct _AgsRegistryEntry
{
  gchar *id;
  GValue entry;
};
</STRUCT>
<FUNCTION>
<NAME>ags_registry_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_registry_entry_alloc</NAME>
<RETURNS>AgsRegistryEntry * </RETURNS>
AgsRegistry *registry 
</FUNCTION>
<FUNCTION>
<NAME>ags_registry_add</NAME>
<RETURNS>void  </RETURNS>
AgsRegistry *registry, AgsRegistryEntry *registry_entry 
</FUNCTION>
<FUNCTION>
<NAME>ags_registry_entry_find</NAME>
<RETURNS>AgsRegistryEntry * </RETURNS>
AgsRegistry *registry, gchar *id 
</FUNCTION>
<FUNCTION>
<NAME>ags_registry_entry_bulk</NAME>
<RETURNS>xmlrpc_value * </RETURNS>
xmlrpc_env *env, xmlrpc_value *param_array, void *server_info 
</FUNCTION>
<FUNCTION>
<NAME>ags_registry_new</NAME>
<RETURNS>AgsRegistry * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SERVICE_PROVIDER</NAME>
#define AGS_TYPE_SERVICE_PROVIDER                    (ags_service_provider_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SERVICE_PROVIDER</NAME>
#define AGS_SERVICE_PROVIDER(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SERVICE_PROVIDER, AgsServiceProvider))
</MACRO>
<MACRO>
<NAME>AGS_SERVICE_PROVIDER_INTERFACE</NAME>
#define AGS_SERVICE_PROVIDER_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_SERVICE_PROVIDER, AgsServiceProviderInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_SERVICE_PROVIDER</NAME>
#define AGS_IS_SERVICE_PROVIDER(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SERVICE_PROVIDER))
</MACRO>
<MACRO>
<NAME>AGS_IS_SERVICE_PROVIDER_INTERFACE</NAME>
#define AGS_IS_SERVICE_PROVIDER_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_SERVICE_PROVIDER))
</MACRO>
<MACRO>
<NAME>AGS_SERVICE_PROVIDER_GET_INTERFACE</NAME>
#define AGS_SERVICE_PROVIDER_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_SERVICE_PROVIDER, AgsServiceProviderInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsServiceProvider</NAME>
typedef void AgsServiceProvider;
</TYPEDEF>
<STRUCT>
<NAME>AgsServiceProviderInterface</NAME>
struct _AgsServiceProviderInterface
{
  GTypeInterface interface;

  AgsServer* (*get_server)(AgsServiceProvider *service_provider);
};
</STRUCT>
<FUNCTION>
<NAME>ags_service_provider_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_service_provider_get_server</NAME>
<RETURNS>AgsServer * </RETURNS>
AgsServiceProvider *service_provider 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SERVER</NAME>
#define AGS_TYPE_SERVER                (ags_server_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SERVER</NAME>
#define AGS_SERVER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SERVER, AgsServer))
</MACRO>
<MACRO>
<NAME>AGS_SERVER_CLASS</NAME>
#define AGS_SERVER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_SERVER, AgsServerClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SERVER</NAME>
#define AGS_IS_SERVER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_SERVER))
</MACRO>
<MACRO>
<NAME>AGS_IS_SERVER_CLASS</NAME>
#define AGS_IS_SERVER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_SERVER))
</MACRO>
<MACRO>
<NAME>AGS_SERVER_GET_CLASS</NAME>
#define AGS_SERVER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_SERVER, AgsServerClass))
</MACRO>
<ENUM>
<NAME>AgsServerFlags</NAME>
typedef enum{
  AGS_SERVER_STARTED        = 1,
  AGS_SERVER_RUNNING        = 1 << 1,
}AgsServerFlags;
</ENUM>
<STRUCT>
<NAME>AgsServer</NAME>
struct _AgsServer
{
  GObject object;

  guint flags;

#ifdef AGS_WITH_XMLRPC_C
  TServer abyss_server;
  TSocket *socket;
#endif
  int socket_fd;
  struct sockaddr_in address;

  void *server_info;

  GObject *application_context;
  pthread_mutex_t *application_mutex;
  
  AgsRegistry *registry;
  AgsRemoteTask *remote_task;
};
</STRUCT>
<STRUCT>
<NAME>AgsServerClass</NAME>
struct _AgsServerClass
{
  GObjectClass object;
  
  void (*start)(AgsServer *server);
};
</STRUCT>
<FUNCTION>
<NAME>ags_server_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_server_start</NAME>
<RETURNS>void  </RETURNS>
AgsServer *server 
</FUNCTION>
<FUNCTION>
<NAME>ags_server_lookup</NAME>
<RETURNS>AgsServer * </RETURNS>
void *server_info 
</FUNCTION>
<FUNCTION>
<NAME>ags_server_create_object</NAME>
<RETURNS>xmlrpc_value * </RETURNS>
xmlrpc_env *env, xmlrpc_value *param_array, void *server_info 
</FUNCTION>
<FUNCTION>
<NAME>ags_server_object_set_property</NAME>
<RETURNS>xmlrpc_value * </RETURNS>
xmlrpc_env *env, xmlrpc_value *param_array, void *server_info 
</FUNCTION>
<FUNCTION>
<NAME>ags_server_new</NAME>
<RETURNS>AgsServer * </RETURNS>
GObject *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_REMOTE_TASK</NAME>
#define AGS_TYPE_REMOTE_TASK                (ags_remote_task_get_type())
</MACRO>
<MACRO>
<NAME>AGS_REMOTE_TASK</NAME>
#define AGS_REMOTE_TASK(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_REMOTE_TASK, AgsRemoteTask))
</MACRO>
<MACRO>
<NAME>AGS_REMOTE_TASK_CLASS</NAME>
#define AGS_REMOTE_TASK_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_REMOTE_TASK, AgsRemoteTaskClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOTE_TASK</NAME>
#define AGS_IS_REMOTE_TASK(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_REMOTE_TASK))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOTE_TASK_CLASS</NAME>
#define AGS_IS_REMOTE_TASK_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_REMOTE_TASK))
</MACRO>
<MACRO>
<NAME>AGS_REMOTE_TASK_GET_CLASS</NAME>
#define AGS_REMOTE_TASK_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_REMOTE_TASK, AgsRemoteTaskClass))
</MACRO>
<STRUCT>
<NAME>AgsRemoteTask</NAME>
struct _AgsRemoteTask
{
  GObject object;

  GObject *server;
};
</STRUCT>
<STRUCT>
<NAME>AgsRemoteTaskClass</NAME>
struct _AgsRemoteTaskClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_remote_task_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_remote_task_launch</NAME>
<RETURNS>xmlrpc_value * </RETURNS>
xmlrpc_env *env, xmlrpc_value *param_array, void *server_info 
</FUNCTION>
<FUNCTION>
<NAME>ags_remote_task_launch_timed</NAME>
<RETURNS>xmlrpc_value * </RETURNS>
xmlrpc_env *env, xmlrpc_value *param_array, void *server_info 
</FUNCTION>
<FUNCTION>
<NAME>ags_remote_task_new</NAME>
<RETURNS>AgsRemoteTask * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SERVER_APPLICATION_CONTEXT</NAME>
#define AGS_TYPE_SERVER_APPLICATION_CONTEXT                (ags_server_application_context_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SERVER_APPLICATION_CONTEXT</NAME>
#define AGS_SERVER_APPLICATION_CONTEXT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SERVER_APPLICATION_CONTEXT, AgsServerApplicationContext))
</MACRO>
<MACRO>
<NAME>AGS_SERVER_APPLICATION_CONTEXT_CLASS</NAME>
#define AGS_SERVER_APPLICATION_CONTEXT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_SERVER_APPLICATION_CONTEXT, AgsServerApplicationContextClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SERVER_APPLICATION_CONTEXT</NAME>
#define AGS_IS_SERVER_APPLICATION_CONTEXT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_SERVER_APPLICATION_CONTEXT))
</MACRO>
<MACRO>
<NAME>AGS_IS_SERVER_APPLICATION_CONTEXT_CLASS</NAME>
#define AGS_IS_SERVER_APPLICATION_CONTEXT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_SERVER_APPLICATION_CONTEXT))
</MACRO>
<MACRO>
<NAME>AGS_SERVER_APPLICATION_CONTEXT_GET_CLASS</NAME>
#define AGS_SERVER_APPLICATION_CONTEXT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_SERVER_APPLICATION_CONTEXT, AgsServerApplicationContextClass))
</MACRO>
<MACRO>
<NAME>AGS_SERVER_BUILD_ID</NAME>
#define AGS_SERVER_BUILD_ID "Thu Apr  2 13:04:21 GMT 2015\0"
</MACRO>
<MACRO>
<NAME>AGS_SERVER_DEFAULT_VERSION</NAME>
#define AGS_SERVER_DEFAULT_VERSION "0.4.3\0"
</MACRO>
<ENUM>
<NAME>AgsServerApplicationContextFlags</NAME>
typedef enum{
  AGS_SERVER_APPLICATION_CONTEXT_ENABLE_SERVER      = 1,
}AgsServerApplicationContextFlags;
</ENUM>
<STRUCT>
<NAME>AgsServerApplicationContext</NAME>
struct _AgsServerApplicationContext
{
  AgsApplicationContext application_context;

  guint flags;

  gchar *version;
  gchar *build_id;

#ifdef AGS_WITH_XMLRPC_C
  xmlrpc_env env;
#endif

  AgsServer *server;
};
</STRUCT>
<STRUCT>
<NAME>AgsServerApplicationContextClass</NAME>
struct _AgsServerApplicationContextClass
{
  AgsApplicationContextClass application_context;
};
</STRUCT>
<FUNCTION>
<NAME>ags_server_application_context_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_server_application_context_new</NAME>
<RETURNS>AgsServerApplicationContext * </RETURNS>
GObject *main_loop, AgsConfig *config 
</FUNCTION>
<FUNCTION>
<NAME>ags_server_init_context</NAME>
<RETURNS>void  </RETURNS>
AgsApplicationContext *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LADSPA_MANAGER</NAME>
#define AGS_TYPE_LADSPA_MANAGER                (ags_ladspa_manager_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LADSPA_MANAGER</NAME>
#define AGS_LADSPA_MANAGER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LADSPA_MANAGER, AgsLadspaManager))
</MACRO>
<MACRO>
<NAME>AGS_LADSPA_MANAGER_CLASS</NAME>
#define AGS_LADSPA_MANAGER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LADSPA_MANAGER, AgsLadspaManagerClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LADSPA_MANAGER</NAME>
#define AGS_IS_LADSPA_MANAGER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LADSPA_MANAGER))
</MACRO>
<MACRO>
<NAME>AGS_IS_LADSPA_MANAGER_CLASS</NAME>
#define AGS_IS_LADSPA_MANAGER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LADSPA_MANAGER))
</MACRO>
<MACRO>
<NAME>AGS_LADSPA_MANAGER_GET_CLASS</NAME>
#define AGS_LADSPA_MANAGER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_LADSPA_MANAGER, AgsLadspaManagerClass))
</MACRO>
<MACRO>
<NAME>AGS_LADSPA_PLUGIN</NAME>
#define AGS_LADSPA_PLUGIN(ptr) ((AgsLadspaPlugin *)(ptr))
</MACRO>
<ENUM>
<NAME>AgsLadspaPluginFlags</NAME>
typedef enum{
  AGS_LADSPA_PLUGIN_IS_LOADED    = 1,
}AgsLadspaPluginFlags;
</ENUM>
<STRUCT>
<NAME>AgsLadspaManager</NAME>
struct _AgsLadspaManager
{
  GObject object;
  
  GList *ladspa_plugin;
};
</STRUCT>
<STRUCT>
<NAME>AgsLadspaManagerClass</NAME>
struct _AgsLadspaManagerClass
{
  GObjectClass object;
};
</STRUCT>
<STRUCT>
<NAME>AgsLadspaPlugin</NAME>
struct _AgsLadspaPlugin
{
  guint flags;

  gchar *filename;
  void *plugin_so;
};
</STRUCT>
<FUNCTION>
<NAME>ags_ladspa_manager_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_plugin_alloc</NAME>
<RETURNS>AgsLadspaPlugin * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_plugin_free</NAME>
<RETURNS>void  </RETURNS>
AgsLadspaPlugin *ladspa_plugin 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_manager_get_filenames</NAME>
<RETURNS>gchar ** </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_manager_find_ladspa_plugin</NAME>
<RETURNS>AgsLadspaPlugin * </RETURNS>
gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_manager_load_file</NAME>
<RETURNS>void  </RETURNS>
gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_manager_load_default_directory</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_manager_effect_index</NAME>
<RETURNS>unsigned long  </RETURNS>
gchar *filename, gchar *effect 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_manager_get_instance</NAME>
<RETURNS>AgsLadspaManager * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_ladspa_manager_new</NAME>
<RETURNS>AgsLadspaManager * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LV2UI_MANAGER</NAME>
#define AGS_TYPE_LV2UI_MANAGER                (ags_lv2ui_manager_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LV2UI_MANAGER</NAME>
#define AGS_LV2UI_MANAGER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LV2UI_MANAGER, AgsLv2uiManager))
</MACRO>
<MACRO>
<NAME>AGS_LV2UI_MANAGER_CLASS</NAME>
#define AGS_LV2UI_MANAGER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LV2UI_MANAGER, AgsLv2uiManagerClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LV2UI_MANAGER</NAME>
#define AGS_IS_LV2UI_MANAGER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LV2UI_MANAGER))
</MACRO>
<MACRO>
<NAME>AGS_IS_LV2UI_MANAGER_CLASS</NAME>
#define AGS_IS_LV2UI_MANAGER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LV2UI_MANAGER))
</MACRO>
<MACRO>
<NAME>AGS_LV2UI_MANAGER_GET_CLASS</NAME>
#define AGS_LV2UI_MANAGER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_LV2UI_MANAGER, AgsLv2uiManagerClass))
</MACRO>
<MACRO>
<NAME>AGS_LV2UI_PLUGIN</NAME>
#define AGS_LV2UI_PLUGIN(ptr) ((AgsLv2uiPlugin *)(ptr))
</MACRO>
<ENUM>
<NAME>AgsLv2uiPluginFlags</NAME>
typedef enum{
  AGS_LV2UI_PLUGIN_IS_LOADED    = 1,
}AgsLv2uiPluginFlags;
</ENUM>
<STRUCT>
<NAME>AgsLv2uiManager</NAME>
struct _AgsLv2uiManager
{
  GObject object;

  GList *lv2ui_plugin;
};
</STRUCT>
<STRUCT>
<NAME>AgsLv2uiManagerClass</NAME>
struct _AgsLv2uiManagerClass
{
  GObjectClass object;
};
</STRUCT>
<STRUCT>
<NAME>AgsLv2uiPlugin</NAME>
struct _AgsLv2uiPlugin
{
  guint flags;

  AgsTurtle *turtle;

  gchar *filename;
  void *plugin_so;
};
</STRUCT>
<FUNCTION>
<NAME>ags_lv2ui_manager_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2ui_plugin_alloc</NAME>
<RETURNS>AgsLv2uiPlugin * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2ui_plugin_free</NAME>
<RETURNS>void  </RETURNS>
AgsLv2uiPlugin *lv2ui_plugin 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2ui_manager_get_filenames</NAME>
<RETURNS>gchar ** </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2ui_manager_find_lv2ui_plugin</NAME>
<RETURNS>AgsLv2uiPlugin * </RETURNS>
gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2ui_manager_load_file</NAME>
<RETURNS>void  </RETURNS>
AgsTurtle *turtle, gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2ui_manager_load_default_directory</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2ui_manager_uri_index</NAME>
<RETURNS>uint32_t  </RETURNS>
gchar *filename, gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2ui_manager_get_instance</NAME>
<RETURNS>AgsLv2uiManager * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2ui_manager_new</NAME>
<RETURNS>AgsLv2uiManager * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLUGIN_FACTORY</NAME>
#define AGS_TYPE_PLUGIN_FACTORY                (ags_plugin_factory_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLUGIN_FACTORY</NAME>
#define AGS_PLUGIN_FACTORY(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLUGIN_FACTORY, AgsPluginFactory))
</MACRO>
<MACRO>
<NAME>AGS_PLUGIN_FACTORY_CLASS</NAME>
#define AGS_PLUGIN_FACTORY_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PLUGIN_FACTORY, AgsPluginFactoryClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLUGIN_FACTORY</NAME>
#define AGS_IS_PLUGIN_FACTORY(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PLUGIN_FACTORY))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLUGIN_FACTORY_CLASS</NAME>
#define AGS_IS_PLUGIN_FACTORY_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PLUGIN_FACTORY))
</MACRO>
<MACRO>
<NAME>AGS_PLUGIN_FACTORY_GET_CLASS</NAME>
#define AGS_PLUGIN_FACTORY_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_PLUGIN_FACTORY, AgsPluginFactoryClass))
</MACRO>
<STRUCT>
<NAME>AgsPluginFactory</NAME>
struct _AgsPluginFactory
{
  GObject object;

  GList *plugin;
};
</STRUCT>
<STRUCT>
<NAME>AgsPluginFactoryClass</NAME>
struct _AgsPluginFactoryClass
{
  GObjectClass object;

  void (*add)(AgsPluginFactory *plugin_factory,
	      GType plugin_type,
	      gchar *plugin_name,
	      gchar *version, gchar *build_id,
	      gchar *xml_type,
	      GParameter *control, guint control_count);

  AgsPlugin* (*create)(AgsPluginFactory *plugin_factory,
		       gchar *xml_type);
};
</STRUCT>
<STRUCT>
<NAME>AgsPluginMetadata</NAME>
struct _AgsPluginMetadata
{
  GType plugin_type;
  gchar *plugin_name;

  gchar *version;
  gchar *build_id;

  gchar *xml_type;

  GParameter *control;
  guint control_count;
};
</STRUCT>
<FUNCTION>
<NAME>ags_plugin_factory_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_factory_read_file</NAME>
<RETURNS>void  </RETURNS>
AgsPluginFactory *plugin_factory, gchar *path 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_factory_list_by_name</NAME>
<RETURNS>GList * </RETURNS>
AgsPluginFactory *plugin_factory, gchar *plugin_name 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_factory_add</NAME>
<RETURNS>void  </RETURNS>
AgsPluginFactory *plugin_factory, GType plugin_type, gchar *plugin_name, gchar *version, gchar *build_id, gchar *xml_type, GParameter *control, guint control_count 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_factory_create</NAME>
<RETURNS>AgsPlugin * </RETURNS>
AgsPluginFactory *plugin_factory, gchar *plugin_name, gchar *version, gchar *build_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_factory_get_instance</NAME>
<RETURNS>AgsPluginFactory * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_factory_new_from_file</NAME>
<RETURNS>AgsPluginFactory * </RETURNS>
gchar *path 
</FUNCTION>
<FUNCTION>
<NAME>ags_plugin_factory_new</NAME>
<RETURNS>AgsPluginFactory * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LV2_MANAGER</NAME>
#define AGS_TYPE_LV2_MANAGER                (ags_lv2_manager_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LV2_MANAGER</NAME>
#define AGS_LV2_MANAGER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LV2_MANAGER, AgsLv2Manager))
</MACRO>
<MACRO>
<NAME>AGS_LV2_MANAGER_CLASS</NAME>
#define AGS_LV2_MANAGER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LV2_MANAGER, AgsLv2ManagerClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LV2_MANAGER</NAME>
#define AGS_IS_LV2_MANAGER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LV2_MANAGER))
</MACRO>
<MACRO>
<NAME>AGS_IS_LV2_MANAGER_CLASS</NAME>
#define AGS_IS_LV2_MANAGER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LV2_MANAGER))
</MACRO>
<MACRO>
<NAME>AGS_LV2_MANAGER_GET_CLASS</NAME>
#define AGS_LV2_MANAGER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_LV2_MANAGER, AgsLv2ManagerClass))
</MACRO>
<MACRO>
<NAME>AGS_LV2_PLUGIN</NAME>
#define AGS_LV2_PLUGIN(ptr) ((AgsLv2Plugin *)(ptr))
</MACRO>
<MACRO>
<NAME>AGS_LV2_MANAGER_DEFAULT_LOCALE</NAME>
#define AGS_LV2_MANAGER_DEFAULT_LOCALE "en-gb\0"
</MACRO>
<ENUM>
<NAME>AgsLv2PluginFlags</NAME>
typedef enum{
  AGS_LV2_PLUGIN_IS_LOADED    = 1,
}AgsLv2PluginFlags;
</ENUM>
<STRUCT>
<NAME>AgsLv2Manager</NAME>
struct _AgsLv2Manager
{
  GObject object;

  gchar *locale;
  
  GList *lv2_plugin;
};
</STRUCT>
<STRUCT>
<NAME>AgsLv2ManagerClass</NAME>
struct _AgsLv2ManagerClass
{
  GObjectClass object;
};
</STRUCT>
<STRUCT>
<NAME>AgsLv2Plugin</NAME>
struct _AgsLv2Plugin
{
  guint flags;

  AgsTurtle *turtle;

  gchar *filename;
  void *plugin_so;
};
</STRUCT>
<FUNCTION>
<NAME>ags_lv2_manager_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_plugin_alloc</NAME>
<RETURNS>AgsLv2Plugin * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_plugin_free</NAME>
<RETURNS>void  </RETURNS>
AgsLv2Plugin *lv2_plugin 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_manager_get_filenames</NAME>
<RETURNS>gchar ** </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_manager_find_lv2_plugin</NAME>
<RETURNS>AgsLv2Plugin * </RETURNS>
gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_manager_load_file</NAME>
<RETURNS>void  </RETURNS>
AgsTurtle *turtle, gchar *filename 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_manager_load_default_directory</NAME>
<RETURNS>void  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_manager_uri_index</NAME>
<RETURNS>uint32_t  </RETURNS>
gchar *filename, gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_manager_get_instance</NAME>
<RETURNS>AgsLv2Manager * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_lv2_manager_new</NAME>
<RETURNS>AgsLv2Manager * </RETURNS>
gchar *locale 
</FUNCTION>
<MACRO>
<NAME>AGS_PLUGIN_NAME_VOLUME</NAME>
#define AGS_PLUGIN_NAME_VOLUME "ags-volume\0"
</MACRO>
<MACRO>
<NAME>AGS_TYPE_RECALL_CHANNEL</NAME>
#define AGS_TYPE_RECALL_CHANNEL                (ags_recall_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CHANNEL</NAME>
#define AGS_RECALL_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_CHANNEL, AgsRecallChannel))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CHANNEL_CLASS</NAME>
#define AGS_RECALL_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_CHANNEL, AgsRecallChannelClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_CHANNEL</NAME>
#define AGS_IS_RECALL_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECALL_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_CHANNEL_CLASS</NAME>
#define AGS_IS_RECALL_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECALL_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CHANNEL_GET_CLASS</NAME>
#define AGS_RECALL_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_RECALL_CHANNEL, AgsRecallChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsRecallChannel</NAME>
struct _AgsRecallChannel
{
  AgsRecall recall;

  AgsChannel *destination;
  AgsChannel *source;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallChannelClass</NAME>
struct _AgsRecallChannelClass
{
  AgsRecallClass recall;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_channel_find_channel</NAME>
<RETURNS>GList * </RETURNS>
GList *recall_channel, AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_channel_new</NAME>
<RETURNS>AgsRecallChannel * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_INPUT</NAME>
#define AGS_TYPE_INPUT                (ags_input_get_type())
</MACRO>
<MACRO>
<NAME>AGS_INPUT</NAME>
#define AGS_INPUT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_INPUT, AgsInput))
</MACRO>
<MACRO>
<NAME>AGS_INPUT_CLASS</NAME>
#define AGS_INPUT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_INPUT, AgsInputClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_INPUT</NAME>
#define AGS_IS_INPUT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_INPUT))
</MACRO>
<MACRO>
<NAME>AGS_IS_INPUT_CLASS</NAME>
#define AGS_IS_INPUT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_INPUT))
</MACRO>
<MACRO>
<NAME>AGS_INPUT_GET_CLASS</NAME>
#define AGS_INPUT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_INPUT, AgsInputClass))
</MACRO>
<STRUCT>
<NAME>AgsInput</NAME>
struct _AgsInput
{
  AgsChannel channel;

  GObject *file_link;
};
</STRUCT>
<STRUCT>
<NAME>AgsInputClass</NAME>
struct _AgsInputClass
{
  AgsChannelClass channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_input_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_input_new</NAME>
<RETURNS>AgsInput * </RETURNS>
GObject *audio 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_OUTPUT</NAME>
#define AGS_TYPE_OUTPUT                (ags_output_get_type())
</MACRO>
<MACRO>
<NAME>AGS_OUTPUT</NAME>
#define AGS_OUTPUT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_OUTPUT, AgsOutput))
</MACRO>
<MACRO>
<NAME>AGS_OUTPUT_CLASS</NAME>
#define AGS_OUTPUT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_OUTPUT, AgsOutputClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_OUTPUT</NAME>
#define AGS_IS_OUTPUT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_OUTPUT))
</MACRO>
<MACRO>
<NAME>AGS_IS_OUTPUT_CLASS</NAME>
#define AGS_IS_OUTPUT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_OUTPUT))
</MACRO>
<MACRO>
<NAME>AGS_OUTPUT_GET_CLASS</NAME>
#define AGS_OUTPUT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_OUTPUT, AgsOutputClass))
</MACRO>
<STRUCT>
<NAME>AgsOutput</NAME>
struct _AgsOutput
{
  AgsChannel channel;
};
</STRUCT>
<STRUCT>
<NAME>AgsOutputClass</NAME>
struct _AgsOutputClass
{
  AgsChannelClass channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_output_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_output_find_first_input_recycling</NAME>
<RETURNS>AgsRecycling * </RETURNS>
AgsOutput *output 
</FUNCTION>
<FUNCTION>
<NAME>ags_output_find_last_input_recycling</NAME>
<RETURNS>AgsRecycling * </RETURNS>
AgsOutput *output 
</FUNCTION>
<FUNCTION>
<NAME>ags_output_new</NAME>
<RETURNS>AgsOutput * </RETURNS>
GObject *audio 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_FACTORY</NAME>
#define AGS_TYPE_RECALL_FACTORY                (ags_recall_factory_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_FACTORY</NAME>
#define AGS_RECALL_FACTORY(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_FACTORY, AgsRecallFactory))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_FACTORY_CLASS</NAME>
#define AGS_RECALL_FACTORY_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_FACTORY, AgsRecallFactoryClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_FACTORY</NAME>
#define AGS_IS_RECALL_FACTORY(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_RECALL_FACTORY))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_FACTORY_CLASS</NAME>
#define AGS_IS_RECALL_FACTORY_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_RECALL_FACTORY))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_FACTORY_GET_CLASS</NAME>
#define AGS_RECALL_FACTORY_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_RECALL_FACTORY, AgsRecallFactoryClass))
</MACRO>
<ENUM>
<NAME>AgsRecallFactoryCreateFlags</NAME>
typedef enum{
  AGS_RECALL_FACTORY_OUTPUT    = 1,
  AGS_RECALL_FACTORY_INPUT     = 1 << 1,
  AGS_RECALL_FACTORY_REMAP     = 1 << 2,
  AGS_RECALL_FACTORY_ADD       = 1 << 3,
  AGS_RECALL_FACTORY_PLAY      = 1 << 4,
  AGS_RECALL_FACTORY_RECALL    = 1 << 5,
}AgsRecallFactoryCreateFlags;
</ENUM>
<STRUCT>
<NAME>AgsRecallFactory</NAME>
struct _AgsRecallFactory
{
  GObject object;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallFactoryClass</NAME>
struct _AgsRecallFactoryClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_factory_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_factory_create</NAME>
<RETURNS>GList * </RETURNS>
AgsAudio *audio, AgsRecallContainer *play_container, AgsRecallContainer *recall_container, gchar *plugin_name, guint start_audio_channel, guint stop_audio_channel, guint start_pad, guint stop_pad, guint create_flags, guint recall_flags 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_factory_remove</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallContainer *recall_container 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_factory_get_instance</NAME>
<RETURNS>AgsRecallFactory * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_factory_new</NAME>
<RETURNS>AgsRecallFactory * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAYBACK_DOMAIN</NAME>
#define AGS_TYPE_PLAYBACK_DOMAIN                (ags_playback_domain_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAYBACK_DOMAIN</NAME>
#define AGS_PLAYBACK_DOMAIN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAYBACK_DOMAIN, AgsPlaybackDomain))
</MACRO>
<MACRO>
<NAME>AGS_PLAYBACK_DOMAIN_CLASS</NAME>
#define AGS_PLAYBACK_DOMAIN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_PLAYBACK_DOMAIN, AgsPlaybackDomain))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAYBACK_DOMAIN</NAME>
#define AGS_IS_PLAYBACK_DOMAIN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PLAYBACK_DOMAIN))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAYBACK_DOMAIN_CLASS</NAME>
#define AGS_IS_PLAYBACK_DOMAIN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PLAYBACK_DOMAIN))
</MACRO>
<MACRO>
<NAME>AGS_PLAYBACK_DOMAIN_GET_CLASS</NAME>
#define AGS_PLAYBACK_DOMAIN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_PLAYBACK_DOMAIN, AgsPlaybackDomainClass))
</MACRO>
<STRUCT>
<NAME>AgsPlaybackDomain</NAME>
struct _AgsPlaybackDomain
{
  GObject gobject;

  GObject *domain;
  
  gboolean do_playback;
  gboolean do_sequencer;
  gboolean do_notation;

  GList *playback;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlaybackDomainClass</NAME>
struct _AgsPlaybackDomainClass
{
  GObjectClass gobject;
};
</STRUCT>
<FUNCTION>
<NAME>ags_playback_domain_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_playback_domain_new</NAME>
<RETURNS>AgsPlaybackDomain * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECYCLING_CONTEXT</NAME>
#define AGS_TYPE_RECYCLING_CONTEXT                (ags_recycling_context_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECYCLING_CONTEXT</NAME>
#define AGS_RECYCLING_CONTEXT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECYCLING_CONTEXT, AgsRecyclingContext))
</MACRO>
<MACRO>
<NAME>AGS_RECYCLING_CONTEXT_CLASS</NAME>
#define AGS_RECYCLING_CONTEXT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECYCLING_CONTEXT, AgsRecyclingContextClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECYCLING_CONTEXT</NAME>
#define AGS_IS_RECYCLING_CONTEXT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECYCLING_CONTEXT))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECYCLING_CONTEXT_CLASS</NAME>
#define AGS_IS_RECYCLING_CONTEXT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECYCLING_CONTEXT))
</MACRO>
<MACRO>
<NAME>AGS_RECYCLING_CONTEXT_GET_CLASS</NAME>
#define AGS_RECYCLING_CONTEXT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_RECYCLING_CONTEXT, AgsRecyclingContextClass))
</MACRO>
<STRUCT>
<NAME>AgsRecyclingContext</NAME>
struct _AgsRecyclingContext
{
  GObject object;

  GObject *recall_id;

  AgsRecycling **recycling;
  guint64 length;

  AgsRecyclingContext *parent;
  GList *children;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecyclingContextClass</NAME>
struct _AgsRecyclingContextClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recycling_context_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_replace</NAME>
<RETURNS>void  </RETURNS>
AgsRecyclingContext *recycling_context, AgsRecycling *recycling, gint position 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_add</NAME>
<RETURNS>AgsRecyclingContext * </RETURNS>
AgsRecyclingContext *recycling_context, AgsRecycling *recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_remove</NAME>
<RETURNS>AgsRecyclingContext * </RETURNS>
AgsRecyclingContext *recycling_context, AgsRecycling *recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_insert</NAME>
<RETURNS>AgsRecyclingContext * </RETURNS>
AgsRecyclingContext *recycling_context, AgsRecycling *recycling, gint position 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_get_toplevel</NAME>
<RETURNS>AgsRecyclingContext * </RETURNS>
AgsRecyclingContext *recycling_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_find</NAME>
<RETURNS>gint  </RETURNS>
AgsRecyclingContext *recycling_context, AgsRecycling *recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_find_child</NAME>
<RETURNS>gint  </RETURNS>
AgsRecyclingContext *recycling_context, AgsRecycling *recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_find_parent</NAME>
<RETURNS>gint  </RETURNS>
AgsRecyclingContext *recycling_context, AgsRecycling *recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_add_child</NAME>
<RETURNS>void  </RETURNS>
AgsRecyclingContext *parent, AgsRecyclingContext *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_remove_child</NAME>
<RETURNS>void  </RETURNS>
AgsRecyclingContext *parent, AgsRecyclingContext *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_get_child_recall_id</NAME>
<RETURNS>GList * </RETURNS>
AgsRecyclingContext *recycling_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_reset_recycling</NAME>
<RETURNS>AgsRecyclingContext * </RETURNS>
AgsRecyclingContext *recycling_context, AgsRecycling *old_first_recycling, AgsRecycling *old_last_recycling, AgsRecycling *new_first_recycling, AgsRecycling *new_last_recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_context_new</NAME>
<RETURNS>AgsRecyclingContext * </RETURNS>
gint length 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SOUND_PROVIDER</NAME>
#define AGS_TYPE_SOUND_PROVIDER                    (ags_sound_provider_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SOUND_PROVIDER</NAME>
#define AGS_SOUND_PROVIDER(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SOUND_PROVIDER, AgsSoundProvider))
</MACRO>
<MACRO>
<NAME>AGS_SOUND_PROVIDER_INTERFACE</NAME>
#define AGS_SOUND_PROVIDER_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_SOUND_PROVIDER, AgsSoundProviderInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_SOUND_PROVIDER</NAME>
#define AGS_IS_SOUND_PROVIDER(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SOUND_PROVIDER))
</MACRO>
<MACRO>
<NAME>AGS_IS_SOUND_PROVIDER_INTERFACE</NAME>
#define AGS_IS_SOUND_PROVIDER_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_SOUND_PROVIDER))
</MACRO>
<MACRO>
<NAME>AGS_SOUND_PROVIDER_GET_INTERFACE</NAME>
#define AGS_SOUND_PROVIDER_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_SOUND_PROVIDER, AgsSoundProviderInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsSoundProvider</NAME>
typedef void AgsSoundProvider;
</TYPEDEF>
<STRUCT>
<NAME>AgsSoundProviderInterface</NAME>
struct _AgsSoundProviderInterface
{
  GTypeInterface interface;

  GList* (*get_soundcard)(AgsSoundProvider *sound_provider);
};
</STRUCT>
<FUNCTION>
<NAME>ags_sound_provider_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_sound_provider_get_soundcard</NAME>
<RETURNS>GList * </RETURNS>
AgsSoundProvider *sound_provider 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_RECYCLING</NAME>
#define AGS_TYPE_RECALL_RECYCLING                (ags_recall_recycling_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_RECYCLING</NAME>
#define AGS_RECALL_RECYCLING(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_RECYCLING, AgsRecallRecycling))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_RECYCLING_CLASS</NAME>
#define AGS_RECALL_RECYCLING_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_RECYCLING, AgsRecallRecyclingClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_RECYCLING</NAME>
#define AGS_IS_RECALL_RECYCLING(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECALL_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_RECYCLING_CLASS</NAME>
#define AGS_IS_RECALL_RECYCLING_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECALL_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_RECYCLING_GET_CLASS</NAME>
#define AGS_RECALL_RECYCLING_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_RECALL_RECYCLING, AgsRecallRecyclingClass))
</MACRO>
<ENUM>
<NAME>AgsRecallRecyclingFlags</NAME>
typedef enum{
  AGS_RECALL_RECYCLING_GARBAGE_COLLECTOR                = 1,
  AGS_RECALL_RECYCLING_MAP_CHILD_DESTINATION            = 1 << 1,
  AGS_RECALL_RECYCLING_MAP_CHILD_SOURCE                 = 1 << 2,
  AGS_RECALL_RECYCLING_CREATE_DESTINATION_ON_MAP_SOURCE = 1 << 3,
}AgsRecallRecyclingFlags;
</ENUM>
<STRUCT>
<NAME>AgsRecallRecycling</NAME>
struct _AgsRecallRecycling
{
  AgsRecall recall;

  guint flags;

  guint audio_channel;

  AgsRecycling *destination;
  gulong destination_add_audio_signal_handler;
  gulong destination_remove_audio_signal_handler;

  AgsRecycling *source;
  gulong source_add_audio_signal_handler;
  gulong source_remove_audio_signal_handler;

  AgsAudioSignal *child_destination;
  GList *child_source;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallRecyclingClass</NAME>
struct _AgsRecallRecyclingClass
{
  AgsRecallClass recall;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_recycling_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_recycling_get_child_source</NAME>
<RETURNS>GList * </RETURNS>
AgsRecallRecycling *recall_recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_recycling_new</NAME>
<RETURNS>AgsRecallRecycling * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_LV2_RUN</NAME>
#define AGS_TYPE_RECALL_LV2_RUN                (ags_recall_lv2_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_LV2_RUN</NAME>
#define AGS_RECALL_LV2_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_LV2_RUN, AgsRecallLv2Run))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_LV2_RUN_CLASS</NAME>
#define AGS_RECALL_LV2_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_LV2_RUN, AgsRecallLv2RunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_LV2_RUN</NAME>
#define AGS_IS_RECALL_LV2_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_RECALL_LV2_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_LV2_RUN_CLASS</NAME>
#define AGS_IS_RECALL_LV2_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_RECALL_LV2_RUN))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_LV2_RUN_GET_CLASS</NAME>
#define AGS_RECALL_LV2_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_RECALL_LV2_RUN, AgsRecallLv2RunClass))
</MACRO>
<STRUCT>
<NAME>AgsRecallLv2Run</NAME>
struct _AgsRecallLv2Run
{
  AgsRecallAudioSignal recall_audio_signal;

  LV2_Handle *lv2_handle;

  float *input;
  float *output;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallLv2RunClass</NAME>
struct _AgsRecallLv2RunClass
{
  AgsRecallAudioSignalClass recall_audio_signal;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_lv2_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_lv2_run_new</NAME>
<RETURNS>AgsRecallLv2Run * </RETURNS>
AgsAudioSignal *audio_signal 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_AUDIO</NAME>
#define AGS_TYPE_RECALL_AUDIO                (ags_recall_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_AUDIO</NAME>
#define AGS_RECALL_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_AUDIO, AgsRecallAudio))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_AUDIO_CLASS</NAME>
#define AGS_RECALL_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_AUDIO, AgsRecallAudioClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_AUDIO</NAME>
#define AGS_IS_RECALL_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECALL_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_AUDIO_CLASS</NAME>
#define AGS_IS_RECALL_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECALL_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_AUDIO_GET_CLASS</NAME>
#define AGS_RECALL_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_RECALL_AUDIO, AgsRecallAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsRecallAudio</NAME>
struct _AgsRecallAudio
{
  AgsRecall recall;

  AgsAudio *audio;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallAudioClass</NAME>
struct _AgsRecallAudioClass
{
  AgsRecallClass recall;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_audio_new</NAME>
<RETURNS>AgsRecallAudio * </RETURNS>
AgsAudio *audio 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CHANNEL</NAME>
#define AGS_TYPE_CHANNEL                (ags_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_CHANNEL</NAME>
#define AGS_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CHANNEL, AgsChannel))
</MACRO>
<MACRO>
<NAME>AGS_CHANNEL_CLASS</NAME>
#define AGS_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_CHANNEL, AgsChannelClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_CHANNEL</NAME>
#define AGS_IS_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_CHANNEL_CLASS</NAME>
#define AGS_IS_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_CHANNEL_GET_CLASS</NAME>
#define AGS_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_CHANNEL, AgsChannelClass))
</MACRO>
<ENUM>
<NAME>AgsChannelFlags</NAME>
typedef enum{
  AGS_CHANNEL_CONNECTED      = 1,
  AGS_CHANNEL_RUNNING        = 1 << 1,
}AgsChannelFlags;
</ENUM>
<ENUM>
<NAME>AgsChannelRecallIDMode</NAME>
typedef enum{
  AGS_CHANNEL_RECALL_ID_RUN_STAGE,
  AGS_CHANNEL_RECALL_ID_CANCEL,
}AgsChannelRecallIDMode;
</ENUM>
<MACRO>
<NAME>AGS_CHANNEL_ERROR</NAME>
#define AGS_CHANNEL_ERROR (ags_channel_error_quark())
</MACRO>
<ENUM>
<NAME>AgsChannelError</NAME>
typedef enum{
  AGS_CHANNEL_ERROR_LOOP_IN_LINK,
}AgsChannelError;
</ENUM>
<STRUCT>
<NAME>AgsChannel</NAME>
struct _AgsChannel
{
  GObject object;

  guint flags;

  GObject *audio;
  GObject *soundcard;

  AgsChannel *prev;
  AgsChannel *prev_pad;
  AgsChannel *next;
  AgsChannel *next_pad;

  guint pad;
  guint audio_channel;
  guint line;

  char *note;

  GObject *playback;

  // GObject *recycling_context; // contains child recycling
  GList *recall_id; // there may be several recall's running
  
  GList *container;
  GList *recall;
  GList *play;

  AgsChannel *link;
  AgsRecycling *first_recycling;
  AgsRecycling *last_recycling;
  GObject *recycling_thread;

  GList *pattern;

  GObject *line_widget;
  gpointer file_data;
};
</STRUCT>
<STRUCT>
<NAME>AgsChannelClass</NAME>
struct _AgsChannelClass
{
  GObjectClass object;

  GList* (*add_effect)(AgsChannel *channel,
		       gchar *filename,
		       gchar *effect);
  void (*remove_effect)(AgsChannel *channel,
			guint nth);
  
  void (*recycling_changed)(AgsChannel *channel,
			    AgsRecycling *old_start_region, AgsRecycling *old_end_region,
			    AgsRecycling *new_start_region, AgsRecycling *new_end_region,
			    AgsRecycling *old_start_changed_region, AgsRecycling *old_end_changed_region,
			    AgsRecycling *new_start_changed_region, AgsRecycling *new_end_changed_region);

  void (*done)(AgsChannel *channel,
	       AgsRecallID *recall_id);
};
</STRUCT>
<FUNCTION>
<NAME>ags_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_first</NAME>
<RETURNS>AgsChannel * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_last</NAME>
<RETURNS>AgsChannel * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_nth</NAME>
<RETURNS>AgsChannel * </RETURNS>
AgsChannel *channel, guint nth 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_pad_first</NAME>
<RETURNS>AgsChannel * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_pad_last</NAME>
<RETURNS>AgsChannel * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_pad_nth</NAME>
<RETURNS>AgsChannel * </RETURNS>
AgsChannel *channel, guint nth 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_first_with_recycling</NAME>
<RETURNS>AgsChannel * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_last_with_recycling</NAME>
<RETURNS>AgsChannel * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_set_soundcard</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, GObject *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_remove_recall_id</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_add_recall_id</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_add_recall_container</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, GObject *recall_container 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_remove_recall_container</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, GObject *recall_container 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_remove_recall</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, GObject *recall, gboolean play 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_add_recall</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, GObject *recall, gboolean play 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_remove_pattern</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, GObject *pattern 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_add_pattern</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, GObject *pattern 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_get_recall_by_effect</NAME>
<RETURNS>GList * </RETURNS>
AgsChannel *channel, gchar *filename, gchar *effect 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_add_effect</NAME>
<RETURNS>GList * </RETURNS>
AgsChannel *channel, char *filename, gchar *effect 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_remove_effect</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, guint nth 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_set_link</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsChannel *link, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_set_recycling</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecycling *first_recycling, AgsRecycling *last_recycling, gboolean update, gboolean destroy_old 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_recursive_reset_recycling_context</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecyclingContext *old_recycling_context, AgsRecyclingContext *recycling_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_recycling_changed</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecycling *old_start_region, AgsRecycling *old_end_region, AgsRecycling *new_start_region, AgsRecycling *new_end_region, AgsRecycling *old_start_changed_region, AgsRecycling *old_end_changed_region, AgsRecycling *new_start_changed_region, AgsRecycling *new_end_changed_region 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_done</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_safe_resize_audio_signal</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, guint size 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_resolve_recall</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_play</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecallID *recall_id, gint stage 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_recursive_play_threaded</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecallID *recall_id, gint stage 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_recursive_play</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecallID *recall_id, gint stage 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_duplicate_recall</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_init_recall</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, gint stage, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_recursive_play_init</NAME>
<RETURNS>AgsRecallID * </RETURNS>
AgsChannel *channel, gint stage, gboolean arrange_recall_id, gboolean duplicate_templates, gboolean playback, gboolean sequencer, gboolean notation, gboolean resolve_dependencies, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_cancel</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_remove</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_tillrecycling_cancel</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_recursive_reset_recall_ids</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *channel, AgsChannel *link, AgsChannel *old_channel_link, AgsChannel *old_link_link 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_recall_id_set</NAME>
<RETURNS>void  </RETURNS>
AgsChannel *output, AgsRecallID *recall_id, gboolean ommit_own_channel, guint mode, ... 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_find_port</NAME>
<RETURNS>GList * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_new</NAME>
<RETURNS>AgsChannel * </RETURNS>
GObject *audio 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_DEVOUT</NAME>
#define AGS_TYPE_DEVOUT                (ags_devout_get_type())
</MACRO>
<MACRO>
<NAME>AGS_DEVOUT</NAME>
#define AGS_DEVOUT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_DEVOUT, AgsDevout))
</MACRO>
<MACRO>
<NAME>AGS_DEVOUT_CLASS</NAME>
#define AGS_DEVOUT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_DEVOUT, AgsDevout))
</MACRO>
<MACRO>
<NAME>AGS_IS_DEVOUT</NAME>
#define AGS_IS_DEVOUT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_DEVOUT))
</MACRO>
<MACRO>
<NAME>AGS_IS_DEVOUT_CLASS</NAME>
#define AGS_IS_DEVOUT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_DEVOUT))
</MACRO>
<MACRO>
<NAME>AGS_DEVOUT_GET_CLASS</NAME>
#define AGS_DEVOUT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_DEVOUT, AgsDevoutClass))
</MACRO>
<ENUM>
<NAME>AgsDevoutFlags</NAME>
typedef enum
{
  AGS_DEVOUT_BUFFER0                        = 1,
  AGS_DEVOUT_BUFFER1                        = 1 << 1,
  AGS_DEVOUT_BUFFER2                        = 1 << 2,
  AGS_DEVOUT_BUFFER3                        = 1 << 3,

  AGS_DEVOUT_ATTACK_FIRST                   = 1 << 4,

  AGS_DEVOUT_PLAY                           = 1 << 5,

  AGS_DEVOUT_OSS                            = 1 << 6,
  AGS_DEVOUT_ALSA                           = 1 << 7,

  AGS_DEVOUT_SHUTDOWN                       = 1 << 8,
  AGS_DEVOUT_START_PLAY                     = 1 << 9,

  AGS_DEVOUT_NONBLOCKING                    = 1 << 10,
}AgsDevoutFlags;
</ENUM>
<MACRO>
<NAME>AGS_DEVOUT_ERROR</NAME>
#define AGS_DEVOUT_ERROR (ags_devout_error_quark())
</MACRO>
<ENUM>
<NAME>AgsDevoutError</NAME>
typedef enum{
  AGS_DEVOUT_ERROR_LOCKED_SOUNDCARD,
}AgsDevoutError;
</ENUM>
<STRUCT>
<NAME>AgsDevout</NAME>
struct _AgsDevout
{
  GObject object;

  guint flags;

  guint dsp_channels;
  guint pcm_channels;
  guint format;
  guint buffer_size;
  guint samplerate; // sample_rate

  signed short** buffer;

  gdouble bpm; // beats per minute

  gdouble *delay; // count of tics within buffer size
  guint *attack; // where currently tic resides in the stream's offset, measured in 1/64 of bpm

  gdouble delay_counter; // next time attack changeing when delay_counter == delay
  guint tic_counter; // in the range of default period

  guint note_offset;
  
  union{
    struct _AgsOss{
      int device_fd;
      char *device;
    }oss;
    struct _AgsAlsa{
      char *device;
      int rc;
      snd_pcm_t *handle;
      snd_async_handler_t *ahandler;
      snd_pcm_hw_params_t *params;
    }alsa;
  }out;

  GObject *application_context;
  pthread_mutex_t *application_mutex;
  
  GList *audio;
};
</STRUCT>
<STRUCT>
<NAME>AgsDevoutClass</NAME>
struct _AgsDevoutClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_devout_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_devout_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_devout_new</NAME>
<RETURNS>AgsDevout * </RETURNS>
GObject *application_context 
</FUNCTION>
<STRUCT>
<NAME>AgsDevoutPlayDomain</NAME>
</STRUCT>
<MACRO>
<NAME>AGS_TYPE_TIMESTAMP</NAME>
#define AGS_TYPE_TIMESTAMP                (ags_timestamp_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP</NAME>
#define AGS_TIMESTAMP(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TIMESTAMP, AgsTimestamp))
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_CLASS</NAME>
#define AGS_TIMESTAMP_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_TIMESTAMP, AgsTimestampClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_TIMESTAMP</NAME>
#define AGS_IS_TIMESTAMP(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_TIMESTAMP))
</MACRO>
<MACRO>
<NAME>AGS_IS_TIMESTAMP_CLASS</NAME>
#define AGS_IS_TIMESTAMP_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_TIMESTAMP))
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_GET_CLASS</NAME>
#define AGS_TIMESTAMP_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_TIMESTAMP, AgsTimestampClass))
</MACRO>
<ENUM>
<NAME>AgsTimestampFlags</NAME>
typedef enum{
  AGS_TIMESTAMP_UNIX      = 1,
  AGS_TIMESTAMP_OUTDATED  = 1 << 1,
}AgsTimestampFlags;
</ENUM>
<STRUCT>
<NAME>AgsTimestamp</NAME>
struct _AgsTimestamp
{
  GObject object;

  guint flags;
  
  union{
    struct _unix{
      time_t time_val;
    }unix_time;
  }timer;

  guint delay;
  guint attack;
};
</STRUCT>
<STRUCT>
<NAME>AgsTimestampClass</NAME>
struct _AgsTimestampClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_timestamp_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_timestamp_new</NAME>
<RETURNS>AgsTimestamp * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL</NAME>
#define AGS_TYPE_RECALL                (ags_recall_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL</NAME>
#define AGS_RECALL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL, AgsRecall))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CLASS</NAME>
#define AGS_RECALL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL, AgsRecallClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL</NAME>
#define AGS_IS_RECALL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_RECALL))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_CLASS</NAME>
#define AGS_IS_RECALL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_RECALL))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_GET_CLASS</NAME>
#define AGS_RECALL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_RECALL, AgsRecallClass))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_HANDLER</NAME>
#define AGS_RECALL_HANDLER(handler)    ((AgsRecallHandler *)(handler))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_DEFAULT_VERSION</NAME>
#define AGS_RECALL_DEFAULT_VERSION "0.4.2\0"
</MACRO>
<MACRO>
<NAME>AGS_RECALL_DEFAULT_BUILD_ID</NAME>
#define AGS_RECALL_DEFAULT_BUILD_ID "CEST 02-10-2014 19:36\0"
</MACRO>
<ENUM>
<NAME>AgsRecallFlags</NAME>
typedef enum{
  AGS_RECALL_CONNECTED             = 1,
  AGS_RECALL_RUN_INITIALIZED       = 1 <<  1, //TODO:JK: rename to AGS_RECALL_RUN_CONNECTED
  AGS_RECALL_TEMPLATE              = 1 <<  2,
  AGS_RECALL_PLAYBACK              = 1 <<  3,
  AGS_RECALL_SEQUENCER             = 1 <<  4,
  AGS_RECALL_NOTATION              = 1 <<  5,
  AGS_RECALL_DEFAULT_TEMPLATE      = 1 <<  6,
  //TODO:JK: remove because it's useless
  AGS_RECALL_DYNAMIC_CONNECTED     = 1 <<  7,
  AGS_RECALL_INPUT_ORIENTATED      = 1 <<  8,
  AGS_RECALL_OUTPUT_ORIENTATED     = 1 <<  9,
  AGS_RECALL_PERSISTENT            = 1 << 10,
  AGS_RECALL_INITIAL_RUN           = 1 << 11,
  AGS_RECALL_TERMINATING           = 1 << 12,
  AGS_RECALL_DONE                  = 1 << 13,
  AGS_RECALL_REMOVE                = 1 << 14,
  AGS_RECALL_HIDE                  = 1 << 15,
  AGS_RECALL_PROPAGATE_DONE        = 1 << 16, // see ags_recall_real_remove
  AGS_RECALL_PERSISTENT_PLAYBACK   = 1 << 17,
  AGS_RECALL_PERSISTENT_SEQUENCER  = 1 << 18,
  AGS_RECALL_PERSISTENT_NOTATION   = 1 << 19,
  AGS_RECALL_SKIP_DEPENDENCIES     = 1 << 20,
  AGS_RECALL_BULK_MODE             = 1 << 21,
}AgsRecallFlags;
</ENUM>
<ENUM>
<NAME>AgsRecallNotifyDependencyMode</NAME>
typedef enum{
  AGS_RECALL_NOTIFY_RUN,
  AGS_RECALL_NOTIFY_AUDIO,
  AGS_RECALL_NOTIFY_AUDIO_RUN,
  AGS_RECALL_NOTIFY_CHANNEL,
  AGS_RECALL_NOTIFY_CHANNEL_RUN,
  AGS_RECALL_NOTIFY_RECALL,
}AgsRecallNotifyDependencyMode;
</ENUM>
<STRUCT>
<NAME>AgsRecall</NAME>
struct _AgsRecall
{
  GObject object;

  guint flags;

  GObject *soundcard;
  GObject *container; // see AgsRecallContainer

  gchar *version;
  gchar *build_id;

  gchar *effect;
  gchar *name;

  gchar *xml_type;

  GList *dependencies;

  AgsRecallID *recall_id;

  AgsRecall *parent;
  GList *children;

  GType child_type;
  GParameter *child_parameters;
  guint n_params;

  GList *port;
  
  GList *handlers;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallClass</NAME>
struct _AgsRecallClass
{
  GObjectClass object;

  void (*resolve_dependencies)(AgsRecall *recall);

  void (*run_init_pre)(AgsRecall *recall);
  void (*run_init_inter)(AgsRecall *recall);
  void (*run_init_post)(AgsRecall *recall);

  void (*run_pre)(AgsRecall *recall);
  void (*run_inter)(AgsRecall *recall);
  void (*run_post)(AgsRecall *recall);

  void (*stop_persistent)(AgsRecall *recall);
  void (*done)(AgsRecall *recall);

  void (*cancel)(AgsRecall *recall);
  void (*remove)(AgsRecall *recall);

  AgsRecall* (*duplicate)(AgsRecall *recall,
			  AgsRecallID *recall_id,
			  guint *n_params, GParameter *params); // if a sequencer is linked with a sequencer the AgsRecall's with the flag AGS_RECALL_SOURCE must be duplicated

  void (*notify_dependency)(AgsRecall *recall, guint dependency, gboolean increase);

  void (*child_added)(AgsRecall *recall, AgsRecall *child);
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallHandler</NAME>
struct _AgsRecallHandler
{
  const gchar *signal_name;
  GCallback callback;
  GObject *data;
  gulong handler;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_set_flags</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, guint flags 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_resolve_dependencies</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *reall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_child_added</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *parent, AgsRecall *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_run_init_pre</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_run_init_inter</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_run_init_post</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_run_pre</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_run_inter</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_run_post</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_stop_persistent</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_done</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_cancel</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_remove</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_is_done</NAME>
<RETURNS>gboolean  </RETURNS>
GList *recalls, GObject *recycling_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_duplicate</NAME>
<RETURNS>AgsRecall * </RETURNS>
AgsRecall *recall, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_set_recall_id</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_set_soundcard_recursive</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, GObject *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_notify_dependency</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, guint dependency, gint count 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_add_dependency</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsRecallDependency *dependency 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_remove_dependency</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsRecall *template 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_get_dependencies</NAME>
<RETURNS>GList * </RETURNS>
AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_remove_child</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsRecall *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_add_child</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsRecall *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_get_children</NAME>
<RETURNS>GList * </RETURNS>
AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_get_by_effect</NAME>
<RETURNS>GList * </RETURNS>
GList *recall, gchar *filename, gchar *effect 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_find_recall_id_with_effect</NAME>
<RETURNS>GList * </RETURNS>
GList *list, AgsRecallID *recall_id, gchar *filename, gchar *effect 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_find_type</NAME>
<RETURNS>GList * </RETURNS>
GList *recall, GType recall_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_find_template</NAME>
<RETURNS>GList * </RETURNS>
GList *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_template_find_type</NAME>
<RETURNS>GList * </RETURNS>
GList *recall, GType recall_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_template_find_all_type</NAME>
<RETURNS>GList * </RETURNS>
GList *recall, ... 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_find_type_with_recycling_context</NAME>
<RETURNS>GList * </RETURNS>
GList *recall, GType recall_type, GObject *recycling_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_find_recycling_context</NAME>
<RETURNS>GList * </RETURNS>
GList *recall, GObject *recycling_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_find_provider</NAME>
<RETURNS>GList * </RETURNS>
GList *recall, GObject *provider 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_template_find_provider</NAME>
<RETURNS>GList * </RETURNS>
GList *recall, GObject *provider 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_find_provider_with_recycling_context</NAME>
<RETURNS>GList * </RETURNS>
GList *recall, GObject *provider, GObject *recycling_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_run_init</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, guint stage 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_handler_alloc</NAME>
<RETURNS>AgsRecallHandler * </RETURNS>
const gchar *signal_name, GCallback callback, GObject *data 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_add_handler</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsRecallHandler *recall_handler 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_remove_handler</NAME>
<RETURNS>void  </RETURNS>
AgsRecall *recall, AgsRecallHandler *recall_handler 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_new</NAME>
<RETURNS>AgsRecall * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PORT</NAME>
#define AGS_TYPE_PORT                (ags_port_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PORT</NAME>
#define AGS_PORT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PORT, AgsPort))
</MACRO>
<MACRO>
<NAME>AGS_PORT_CLASS</NAME>
#define AGS_PORT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PORT, AgsPortClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PORT</NAME>
#define AGS_IS_PORT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PORT))
</MACRO>
<MACRO>
<NAME>AGS_IS_PORT_CLASS</NAME>
#define AGS_IS_PORT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_PORT))
</MACRO>
<MACRO>
<NAME>AGS_PORT_GET_CLASS</NAME>
#define AGS_PORT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PORT, AgsPortClass))
</MACRO>
<STRUCT>
<NAME>AgsPort</NAME>
struct _AgsPort
{
  GObject object;

  gchar *plugin_name;
  gchar *specifier;

  gchar *control_port;

  gboolean port_value_is_pointer;
  GType port_value_type;

  guint port_value_size;
  guint port_value_length;

  pthread_mutex_t mutex;

  union _AgsPortValue{
    gboolean ags_port_boolean;
    gint64 ags_port_int;
    guint64 ags_port_uint;
    gfloat ags_port_float;
    gdouble ags_port_double;
    gboolean *ags_port_boolean_ptr;
    gint64 *ags_port_int_ptr;
    guint64 *ags_port_uint_ptr;
    gfloat *ags_port_float_ptr;
    gdouble *ags_port_double_ptr;
    gpointer ags_port_pointer;
    GObject *ags_port_object;
  }port_value;
};
</STRUCT>
<STRUCT>
<NAME>AgsPortClass</NAME>
struct _AgsPortClass
{
  GObjectClass object;

  void (*safe_read)(AgsPort *port, GValue *value);
  void (*safe_write)(AgsPort *port, GValue *value);

  void (*safe_get_property)(AgsPort *port, gchar *property_name, GValue *value);
  void (*safe_set_property)(AgsPort *port, gchar *property_name, GValue *value);
};
</STRUCT>
<FUNCTION>
<NAME>ags_port_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_port_safe_read</NAME>
<RETURNS>void  </RETURNS>
AgsPort *port, GValue *value 
</FUNCTION>
<FUNCTION>
<NAME>ags_port_safe_write</NAME>
<RETURNS>void  </RETURNS>
AgsPort *port, GValue *value 
</FUNCTION>
<FUNCTION>
<NAME>ags_port_safe_get_property</NAME>
<RETURNS>void  </RETURNS>
AgsPort *port, gchar *property_name, GValue *value 
</FUNCTION>
<FUNCTION>
<NAME>ags_port_safe_set_property</NAME>
<RETURNS>void  </RETURNS>
AgsPort *port, gchar *property_name, GValue *value 
</FUNCTION>
<FUNCTION>
<NAME>ags_port_find_specifier</NAME>
<RETURNS>GList * </RETURNS>
GList *port, gchar *specifier 
</FUNCTION>
<FUNCTION>
<NAME>ags_port_new</NAME>
<RETURNS>AgsPort * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_LADSPA_RUN</NAME>
#define AGS_TYPE_RECALL_LADSPA_RUN                (ags_recall_ladspa_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_LADSPA_RUN</NAME>
#define AGS_RECALL_LADSPA_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_LADSPA_RUN, AgsRecallLadspaRun))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_LADSPA_RUN_CLASS</NAME>
#define AGS_RECALL_LADSPA_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_LADSPA_RUN, AgsRecallLadspaRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_LADSPA_RUN</NAME>
#define AGS_IS_RECALL_LADSPA_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_RECALL_LADSPA_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_LADSPA_RUN_CLASS</NAME>
#define AGS_IS_RECALL_LADSPA_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_RECALL_LADSPA_RUN))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_LADSPA_RUN_GET_CLASS</NAME>
#define AGS_RECALL_LADSPA_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_RECALL_LADSPA_RUN, AgsRecallLadspaRunClass))
</MACRO>
<STRUCT>
<NAME>AgsRecallLadspaRun</NAME>
struct _AgsRecallLadspaRun
{
  AgsRecallAudioSignal recall_audio_signal;

  LADSPA_Handle *ladspa_handle;

  LADSPA_Data *input;
  LADSPA_Data *output;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallLadspaRunClass</NAME>
struct _AgsRecallLadspaRunClass
{
  AgsRecallAudioSignalClass recall_audio_signal;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_ladspa_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_ladspa_run_new</NAME>
<RETURNS>AgsRecallLadspaRun * </RETURNS>
AgsAudioSignal *audio_signal 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_AUDIO_SIGNAL</NAME>
#define AGS_TYPE_RECALL_AUDIO_SIGNAL                (ags_recall_audio_signal_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_AUDIO_SIGNAL</NAME>
#define AGS_RECALL_AUDIO_SIGNAL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_AUDIO_SIGNAL, AgsRecallAudioSignal))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_RECALL_AUDIO_SIGNAL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_AUDIO_SIGNAL, AgsRecallAudioSignalClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_AUDIO_SIGNAL</NAME>
#define AGS_IS_RECALL_AUDIO_SIGNAL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECALL_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_IS_RECALL_AUDIO_SIGNAL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECALL_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_AUDIO_SIGNAL_GET_CLASS</NAME>
#define AGS_RECALL_AUDIO_SIGNAL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_RECALL_AUDIO_SIGNAL, AgsRecallAudioSignalClass))
</MACRO>
<ENUM>
<NAME>AgsRecallAudioSignalFlags</NAME>
typedef enum{
  AGS_RECALL_AUDIO_SIGNAL_INITIAL_RUN      = 1,
}AgsRecallAudioSignalFlags;
</ENUM>
<STRUCT>
<NAME>AgsRecallAudioSignal</NAME>
struct _AgsRecallAudioSignal
{
  AgsRecall recall;

  guint flags;

  guint audio_channel;

  AgsAudioSignal *destination;

  AgsAudioSignal *source;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallAudioSignalClass</NAME>
struct _AgsRecallAudioSignalClass
{
  AgsRecallClass recall;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_audio_signal_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_audio_signal_new</NAME>
<RETURNS>AgsRecallAudioSignal * </RETURNS>
AgsAudioSignal *destination, AgsAudioSignal *source, GObject *soundcard 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_NOTATION</NAME>
#define AGS_TYPE_NOTATION                (ags_notation_get_type())
</MACRO>
<MACRO>
<NAME>AGS_NOTATION</NAME>
#define AGS_NOTATION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_NOTATION, AgsNotation))
</MACRO>
<MACRO>
<NAME>AGS_NOTATION_CLASS</NAME>
#define AGS_NOTATION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_NOTATION, AgsNotationClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_NOTATION</NAME>
#define AGS_IS_NOTATION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_NOTATION))
</MACRO>
<MACRO>
<NAME>AGS_IS_NOTATION_CLASS</NAME>
#define AGS_IS_NOTATION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_NOTATION))
</MACRO>
<MACRO>
<NAME>AGS_NOTATION_GET_CLASS</NAME>
#define AGS_NOTATION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_NOTATION, AgsNotationClass))
</MACRO>
<MACRO>
<NAME>AGS_NOTATION_DEFAULT_BPM</NAME>
#define AGS_NOTATION_DEFAULT_BPM (120.0)
</MACRO>
<MACRO>
<NAME>AGS_NOTATION_TICS_PER_BEAT</NAME>
#define AGS_NOTATION_TICS_PER_BEAT (1.0)
</MACRO>
<MACRO>
<NAME>AGS_NOTATION_MINIMUM_NOTE_LENGTH</NAME>
#define AGS_NOTATION_MINIMUM_NOTE_LENGTH (1.0 / 16.0)
</MACRO>
<MACRO>
<NAME>AGS_NOTATION_MAXIMUM_NOTE_LENGTH</NAME>
#define AGS_NOTATION_MAXIMUM_NOTE_LENGTH (16.0)
</MACRO>
<MACRO>
<NAME>AGS_NOTATION_DEFAULT_LENGTH</NAME>
#define AGS_NOTATION_DEFAULT_LENGTH (65535.0 / AGS_NOTATION_TICS_PER_BEAT - AGS_NOTATION_MAXIMUM_NOTE_LENGTH)
</MACRO>
<MACRO>
<NAME>AGS_NOTATION_DEFAULT_JIFFIE</NAME>
#define AGS_NOTATION_DEFAULT_JIFFIE (60.0 / AGS_NOTATION_DEFAULT_BPM / AGS_NOTATION_TICS_PER_BEAT)
</MACRO>
<MACRO>
<NAME>AGS_NOTATION_DEFAULT_DURATION</NAME>
#define AGS_NOTATION_DEFAULT_DURATION (AGS_NOTATION_DEFAULT_LENGTH * AGS_NOTATION_DEFAULT_JIFFIE * AGS_MICROSECONDS_PER_SECOND)
</MACRO>
<ENUM>
<NAME>AgsNotationFlags</NAME>
typedef enum{
  AGS_NOTATION_STICKY              =  1,
  AGS_NOTATION_INDICATED_LENGTH    =  1 <<  1,
}AgsNotationFlags;
</ENUM>
<STRUCT>
<NAME>AgsNotation</NAME>
struct _AgsNotation
{
  GObject object;

  guint flags;

  GObject *timestamp;

  guint audio_channel;
  GObject *audio;

  gchar *key;
  gdouble base_frequency;

  gdouble tact;
  gdouble bpm;

  gdouble maximum_note_length;

  GList *notes;
  
  gdouble start_loop;
  gdouble end_loop;
  gdouble offset;

  GList *selection;

  GObject *port;

  GList *current_notes;
  GList *next_notes;
};
</STRUCT>
<STRUCT>
<NAME>AgsNotationClass</NAME>
struct _AgsNotationClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_notation_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_find_near_timestamp</NAME>
<RETURNS>GList * </RETURNS>
GList *notation, guint audio_channel, GObject *timestamp 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_add_note</NAME>
<RETURNS>void  </RETURNS>
AgsNotation *notation, AgsNote *note, gboolean use_selection_list 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_remove_note_at_position</NAME>
<RETURNS>gboolean  </RETURNS>
AgsNotation *notation, guint x, guint y 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_get_selection</NAME>
<RETURNS>GList * </RETURNS>
AgsNotation *notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_is_note_selected</NAME>
<RETURNS>gboolean  </RETURNS>
AgsNotation *notation, AgsNote *note 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_find_point</NAME>
<RETURNS>AgsNote * </RETURNS>
AgsNotation *notation, guint x, guint y, gboolean use_selection_list 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_find_region</NAME>
<RETURNS>GList * </RETURNS>
AgsNotation *notation, guint x0, guint y0, guint x1, guint y1, gboolean use_selection_list 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_free_selection</NAME>
<RETURNS>void  </RETURNS>
AgsNotation *notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_add_point_to_selection</NAME>
<RETURNS>void  </RETURNS>
AgsNotation *notation, guint x, guint y, gboolean replace_current_selection 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_remove_point_from_selection</NAME>
<RETURNS>void  </RETURNS>
AgsNotation *notation, guint x, guint y 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_add_region_to_selection</NAME>
<RETURNS>void  </RETURNS>
AgsNotation *notation, guint x0, guint y0, guint x1, guint y1, gboolean replace_current_selection 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_remove_region_from_selection</NAME>
<RETURNS>void  </RETURNS>
AgsNotation *notation, guint x0, guint y0, guint x1, guint y1 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_copy_selection</NAME>
<RETURNS>xmlNodePtr  </RETURNS>
AgsNotation *notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_cut_selection</NAME>
<RETURNS>xmlNodePtr  </RETURNS>
AgsNotation *notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_insert_from_clipboard</NAME>
<RETURNS>void  </RETURNS>
AgsNotation *notation, xmlNodePtr content, gboolean reset_x_offset, guint x_offset, gboolean reset_y_offset, guint y_offset 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_get_current</NAME>
<RETURNS>GList * </RETURNS>
AgsNotation *notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_notation_new</NAME>
<RETURNS>AgsNotation * </RETURNS>
GObject *audio, guint audio_channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_ID</NAME>
#define AGS_TYPE_RECALL_ID                (ags_recall_id_get_type ())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_ID</NAME>
#define AGS_RECALL_ID(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), AGS_TYPE_RECALL_ID, AgsRecallID))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_ID_CLASS</NAME>
#define AGS_RECALL_ID_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST ((class), AGS_TYPE_RECALL_ID, AgsRecallIDClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_ID</NAME>
#define AGS_IS_RECALL_ID(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECALL_ID))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_ID_CLASS</NAME>
#define AGS_IS_RECALL_ID_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECALL_ID))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_ID_GET_CLASS</NAME>
#define AGS_RECALL_ID_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_RECALL_ID, AgsRecallIDClass))
</MACRO>
<ENUM>
<NAME>AgsRecallIDFlags</NAME>
typedef enum{
  AGS_RECALL_ID_PLAYBACK          = 1,
  AGS_RECALL_ID_SEQUENCER         = 1 << 1,
  AGS_RECALL_ID_NOTATION          = 1 << 2,
  AGS_RECALL_ID_DUPLICATE         = 1 << 3,
  AGS_RECALL_ID_RESOLVE           = 1 << 4,
  AGS_RECALL_ID_INIT_PRE          = 1 << 5,
  AGS_RECALL_ID_INIT_INTER        = 1 << 6,
  AGS_RECALL_ID_INIT_POST         = 1 << 7,
  AGS_RECALL_ID_PRE               = 1 << 8,
  AGS_RECALL_ID_INTER             = 1 << 9,
  AGS_RECALL_ID_POST              = 1 << 10,
  AGS_RECALL_ID_CANCEL            = 1 << 11,
}AgsRecallIDFlags;
</ENUM>
<STRUCT>
<NAME>AgsRecallID</NAME>
struct _AgsRecallID
{
  GObject object;
  
  guint flags;

  GObject *recycling;
  AgsRecyclingContext *recycling_context;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallIDClass</NAME>
struct _AgsRecallIDClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_id_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_id_get_run_stage</NAME>
<RETURNS>gboolean  </RETURNS>
AgsRecallID *id, gint stage 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_id_set_run_stage</NAME>
<RETURNS>void  </RETURNS>
AgsRecallID *recall_id, gint stage 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_id_unset_run_stage</NAME>
<RETURNS>void  </RETURNS>
AgsRecallID *recall_id, gint stage 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_id_find_recycling_context</NAME>
<RETURNS>AgsRecallID * </RETURNS>
GList *recall_id_list, AgsRecyclingContext *recycling_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_id_find_parent_recycling_context</NAME>
<RETURNS>AgsRecallID * </RETURNS>
GList *recall_id_list, AgsRecyclingContext *parent_recycling_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_id_add</NAME>
<RETURNS>GList * </RETURNS>
GList *recall_id_list, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_id_new</NAME>
<RETURNS>AgsRecallID * </RETURNS>
AgsRecycling *recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_init_context</NAME>
<RETURNS>void  </RETURNS>
AgsApplicationContext *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_RECYCLING_DUMMY</NAME>
#define AGS_TYPE_RECALL_RECYCLING_DUMMY                (ags_recall_recycling_dummy_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_RECYCLING_DUMMY</NAME>
#define AGS_RECALL_RECYCLING_DUMMY(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_RECYCLING_DUMMY, AgsRecallRecyclingDummy))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_RECYCLING_DUMMY_CLASS</NAME>
#define AGS_RECALL_RECYCLING_DUMMY_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_RECYCLING_DUMMY, AgsRecallRecyclingDummyClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_RECYCLING_DUMMY</NAME>
#define AGS_IS_RECALL_RECYCLING_DUMMY(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECALL_RECYCLING_DUMMY))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_RECYCLING_DUMMY_CLASS</NAME>
#define AGS_IS_RECALL_RECYCLING_DUMMY_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECALL_RECYCLING_DUMMY))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_RECYCLING_DUMMY_GET_CLASS</NAME>
#define AGS_RECALL_RECYCLING_DUMMY_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_RECALL_RECYCLING_DUMMY, AgsRecallRecyclingDummyClass))
</MACRO>
<STRUCT>
<NAME>AgsRecallRecyclingDummy</NAME>
struct _AgsRecallRecyclingDummy
{
  AgsRecallRecycling recall_recycling;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallRecyclingDummyClass</NAME>
struct _AgsRecallRecyclingDummyClass
{
  AgsRecallRecyclingClass recall_recycling;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_recycling_dummy_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_recycling_dummy_new</NAME>
<RETURNS>AgsRecallRecyclingDummy * </RETURNS>
AgsRecycling *recycling, GType child_type 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_LADSPA</NAME>
#define AGS_TYPE_RECALL_LADSPA                (ags_recall_ladspa_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_LADSPA</NAME>
#define AGS_RECALL_LADSPA(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_LADSPA, AgsRecallLadspa))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_LADSPA_CLASS</NAME>
#define AGS_RECALL_LADSPA_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_LADSPA, AgsRecallLadspaClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_LADSPA</NAME>
#define AGS_IS_RECALL_LADSPA(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_RECALL_LADSPA))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_LADSPA_CLASS</NAME>
#define AGS_IS_RECALL_LADSPA_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_RECALL_LADSPA))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_LADSPA_GET_CLASS</NAME>
#define AGS_RECALL_LADSPA_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_RECALL_LADSPA, AgsRecallLadspaClass))
</MACRO>
<STRUCT>
<NAME>AgsRecallLadspa</NAME>
struct _AgsRecallLadspa
{
  AgsRecallChannel recall_channel;

  gchar *filename;
  gchar *effect;
  unsigned long effect_index;

  LADSPA_Descriptor *plugin_descriptor;

  unsigned long *input_port;
  unsigned long input_lines;

  unsigned long *output_port;
  unsigned long output_lines;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallLadspaClass</NAME>
struct _AgsRecallLadspaClass
{
  AgsRecallChannelClass recall_channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_ladspa_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_ladspa_load_ports</NAME>
<RETURNS>GList * </RETURNS>
AgsRecallLadspa *recall_ladspa 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_ladspa_short_to_float</NAME>
<RETURNS>void  </RETURNS>
signed short *buffer, float *destination, guint buffer_size, guint lines 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_ladspa_float_to_short</NAME>
<RETURNS>void  </RETURNS>
float *buffer, signed short *destination, guint buffer_size, guint lines 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_ladspa_find</NAME>
<RETURNS>GList * </RETURNS>
GList *recall, gchar *filename, gchar *effect 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_ladspa_new</NAME>
<RETURNS>AgsRecallLadspa * </RETURNS>
AgsChannel *source, gchar *filename, gchar *effect, unsigned long effect_index 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECYCLING</NAME>
#define AGS_TYPE_RECYCLING                (ags_recycling_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECYCLING</NAME>
#define AGS_RECYCLING(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECYCLING, AgsRecycling))
</MACRO>
<MACRO>
<NAME>AGS_RECYCLING_CLASS</NAME>
#define AGS_RECYCLING_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECYCLING, AgsRecyclingClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECYCLING</NAME>
#define AGS_IS_RECYCLING(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECYCLING_CLASS</NAME>
#define AGS_IS_RECYCLING_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_RECYCLING_GET_CLASS</NAME>
#define AGS_RECYCLING_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_RECYCLING, AgsRecyclingClass))
</MACRO>
<ENUM>
<NAME>AgsRecyclingFlags</NAME>
typedef enum{
  AGS_RECYCLING_MUTED           =  1,
}AgsRecyclingFlags;
</ENUM>
<STRUCT>
<NAME>AgsRecycling</NAME>
struct _AgsRecycling
{
  GObject object;

  guint flags;

  GObject *channel;
  GObject *soundcard;

  AgsRecycling *parent;

  AgsRecycling *next;
  AgsRecycling *prev;

  GList *audio_signal;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecyclingClass</NAME>
struct _AgsRecyclingClass
{
  GObjectClass object;

  void (*add_audio_signal)(AgsRecycling *recycling,
			   AgsAudioSignal *audio_signal);
  void (*remove_audio_signal)(AgsRecycling *recycling,
			      AgsAudioSignal *audio_signal);
};
</STRUCT>
<FUNCTION>
<NAME>ags_recycling_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_set_soundcard</NAME>
<RETURNS>void  </RETURNS>
AgsRecycling *recycling, GObject *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_add_audio_signal</NAME>
<RETURNS>void  </RETURNS>
AgsRecycling *recycling, AgsAudioSignal *audio_signal 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_remove_audio_signal</NAME>
<RETURNS>void  </RETURNS>
AgsRecycling *recycling, AgsAudioSignal *audio_signal 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_create_audio_signal_with_defaults</NAME>
<RETURNS>void  </RETURNS>
AgsRecycling *recycling, AgsAudioSignal *audio_signal, gdouble delay, guint attack 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_create_audio_signal_with_frame_count</NAME>
<RETURNS>void  </RETURNS>
AgsRecycling *recycling, AgsAudioSignal *audio_signal, guint frame_count, gdouble delay, guint attack 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_position</NAME>
<RETURNS>gint  </RETURNS>
AgsRecycling *start_recycling, AgsRecycling *end_region, AgsRecycling *recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_find_next_channel</NAME>
<RETURNS>AgsRecycling * </RETURNS>
AgsRecycling *start_region, AgsRecycling *end_region, GObject *prev_channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_new</NAME>
<RETURNS>AgsRecycling * </RETURNS>
GObject *soundcard 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_ACCELERATION</NAME>
#define AGS_TYPE_ACCELERATION                (ags_acceleration_get_type())
</MACRO>
<MACRO>
<NAME>AGS_ACCELERATION</NAME>
#define AGS_ACCELERATION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_ACCELERATION, AgsAcceleration))
</MACRO>
<MACRO>
<NAME>AGS_ACCELERATION_CLASS</NAME>
#define AGS_ACCELERATION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_ACCELERATION, AgsAccelerationClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_ACCELERATION</NAME>
#define AGS_IS_ACCELERATION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_ACCELERATION))
</MACRO>
<MACRO>
<NAME>AGS_IS_ACCELERATION_CLASS</NAME>
#define AGS_IS_ACCELERATION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_ACCELERATION))
</MACRO>
<MACRO>
<NAME>AGS_ACCELERATION_GET_CLASS</NAME>
#define AGS_ACCELERATION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_ACCELERATION, AgsAccelerationClass))
</MACRO>
<ENUM>
<NAME>AgsAccelerationFlags</NAME>
typedef enum{
  AGS_ACCELERATION_GUI             =  1,
  AGS_ACCELERATION_RUNTIME         =  1 <<  1,
  AGS_ACCELERATION_HUMAN_READABLE  =  1 <<  2,
  AGS_ACCELERATION_DEFAULT_LENGTH  =  1 <<  3,
  AGS_ACCELERATION_IS_SELECTED     =  1 <<  4,
}AgsAccelerationFlags;
</ENUM>
<STRUCT>
<NAME>AgsAcceleration</NAME>
struct _AgsAcceleration
{
  GObject object;

  guint flags;

  // gui format, convert easy to visualization
  guint x;
  guint y;

  gchar *name;
  gdouble frequency;
};
</STRUCT>
<STRUCT>
<NAME>AgsAccelerationClass</NAME>
struct _AgsAccelerationClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_acceleration_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_acceleration_duplicate</NAME>
<RETURNS>AgsAcceleration * </RETURNS>
AgsAcceleration *acceleration 
</FUNCTION>
<FUNCTION>
<NAME>ags_acceleration_new</NAME>
<RETURNS>AgsAcceleration * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LIBAO</NAME>
#define AGS_TYPE_LIBAO                (ags_libao_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LIBAO</NAME>
#define AGS_LIBAO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LIBAO, AgsLibao))
</MACRO>
<MACRO>
<NAME>AGS_LIBAO_CLASS</NAME>
#define AGS_LIBAO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_LIBAO, AgsLibao))
</MACRO>
<MACRO>
<NAME>AGS_IS_LIBAO</NAME>
#define AGS_IS_LIBAO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LIBAO))
</MACRO>
<MACRO>
<NAME>AGS_IS_LIBAO_CLASS</NAME>
#define AGS_IS_LIBAO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LIBAO))
</MACRO>
<MACRO>
<NAME>AGS_LIBAO_GET_CLASS</NAME>
#define AGS_LIBAO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_LIBAO, AgsLibaoClass))
</MACRO>
<MACRO>
<NAME>AGS_LIBAO_PLAY_DOMAIN</NAME>
#define AGS_LIBAO_PLAY_DOMAIN(ptr)    ((AgsLibaoPlayDomain *)(ptr))
</MACRO>
<MACRO>
<NAME>AGS_LIBAO_PLAY</NAME>
#define AGS_LIBAO_PLAY(ptr)           ((AgsLibaoPlay *)(ptr))
</MACRO>
<MACRO>
<NAME>AGS_LIBAO_DEFAULT_SAMPLERATE</NAME>
#define AGS_LIBAO_DEFAULT_SAMPLERATE (44100.0)
</MACRO>
<MACRO>
<NAME>AGS_LIBAO_DEFAULT_BUFFER_SIZE</NAME>
#define AGS_LIBAO_DEFAULT_BUFFER_SIZE (940)
</MACRO>
<MACRO>
<NAME>AGS_LIBAO_DEFAULT_BPM</NAME>
#define AGS_LIBAO_DEFAULT_BPM (120.0)
</MACRO>
<MACRO>
<NAME>AGS_LIBAO_DEFAULT_JIFFIE</NAME>
#define AGS_LIBAO_DEFAULT_JIFFIE ((double) AGS_LIBAO_DEFAULT_SAMPLERATE / (double) AGS_LIBAO_DEFAULT_BUFFER_SIZE)
</MACRO>
<MACRO>
<NAME>AGS_LIBAO_DEFAULT_TACT</NAME>
#define AGS_LIBAO_DEFAULT_TACT (1.0)
</MACRO>
<MACRO>
<NAME>AGS_LIBAO_DEFAULT_TACT_JIFFIE</NAME>
#define AGS_LIBAO_DEFAULT_TACT_JIFFIE (60.0 / AGS_LIBAO_DEFAULT_BPM * AGS_LIBAO_DEFAULT_TACT)
</MACRO>
<MACRO>
<NAME>AGS_LIBAO_DEFAULT_TACTRATE</NAME>
#define AGS_LIBAO_DEFAULT_TACTRATE (1.0 / AGS_LIBAO_DEFAULT_TACT_JIFFIE)
</MACRO>
<MACRO>
<NAME>AGS_LIBAO_DEFAULT_DELAY</NAME>
#define AGS_LIBAO_DEFAULT_DELAY (AGS_LIBAO_DEFAULT_JIFFIE / AGS_LIBAO_DEFAULT_TACTRATE)
</MACRO>
<ENUM>
<NAME>AgsLibaoFlags</NAME>
typedef enum
  {
    AGS_LIBAO_BUFFER0                        = 1,
    AGS_LIBAO_BUFFER1                        = 1 << 1,
    AGS_LIBAO_BUFFER2                        = 1 << 2,
    AGS_LIBAO_BUFFER3                        = 1 << 3,

    AGS_LIBAO_ATTACK_FIRST                   = 1 << 4,

    AGS_LIBAO_PLAY                           = 1 << 5,

    AGS_LIBAO_LIBAO                          = 1 << 6,
    AGS_LIBAO_OSS                            = 1 << 7,
    AGS_LIBAO_ALSA                           = 1 << 8,

    AGS_LIBAO_SHUTDOWN                       = 1 << 9,
    AGS_LIBAO_START_PLAY                     = 1 << 10,

    AGS_LIBAO_NONBLOCKING                    = 1 << 11,

    AGS_LIBAO_TIMING_SET_0                   = 1 << 12,
    AGS_LIBAO_TIMING_SET_1                   = 1 << 13,
  }AgsLibaoFlags;
</ENUM>
<ENUM>
<NAME>AgsLibaoPlayFlags</NAME>
typedef enum
  {
    AGS_LIBAO_PLAY_DONE              = 1,
    AGS_LIBAO_PLAY_REMOVE            = 1 <<  1,
    AGS_LIBAO_PLAY_CHANNEL           = 1 <<  2,
    AGS_LIBAO_PLAY_PAD               = 1 <<  3,
    AGS_LIBAO_PLAY_AUDIO             = 1 <<  4,
    AGS_LIBAO_PLAY_PLAYBACK          = 1 <<  5,
    AGS_LIBAO_PLAY_SEQUENCER         = 1 <<  6,
    AGS_LIBAO_PLAY_NOTATION          = 1 <<  7,
    AGS_LIBAO_PLAY_SUPER_THREADED    = 1 <<  8,
  }AgsLibaoPlayFlags;
</ENUM>
<ENUM>
<NAME>AgsLibaoResolutionMode</NAME>
typedef enum{
  AGS_LIBAO_RESOLUTION_8_BIT    = 8,
  AGS_LIBAO_RESOLUTION_16_BIT   = 16,
  AGS_LIBAO_RESOLUTION_24_BIT   = 24,
  AGS_LIBAO_RESOLUTION_32_BIT   = 32,
  AGS_LIBAO_RESOLUTION_64_BIT   = 64,
}AgsLibaoResolutionMode;
</ENUM>
<MACRO>
<NAME>AGS_LIBAO_ERROR</NAME>
#define AGS_LIBAO_ERROR (ags_libao_error_quark())
</MACRO>
<ENUM>
<NAME>AgsLibaoError</NAME>
typedef enum{
  AGS_LIBAO_ERROR_LOCKED_SOUNDCARD,
}AgsLibaoError;
</ENUM>
<STRUCT>
<NAME>AgsLibao</NAME>
struct _AgsLibao
{
  GObject object;

  guint flags;

  guint dsp_channels;
  guint pcm_channels;
  guint bits;
  guint buffer_size;
  guint frequency; // sample_rate

  signed short** buffer;

  double bpm; // beats per minute

  gdouble *delay; // count of tics within buffer size
  guint *attack; // where currently tic resides in the stream's offset, measured in 1/64 of bpm

  gdouble delay_counter; // next time attack changeing when delay_counter == delay
  guint tic_counter;

  union{
    struct _AgsAO{
      ao_device *device;
      ao_sample_format *format;
      int driver_ao;
    }ao;
  }out;

  GObject *application_context;
  
  GList *audio;
};
</STRUCT>
<STRUCT>
<NAME>AgsLibaoClass</NAME>
struct _AgsLibaoClass
{
  GObjectClass object;

  void (*play_init)(AgsLibao *libao,
		    GError **error);
  void (*play)(AgsLibao *libao,
	       GError **error);
  void (*stop)(AgsLibao *libao);

  void (*tic)(AgsLibao *libao);

  void (*note_offset_changed)(AgsLibao *libao, guint note_offset);
};
</STRUCT>
<STRUCT>
<NAME>AgsLibaoPlayDomain</NAME>
struct _AgsLibaoPlayDomain
{
  GObject *domain;
  
  gboolean playback;
  gboolean sequencer;
  gboolean notation;

  GList *libao_play;
};
</STRUCT>
<STRUCT>
<NAME>AgsLibaoPlay</NAME>
struct _AgsLibaoPlay
{
  guint flags;

  AgsIteratorThread **iterator_thread;

  GObject *source;
  guint audio_channel;

  AgsRecallID *recall_id[3];
};
</STRUCT>
<FUNCTION>
<NAME>ags_libao_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_libao_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_libao_play_domain_alloc</NAME>
<RETURNS>AgsLibaoPlayDomain * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_libao_play_domain_free</NAME>
<RETURNS>void  </RETURNS>
AgsLibaoPlayDomain *libao_play_domain 
</FUNCTION>
<FUNCTION>
<NAME>ags_libao_play_alloc</NAME>
<RETURNS>AgsLibaoPlay * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_libao_play_free</NAME>
<RETURNS>void  </RETURNS>
AgsLibaoPlay *libao_play 
</FUNCTION>
<FUNCTION>
<NAME>ags_libao_list_cards</NAME>
<RETURNS>void  </RETURNS>
GList **card_id, GList **card_name 
</FUNCTION>
<FUNCTION>
<NAME>ags_libao_pcm_info</NAME>
<RETURNS>void  </RETURNS>
char *card_id, guint *channels_min, guint *channels_max, guint *rate_min, guint *rate_max, guint *buffer_size_min, guint *buffer_size_max, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>ags_libao_tic</NAME>
<RETURNS>void  </RETURNS>
AgsLibao *libao 
</FUNCTION>
<FUNCTION>
<NAME>ags_libao_note_offset_changed</NAME>
<RETURNS>void  </RETURNS>
AgsLibao *libao, guint note_offset 
</FUNCTION>
<FUNCTION>
<NAME>ags_libao_new</NAME>
<RETURNS>AgsLibao * </RETURNS>
GObject *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUDIO_APPLICATION_CONTEXT</NAME>
#define AGS_TYPE_AUDIO_APPLICATION_CONTEXT                (ags_audio_application_context_get_type())
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_APPLICATION_CONTEXT</NAME>
#define AGS_AUDIO_APPLICATION_CONTEXT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUDIO_APPLICATION_CONTEXT, AgsAudioApplicationContext))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_APPLICATION_CONTEXT_CLASS</NAME>
#define AGS_AUDIO_APPLICATION_CONTEXT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_AUDIO_APPLICATION_CONTEXT, AgsAudioApplicationContextClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_APPLICATION_CONTEXT</NAME>
#define AGS_IS_AUDIO_APPLICATION_CONTEXT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_AUDIO_APPLICATION_CONTEXT))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_APPLICATION_CONTEXT_CLASS</NAME>
#define AGS_IS_AUDIO_APPLICATION_CONTEXT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_AUDIO_APPLICATION_CONTEXT))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_APPLICATION_CONTEXT_GET_CLASS</NAME>
#define AGS_AUDIO_APPLICATION_CONTEXT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_AUDIO_APPLICATION_CONTEXT, AgsAudioApplicationContextClass))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_RT_PRIORITY</NAME>
#define AGS_AUDIO_RT_PRIORITY (49)
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_BUILD_ID</NAME>
#define AGS_AUDIO_BUILD_ID "Thu Apr  2 13:04:21 GMT 2015\0"
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_DEFAULT_VERSION</NAME>
#define AGS_AUDIO_DEFAULT_VERSION "0.4.3\0"
</MACRO>
<MACRO>
<NAME>AGS_EFFECTS_DEFAULT_VERSION</NAME>
#define AGS_EFFECTS_DEFAULT_VERSION "0.4.2\0"
</MACRO>
<ENUM>
<NAME>AgsAudioApplicationContextFlags</NAME>
typedef enum{
  AGS_AUDIO_APPLICATION_CONTEXT_USE_ALSA      = 1,
}AgsAudioApplicationContextFlags;
</ENUM>
<STRUCT>
<NAME>AgsAudioApplicationContext</NAME>
struct _AgsAudioApplicationContext
{
  AgsApplicationContext appliacation_context;

  guint flags;

  gchar *version;
  gchar *build_id;

  GList *soundcard;
};
</STRUCT>
<STRUCT>
<NAME>AgsAudioApplicationContextClass</NAME>
struct _AgsAudioApplicationContextClass
{
  AgsApplicationContextClass appliacation_context;
};
</STRUCT>
<FUNCTION>
<NAME>ags_audio_application_context_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_application_context_new</NAME>
<RETURNS>AgsAudioApplicationContext * </RETURNS>
GObject *main_loop, AgsConfig *config 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUDIO_SIGNAL</NAME>
#define AGS_TYPE_AUDIO_SIGNAL                (ags_audio_signal_get_type())
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_SIGNAL</NAME>
#define AGS_AUDIO_SIGNAL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUDIO_SIGNAL, AgsAudioSignal))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_AUDIO_SIGNAL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_AUDIO_SIGNAL, AgsAudioSignalClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_SIGNAL</NAME>
#define AGS_IS_AUDIO_SIGNAL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_IS_AUDIO_SIGNAL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_SIGNAL_GET_CLASS</NAME>
#define AGS_AUDIO_SIGNAL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_AUDIO_SIGNAL, AgsAudioSignalClass))
</MACRO>
<ENUM>
<NAME>AgsAudioSignalFlags</NAME>
typedef enum{
  AGS_AUDIO_SIGNAL_TEMPLATE             = 1,
  AGS_AUDIO_SIGNAL_PLAY_DONE            = 1 << 1,
  AGS_AUDIO_SIGNAL_STANDALONE           = 1 << 2,
}AgsAudioSignalFlags;
</ENUM>
<ENUM>
<NAME>AgsAudioSignalFormat</NAME>
typedef enum{
  AGS_AUDIO_SIGNAL_FORMAT_NONINTERLEAVED_RAW   = 1,
  AGS_AUDIO_SIGNAL_FORMAT_8_BIT_PCM            = 1 << 1,
  AGS_AUDIO_SIGNAL_FORMAT_16_BIT_PCM           = 1 << 2,
  AGS_AUDIO_SIGNAL_FORMAT_24_BIT_PCM           = 1 << 3,
  AGS_AUDIO_SIGNAL_FORMAT_32_BIT_PCM           = 1 << 4,
  AGS_AUDIO_SIGNAL_FORMAT_64_BIT_PCM           = 1 << 5,
  AGS_AUDIO_SIGNAL_FORMAT_16_BIT_FLOAT         = 1 << 6,
  AGS_AUDIO_SIGNAL_FORMAT_32_BIT_FLOAT         = 1 << 7,
  AGS_AUDIO_SIGNAL_FORMAT_64_BIT_FLOAT         = 1 << 8,
}AgsAudioSignalFormat;
</ENUM>
<STRUCT>
<NAME>AgsAudioSignal</NAME>
struct _AgsAudioSignal
{
  GObject object;

  guint flags;

  GObject *soundcard;

  GObject *recycling;
  GObject *recall_id; // AGS_TYPE_RECALL_ID to identify the AgsAudioSignal

  guint samplerate;
  guint buffer_size;
  guint format;

  guint length;
  guint first_frame;
  guint last_frame; // the last frame at stream_end
  guint loop_start;
  guint loop_end;

  gdouble delay;
  guint attack;

  guint lock_attack; // deprecated
  
  GList *stream_beginning;
  GList *stream_current;
  GList *stream_end;
};
</STRUCT>
<STRUCT>
<NAME>AgsAudioSignalClass</NAME>
struct _AgsAudioSignalClass
{
  GObjectClass object;

  void (*realloc_buffer_size)(AgsAudioSignal *audio_signal, guint buffer_size);
  void (*morph_samplerate)(AgsAudioSignal *audio_signal, guint samplerate, double k_morph);
};
</STRUCT>
<FUNCTION>
<NAME>ags_audio_signal_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_stream_alloc</NAME>
<RETURNS>signed short * </RETURNS>
guint buffer_size 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_get_length_till_current</NAME>
<RETURNS>guint  </RETURNS>
AgsAudioSignal *audio_signal 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_add_stream</NAME>
<RETURNS>void  </RETURNS>
AgsAudioSignal *audio_signal 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_stream_resize</NAME>
<RETURNS>void  </RETURNS>
AgsAudioSignal *audio_signal, guint length 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_stream_safe_resize</NAME>
<RETURNS>void  </RETURNS>
AgsAudioSignal *audio_signal, guint length 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_realloc_buffer_size</NAME>
<RETURNS>void  </RETURNS>
AgsAudioSignal *audio_signal, guint buffer_size 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_morph_samplerate</NAME>
<RETURNS>void  </RETURNS>
AgsAudioSignal *audio_signal, guint samplerate, double k_morph 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_copy_buffer_to_buffer</NAME>
<RETURNS>void  </RETURNS>
signed short *destination, guint dchannels, signed short *source, guint schannels, guint size 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_copy_buffer_to_double_buffer</NAME>
<RETURNS>void  </RETURNS>
double *destination, guint dchannels, signed short *source, guint schannels, guint size 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_copy_double_buffer_to_buffer</NAME>
<RETURNS>void  </RETURNS>
signed short *destination, guint dchannels, double *source, guint schannels, guint size 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_duplicate_stream</NAME>
<RETURNS>void  </RETURNS>
AgsAudioSignal *audio_signal, AgsAudioSignal *template 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_get_template</NAME>
<RETURNS>AgsAudioSignal * </RETURNS>
GList *audio_signal 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_get_stream_current</NAME>
<RETURNS>GList * </RETURNS>
GList *audio_signal, GObject *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_get_by_recall_id</NAME>
<RETURNS>GList * </RETURNS>
GList *audio_signal, GObject *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_tile</NAME>
<RETURNS>void  </RETURNS>
AgsAudioSignal *audio_signal, AgsAudioSignal *template, guint length 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_scale</NAME>
<RETURNS>void  </RETURNS>
AgsAudioSignal *audio_signal, AgsAudioSignal *template, guint length 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_new</NAME>
<RETURNS>AgsAudioSignal * </RETURNS>
GObject *soundcard, GObject *recycling, GObject *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_signal_new_with_length</NAME>
<RETURNS>AgsAudioSignal * </RETURNS>
GObject *soundcard, GObject *recycling, GObject *recall_id, guint length 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_AUDIO_RUN</NAME>
#define AGS_TYPE_RECALL_AUDIO_RUN                (ags_recall_audio_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_AUDIO_RUN</NAME>
#define AGS_RECALL_AUDIO_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_AUDIO_RUN, AgsRecallAudioRun))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_AUDIO_RUN_CLASS</NAME>
#define AGS_RECALL_AUDIO_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_AUDIO_RUN, AgsRecallAudioRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_AUDIO_RUN</NAME>
#define AGS_IS_RECALL_AUDIO_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECALL_AUDIO_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_AUDIO_RUN_CLASS</NAME>
#define AGS_IS_RECALL_AUDIO_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECALL_AUDIO_RUN))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_AUDIO_RUN_GET_CLASS</NAME>
#define AGS_RECALL_AUDIO_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_RECALL_AUDIO_RUN, AgsRecallAudioRunClass))
</MACRO>
<STRUCT>
<NAME>AgsRecallAudioRun</NAME>
struct _AgsRecallAudioRun
{
  AgsRecall recall;

  AgsRecallAudio *recall_audio;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallAudioRunClass</NAME>
struct _AgsRecallAudioRunClass
{
  AgsRecallClass recall;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_audio_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_audio_run_new</NAME>
<RETURNS>AgsRecallAudioRun * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_CHANNEL_RUN</NAME>
#define AGS_TYPE_RECALL_CHANNEL_RUN                (ags_recall_channel_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CHANNEL_RUN</NAME>
#define AGS_RECALL_CHANNEL_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_CHANNEL_RUN, AgsRecallChannelRun))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CHANNEL_RUN_CLASS</NAME>
#define AGS_RECALL_CHANNEL_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_CHANNEL_RUN, AgsRecallChannelRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_CHANNEL_RUN</NAME>
#define AGS_IS_RECALL_CHANNEL_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECALL_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_CHANNEL_RUN_CLASS</NAME>
#define AGS_IS_RECALL_CHANNEL_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECALL_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CHANNEL_RUN_GET_CLASS</NAME>
#define AGS_RECALL_CHANNEL_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_RECALL_CHANNEL_RUN, AgsRecallChannelRunClass))
</MACRO>
<STRUCT>
<NAME>AgsRecallChannelRun</NAME>
struct _AgsRecallChannelRun
{
  AgsRecall recall;

  guint audio_channel;

  AgsRecallChannel *recall_channel;
  AgsRecallAudioRun *recall_audio_run;

  AgsChannel *destination;
  gulong destination_recycling_changed_handler;
  gulong changed_output_handler;

  AgsChannel *source;
  gulong source_recycling_changed_handler;

  guint run_order;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallChannelRunClass</NAME>
struct _AgsRecallChannelRunClass
{
  AgsRecallClass recall;

  void (*run_order_changed)(AgsRecallChannelRun *recall_channel_run, guint nth_run);
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_channel_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_channel_run_run_order_changed</NAME>
<RETURNS>void  </RETURNS>
AgsRecallChannelRun *recall_channel_run, guint run_order 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_channel_run_get_run_order</NAME>
<RETURNS>guint  </RETURNS>
AgsRecallChannelRun *recall_channel_run 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_channel_run_new</NAME>
<RETURNS>AgsRecallChannelRun * </RETURNS>
 
</FUNCTION>
<ENUM>
<NAME>AgsChannelIterFlags</NAME>
typedef enum{
  AGS_CHANNEL_ITER_LEVEL_STRICT,
  AGS_CHANNEL_ITER_DIRECTION_AXIS_TO_LEAFES,
  AGS_CHANNEL_ITER_DIRECTION_AXIS_TO_ROOT,
  AGS_CHANNEL_ITER_DIRECTION_LEAFES_TO_ROOT,
  AGS_CHANNEL_ITER_DIRECTION_ROOT_TO_LEAFES,
}AgsChannelIterFlags;
</ENUM>
<STRUCT>
<NAME>AgsChannelIter</NAME>
struct _AgsChannelIter
{
  AgsChannel *current_start;

  AgsChannelIter *parent;
  GList *children;
  AgsChannelIter *current_iter;

  AgsChannel *current;
};
</STRUCT>
<FUNCTION>
<NAME>ags_channel_iter_alloc</NAME>
<RETURNS>AgsChannelIter * </RETURNS>
AgsChannel *start 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_iter_free</NAME>
<RETURNS>void  </RETURNS>
AgsChannelIter *iter 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_iter_prev</NAME>
<RETURNS>AgsChannel * </RETURNS>
AgsChannelIter *iter, guint mode 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_iter_next</NAME>
<RETURNS>AgsChannel * </RETURNS>
AgsChannelIter *iter, guint mode 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUTOMATION</NAME>
#define AGS_TYPE_AUTOMATION                (ags_automation_get_type())
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION</NAME>
#define AGS_AUTOMATION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUTOMATION, AgsAutomation))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_CLASS</NAME>
#define AGS_AUTOMATION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_AUTOMATION, AgsAutomationClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUTOMATION</NAME>
#define AGS_IS_AUTOMATION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_AUTOMATION))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUTOMATION_CLASS</NAME>
#define AGS_IS_AUTOMATION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_AUTOMATION))
</MACRO>
<MACRO>
<NAME>AGS_AUTOMATION_GET_CLASS</NAME>
#define AGS_AUTOMATION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS (obj, AGS_TYPE_AUTOMATION, AgsAutomationClass))
</MACRO>
<STRUCT>
<NAME>AgsAutomation</NAME>
struct _AgsAutomation
{
  GObject gobject;

  guint flags;

  GObject *timestamp;

  GObject *audio;
  guint line;
  GType channel_type;
  gchar *control_name;

  guint steps;
  gdouble upper;
  gdouble lower;

  GList *acceleration;

  gdouble start_loop;
  gdouble end_loop;
  gdouble offset;

  GList *selection;

  GObject *port;

  GList *current_accelerations;
  GList *next_accelerations;
};
</STRUCT>
<STRUCT>
<NAME>AgsAutomationClass</NAME>
struct _AgsAutomationClass
{
  GObjectClass gobject;
};
</STRUCT>
<FUNCTION>
<NAME>ags_automation_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_find_near_timestamp</NAME>
<RETURNS>GList * </RETURNS>
GList *automation, guint line, GObject *timestamp 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_add_acceleration</NAME>
<RETURNS>void  </RETURNS>
AgsAutomation *automation, AgsAcceleration *acceleration, gboolean use_selection_list 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_remove_acceleration_at_position</NAME>
<RETURNS>gboolean  </RETURNS>
AgsAutomation *automation, guint x, guint y 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_get_selection</NAME>
<RETURNS>GList * </RETURNS>
AgsAutomation *automation 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_is_acceleration_selected</NAME>
<RETURNS>gboolean  </RETURNS>
AgsAutomation *automation, AgsAcceleration *acceleration 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_find_point</NAME>
<RETURNS>AgsAcceleration * </RETURNS>
AgsAutomation *automation, guint x, guint y, gboolean use_selection_list 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_find_region</NAME>
<RETURNS>GList * </RETURNS>
AgsAutomation *automation, guint x0, guint y0, guint x1, guint y1, gboolean use_selection_list 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_free_selection</NAME>
<RETURNS>void  </RETURNS>
AgsAutomation *automation 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_add_point_to_selection</NAME>
<RETURNS>void  </RETURNS>
AgsAutomation *automation, guint x, guint y, gboolean replace_current_selection 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_remove_point_from_selection</NAME>
<RETURNS>void  </RETURNS>
AgsAutomation *automation, guint x, guint y 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_add_region_to_selection</NAME>
<RETURNS>void  </RETURNS>
AgsAutomation *automation, guint x0, guint y0, guint x1, guint y1, gboolean replace_current_selection 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_remove_region_from_selection</NAME>
<RETURNS>void  </RETURNS>
AgsAutomation *automation, guint x0, guint y0, guint x1, guint y1 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_copy_selection</NAME>
<RETURNS>xmlNodePtr  </RETURNS>
AgsAutomation *automation 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_cut_selection</NAME>
<RETURNS>xmlNodePtr  </RETURNS>
AgsAutomation *automation 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_insert_from_clipboard</NAME>
<RETURNS>void  </RETURNS>
AgsAutomation *automation, xmlNodePtr content, gboolean reset_x_offset, guint x_offset, gboolean reset_y_offset, guint y_offset 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_get_current</NAME>
<RETURNS>GList * </RETURNS>
AgsAutomation *automation 
</FUNCTION>
<FUNCTION>
<NAME>ags_automation_new</NAME>
<RETURNS>AgsAutomation * </RETURNS>
GObject *audio, guint line, GType channel_type, gchar *control_name 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PATTERN</NAME>
#define AGS_TYPE_PATTERN                (ags_pattern_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PATTERN</NAME>
#define AGS_PATTERN(obj)                (G_TYPE_CHECK_INSTANCE_CAST(obj, AGS_TYPE_PATTERN, AgsPattern))
</MACRO>
<MACRO>
<NAME>AGS_PATTERN_CLASS</NAME>
#define AGS_PATTERN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_PATTERN, AgsPatternClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PATTERN</NAME>
#define AGS_IS_PATTERN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PATTERN))
</MACRO>
<MACRO>
<NAME>AGS_IS_PATTERN_CLASS</NAME>
#define AGS_IS_PATTERN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PATTERN))
</MACRO>
<MACRO>
<NAME>AGS_PATTERN_GET_CLASS</NAME>
#define AGS_PATTERN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_PATTERN, AgsPatternClass))
</MACRO>
<STRUCT>
<NAME>AgsPattern</NAME>
struct _AgsPattern
{
  GObject object;

  GObject *timestamp;

  guint dim[3];
  guint ***pattern;

  GObject *port;

  guint i;
  guint j;
  guint bit;
};
</STRUCT>
<STRUCT>
<NAME>AgsPatternClass</NAME>
struct _AgsPatternClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_pattern_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_get_by_timestamp</NAME>
<RETURNS>AgsPattern * </RETURNS>
GList *list, GObject *timestamp 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_set_dim</NAME>
<RETURNS>void  </RETURNS>
AgsPattern *pattern, guint dim0, guint dim1, guint lenght 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_get_bit</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPattern *pattern, guint i, guint j, guint bit 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_toggle_bit</NAME>
<RETURNS>void  </RETURNS>
AgsPattern *pattern, guint i, guint j, guint bit 
</FUNCTION>
<FUNCTION>
<NAME>ags_pattern_new</NAME>
<RETURNS>AgsPattern * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUDIO</NAME>
#define AGS_TYPE_AUDIO                (ags_audio_get_type ())
</MACRO>
<MACRO>
<NAME>AGS_AUDIO</NAME>
#define AGS_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUDIO, AgsAudio))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_CLASS</NAME>
#define AGS_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_AUDIO, AgsAudioClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO</NAME>
#define AGS_IS_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_CLASS</NAME>
#define AGS_IS_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_GET_CLASS</NAME>
#define AGS_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_AUDIO, AgsAudioClass))
</MACRO>
<ENUM>
<NAME>AgsAudioFlags</NAME>
typedef enum{
  AGS_AUDIO_CONNECTED                   = 1,
  AGS_AUDIO_OUTPUT_HAS_RECYCLING        = 1 <<  1,
  AGS_AUDIO_INPUT_HAS_RECYCLING         = 1 <<  2,
  AGS_AUDIO_INPUT_TAKES_FILE            = 1 <<  3,
  AGS_AUDIO_HAS_NOTATION                = 1 <<  4,
  AGS_AUDIO_SYNC                        = 1 <<  5, // can be combined with below
  AGS_AUDIO_ASYNC                       = 1 <<  6,
  AGS_AUDIO_RUNNING                     = 1 <<  7,
  AGS_AUDIO_PLAYING                     = 1 <<  8,
  AGS_AUDIO_NOTATION_DEFAULT            = 1 <<  9,
}AgsAudioFlags;
</ENUM>
<STRUCT>
<NAME>AgsAudio</NAME>
struct _AgsAudio
{
  GObject object;

  guint flags;

  GObject *soundcard;
  guint level;
  
  guint sequence_length;
  guint audio_channels;
  guint frequence;

  guint output_pads;
  guint output_lines;

  guint input_pads;
  guint input_lines;

  AgsChannel *output;
  AgsChannel *input;

  GObject *playback_domain;

  GList *notation;
  GList *automation;
  
  GList *recall_id;
  GList *recycling_context;

  GList *container;
  GList *recall;
  GList *play;

  GList *recall_remove; //TODO:JK: verify deprecation
  GList *play_remove; //TODO:JK: verify deprecation

  GObject *machine_widget;
};
</STRUCT>
<STRUCT>
<NAME>AgsAudioClass</NAME>
struct _AgsAudioClass
{
  GObjectClass object;

  void (*set_audio_channels)(AgsAudio *audio,
			     guint audio_channels, guint audio_channels_old);
  void (*set_pads)(AgsAudio *audio,
		   GType type,
		   guint pads, guint pads_old);

  AgsRecallID* (*init_run)(AgsAudio *audio);
  void (*tact)(AgsAudio *audio, AgsRecallID *recall_id);
  void (*done)(AgsAudio *audio, AgsRecallID *recall_id);
};
</STRUCT>
<FUNCTION>
<NAME>ags_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_set_flags</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, guint flags 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_unset_flags</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, guint flags 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_set_audio_channels</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, guint audio_channels 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_set_pads</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GType type, guint pads 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_init_run</NAME>
<RETURNS>AgsRecallID * </RETURNS>
AgsAudio *audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_tact</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_done</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_set_sequence_length</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, guint sequence_length 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_set_soundcard</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *soundcard 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_add_notation</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_remove_notation</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_add_automation</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *automation 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_remove_automation</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *automation 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_add_recall_id</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_remove_recall_id</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_add_recycling_context</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *recycling_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_remove_recycling_context</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *recycling_context 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_add_recall_container</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *recall_container 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_remove_recall_container</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *recall_container 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_add_recall</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *recall, gboolean play 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_remove_recall</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GObject *recall, gboolean play 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_recall_change_state</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, gboolean enable 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_duplicate_recall</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_init_recall</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, gint stage, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_resolve_recall</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_is_playing</NAME>
<RETURNS>gboolean  </RETURNS>
AgsAudio *audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_play</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id, gint stage 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_recursive_play_init</NAME>
<RETURNS>GList * </RETURNS>
AgsAudio *audio, gboolean playback, gboolean sequencer, gboolean notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_cancel</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_remove</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_open_files</NAME>
<RETURNS>void  </RETURNS>
AgsAudio *audio, GSList *filenames, gboolean overwrite_channels, gboolean create_channels 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_find_port</NAME>
<RETURNS>GList * </RETURNS>
AgsAudio *audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_new</NAME>
<RETURNS>AgsAudio * </RETURNS>
GObject *soundcard 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_NOTE</NAME>
#define AGS_TYPE_NOTE                (ags_note_get_type())
</MACRO>
<MACRO>
<NAME>AGS_NOTE</NAME>
#define AGS_NOTE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_NOTE, AgsNote))
</MACRO>
<MACRO>
<NAME>AGS_NOTE_CLASS</NAME>
#define AGS_NOTE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_NOTE, AgsNoteClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_NOTE</NAME>
#define AGS_IS_NOTE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_NOTE))
</MACRO>
<MACRO>
<NAME>AGS_IS_NOTE_CLASS</NAME>
#define AGS_IS_NOTE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_NOTE))
</MACRO>
<MACRO>
<NAME>AGS_NOTE_GET_CLASS</NAME>
#define AGS_NOTE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_NOTE, AgsNoteClass))
</MACRO>
<ENUM>
<NAME>AgsNoteFlags</NAME>
typedef enum{
  AGS_NOTE_GUI             =  1,
  AGS_NOTE_RUNTIME         =  1 <<  1,
  AGS_NOTE_HUMAN_READABLE  =  1 <<  2,
  AGS_NOTE_DEFAULT_LENGTH  =  1 <<  3,
  AGS_NOTE_IS_SELECTED     =  1 <<  4,
}AgsNoteFlags;
</ENUM>
<STRUCT>
<NAME>AgsNote</NAME>
struct _AgsNote
{
  GObject object;

  guint flags;

  // gui format, convert easy to visualization
  guint x[2];
  guint y;

  gchar *name;
  gdouble frequency;

  gdouble velocity[2];
};
</STRUCT>
<STRUCT>
<NAME>AgsNoteClass</NAME>
struct _AgsNoteClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_note_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_find_prev</NAME>
<RETURNS>GList * </RETURNS>
GList *note, guint x0, guint y 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_find_next</NAME>
<RETURNS>GList * </RETURNS>
GList *note, guint x0, guint y 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_duplicate</NAME>
<RETURNS>AgsNote * </RETURNS>
AgsNote *note 
</FUNCTION>
<FUNCTION>
<NAME>ags_note_new</NAME>
<RETURNS>AgsNote * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_sin</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, signed short *buffer, guint offset, guint freq, guint phase, guint length, double volume 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_saw</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, signed short *buffer, guint offset, guint freq, guint phase, guint length, double volume 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_triangle</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, signed short *buffer, guint offset, guint freq, guint phase, guint length, double volume 
</FUNCTION>
<FUNCTION>
<NAME>ags_synth_square</NAME>
<RETURNS>void  </RETURNS>
AgsSoundcard *soundcard, signed short *buffer, guint offset, guint freq, guint phase, guint length, double volume 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_DEPENDENCY</NAME>
#define AGS_TYPE_RECALL_DEPENDENCY                (ags_recall_dependency_get_type ())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_DEPENDENCY</NAME>
#define AGS_RECALL_DEPENDENCY(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), AGS_TYPE_RECALL_DEPENDENCY, AgsRecallDependency))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_DEPENDENCY_CLASS</NAME>
#define AGS_RECALL_DEPENDENCY_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST ((class), AGS_TYPE_RECALL_DEPENDENCY, AgsRecallDependencyClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_DEPENDENCY</NAME>
#define AGS_IS_RECALL_DEPENDENCY(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECALL_DEPENDENCY))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_DEPENDENCY_CLASS</NAME>
#define AGS_IS_RECALL_DEPENDENCY_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECALL_DEPENDENCY))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_DEPENDENCY_GET_CLASS</NAME>
#define AGS_RECALL_DEPENDENCY_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_RECALL_DEPENDENCY, AgsRecallDependencyClass))
</MACRO>
<STRUCT>
<NAME>AgsRecallDependency</NAME>
struct _AgsRecallDependency
{
  GObject object;

  GObject *dependency;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallDependencyClass</NAME>
struct _AgsRecallDependencyClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_dependency_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_dependency_find_dependency</NAME>
<RETURNS>GList * </RETURNS>
GList *recall_dependencies, GObject *dependency 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_dependency_find_dependency_by_provider</NAME>
<RETURNS>GList * </RETURNS>
GList *recall_dependencies, GObject *provider 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_dependency_resolve</NAME>
<RETURNS>GObject * </RETURNS>
AgsRecallDependency *recall_dependency, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_dependency_new</NAME>
<RETURNS>AgsRecallDependency * </RETURNS>
GObject *dependency 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAYBACK</NAME>
#define AGS_TYPE_PLAYBACK                (ags_playback_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAYBACK</NAME>
#define AGS_PLAYBACK(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAYBACK, AgsPlayback))
</MACRO>
<MACRO>
<NAME>AGS_PLAYBACK_CLASS</NAME>
#define AGS_PLAYBACK_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_PLAYBACK, AgsPlayback))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAYBACK</NAME>
#define AGS_IS_PLAYBACK(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PLAYBACK))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAYBACK_CLASS</NAME>
#define AGS_IS_PLAYBACK_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PLAYBACK))
</MACRO>
<MACRO>
<NAME>AGS_PLAYBACK_GET_CLASS</NAME>
#define AGS_PLAYBACK_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_PLAYBACK, AgsPlaybackClass))
</MACRO>
<ENUM>
<NAME>AgsPlaybackFlags</NAME>
typedef enum
{
  AGS_PLAYBACK_DONE              = 1,
  AGS_PLAYBACK_REMOVE            = 1 <<  1,
  AGS_PLAYBACK_CHANNEL           = 1 <<  2,
  AGS_PLAYBACK_PAD               = 1 <<  3,
  AGS_PLAYBACK_AUDIO             = 1 <<  4,
  AGS_PLAYBACK_PLAYBACK          = 1 <<  5,
  AGS_PLAYBACK_SEQUENCER         = 1 <<  6,
  AGS_PLAYBACK_NOTATION          = 1 <<  7,
  AGS_PLAYBACK_SUPER_THREADED    = 1 <<  8,
}AgsPlaybackFlags;
</ENUM>
<STRUCT>
<NAME>AgsPlayback</NAME>
struct _AgsPlayback
{
  GObject gobject;
  
  guint flags;

  AgsIteratorThread **iterator_thread;

  GObject *source;
  guint audio_channel;

  AgsRecallID **recall_id;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlaybackClass</NAME>
struct _AgsPlaybackClass
{
  GObjectClass gobject;
};
</STRUCT>
<FUNCTION>
<NAME>ags_playback_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_playback_find_source</NAME>
<RETURNS>AgsPlayback * </RETURNS>
GList *playback, GObject *source 
</FUNCTION>
<FUNCTION>
<NAME>ags_playback_new</NAME>
<RETURNS>AgsPlayback * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_LV2</NAME>
#define AGS_TYPE_RECALL_LV2                (ags_recall_lv2_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_LV2</NAME>
#define AGS_RECALL_LV2(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_LV2, AgsRecallLv2))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_LV2_CLASS</NAME>
#define AGS_RECALL_LV2_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_LV2, AgsRecallLv2Class))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_LV2</NAME>
#define AGS_IS_RECALL_LV2(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_RECALL_LV2))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_LV2_CLASS</NAME>
#define AGS_IS_RECALL_LV2_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_RECALL_LV2))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_LV2_GET_CLASS</NAME>
#define AGS_RECALL_LV2_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_RECALL_LV2, AgsRecallLv2Class))
</MACRO>
<STRUCT>
<NAME>AgsRecallLv2</NAME>
struct _AgsRecallLv2
{
  AgsRecallChannel recall_channel;

  AgsTurtle *turtle;
  
  gchar *filename;
  gchar *uri;
  uint32_t index;

  LV2_Descriptor *plugin_descriptor;

  uint32_t *input_port;
  uint32_t input_lines;

  uint32_t *output_port;
  uint32_t output_lines;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallLv2Class</NAME>
struct _AgsRecallLv2Class
{
  AgsRecallChannelClass recall_channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_lv2_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_lv2_load_ports</NAME>
<RETURNS>GList * </RETURNS>
AgsRecallLv2 *recall_lv2 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_lv2_short_to_float</NAME>
<RETURNS>void  </RETURNS>
signed short *buffer, float *destination, guint buffer_size, guint lines 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_lv2_float_to_short</NAME>
<RETURNS>void  </RETURNS>
float *buffer, signed short *destination, guint buffer_size, guint lines 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_ladpsa_find</NAME>
<RETURNS>GList * </RETURNS>
GList *recall, gchar *filename, gchar *uri 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_lv2_new</NAME>
<RETURNS>AgsRecallLv2 * </RETURNS>
AgsChannel *source, AgsTurtle *turtle, gchar *filename, gchar *uri, uint32_t index 
</FUNCTION>
<MACRO>
<NAME>AGS_EFFECT_COPY_STREAM</NAME>
#define AGS_EFFECT_COPY_STREAM "copy_stream"
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_COPY_BUFFER</NAME>
#define AGS_EFFECT_COPY_BUFFER "copy_buffer"
</MACRO>
<MACRO>
<NAME>AGS_EFFECT_DOWN_MIX</NAME>
#define AGS_EFFECT_DOWN_MIX "down_mix"
</MACRO>
<MACRO>
<NAME>AGS_TYPE_RECALL_CHANNEL_RUN_DUMMY</NAME>
#define AGS_TYPE_RECALL_CHANNEL_RUN_DUMMY                (ags_recall_channel_run_dummy_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CHANNEL_RUN_DUMMY</NAME>
#define AGS_RECALL_CHANNEL_RUN_DUMMY(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_CHANNEL_RUN_DUMMY, AgsRecallChannelRunDummy))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CHANNEL_RUN_DUMMY_CLASS</NAME>
#define AGS_RECALL_CHANNEL_RUN_DUMMY_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_CHANNEL_RUN_DUMMY, AgsRecallChannelRunDummyClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_CHANNEL_RUN_DUMMY</NAME>
#define AGS_IS_RECALL_CHANNEL_RUN_DUMMY(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECALL_CHANNEL_RUN_DUMMY))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_CHANNEL_RUN_DUMMY_CLASS</NAME>
#define AGS_IS_RECALL_CHANNEL_RUN_DUMMY_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECALL_CHANNEL_RUN_DUMMY))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CHANNEL_RUN_DUMMY_GET_CLASS</NAME>
#define AGS_RECALL_CHANNEL_RUN_DUMMY_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_RECALL_CHANNEL_RUN_DUMMY, AgsRecallChannelRunDummyClass))
</MACRO>
<STRUCT>
<NAME>AgsRecallChannelRunDummy</NAME>
struct _AgsRecallChannelRunDummy
{
  AgsRecallChannelRun recall_channel_run;

  GType recycling_dummy_child_type;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallChannelRunDummyClass</NAME>
struct _AgsRecallChannelRunDummyClass
{
  AgsRecallChannelRunClass recall_channel_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_channel_run_dummy_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_channel_run_dummy_new</NAME>
<RETURNS>AgsRecallChannelRunDummy * </RETURNS>
AgsChannel *source, GType child_type, GType recycling_dummy_child_type 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECALL_CONTAINER</NAME>
#define AGS_TYPE_RECALL_CONTAINER                (ags_recall_container_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CONTAINER</NAME>
#define AGS_RECALL_CONTAINER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECALL_CONTAINER, AgsRecallContainer))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CONTAINER_CLASS</NAME>
#define AGS_RECALL_CONTAINER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RECALL_CONTAINER, AgsRecallContainerClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_CONTAINER</NAME>
#define AGS_IS_RECALL_CONTAINER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_RECALL_CONTAINER))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECALL_CONTAINER_CLASS</NAME>
#define AGS_IS_RECALL_CONTAINER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_RECALL_CONTAINER))
</MACRO>
<MACRO>
<NAME>AGS_RECALL_CONTAINER_GET_CLASS</NAME>
#define AGS_RECALL_CONTAINER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_RECALL_CONTAINER, AgsRecallContainerClass))
</MACRO>
<ENUM>
<NAME>AgsRecallContainerFlags</NAME>
typedef enum{
  AGS_RECALL_CONTAINER_PLAY    =  1,
}AgsRecallContainerFlags;
</ENUM>
<ENUM>
<NAME>AgsRecallContainerFindFlags</NAME>
typedef enum{
  AGS_RECALL_CONTAINER_FIND_TYPE,
  AGS_RECALL_CONTAINER_FIND_TEMPLATE,
  AGS_RECALL_CONTAINER_FIND_RECALL_ID,
}AgsRecallContainerFindFlags;
</ENUM>
<STRUCT>
<NAME>AgsRecallContainer</NAME>
struct _AgsRecallContainer
{
  GObject object;
  
  guint flags;

  GType recall_audio_type;
  AgsRecall *recall_audio;

  GType recall_audio_run_type;
  GList *recall_audio_run;

  GType recall_channel_type;
  GList *recall_channel;

  GType recall_channel_run_type;
  GList *recall_channel_run;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecallContainerClass</NAME>
struct _AgsRecallContainerClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_recall_container_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_container_get_recall_audio</NAME>
<RETURNS>AgsRecall * </RETURNS>
AgsRecallContainer *container 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_container_get_recall_audio_run</NAME>
<RETURNS>GList * </RETURNS>
AgsRecallContainer *container 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_container_get_recall_channel</NAME>
<RETURNS>GList * </RETURNS>
AgsRecallContainer *container 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_container_get_recall_channel_run</NAME>
<RETURNS>GList * </RETURNS>
AgsRecallContainer *container 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_container_find</NAME>
<RETURNS>GList * </RETURNS>
GList *recall_container, GType type, guint find_flags, AgsRecallID *recall_id 
</FUNCTION>
<FUNCTION>
<NAME>ags_recall_container_new</NAME>
<RETURNS>AgsRecallContainer * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TIMESTAMP_FACTORY</NAME>
#define AGS_TYPE_TIMESTAMP_FACTORY                (ags_timestamp_factory_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_FACTORY</NAME>
#define AGS_TIMESTAMP_FACTORY(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TIMESTAMP_FACTORY, AgsTimestampFactory))
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_FACTORY_CLASS</NAME>
#define AGS_TIMESTAMP_FACTORY_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_TIMESTAMP_FACTORY, AgsTimestampFactoryClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_TIMESTAMP_FACTORY</NAME>
#define AGS_IS_TIMESTAMP_FACTORY(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_TIMESTAMP_FACTORY))
</MACRO>
<MACRO>
<NAME>AGS_IS_TIMESTAMP_FACTORY_CLASS</NAME>
#define AGS_IS_TIMESTAMP_FACTORY_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_TIMESTAMP_FACTORY))
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_FACTORY_GET_CLASS</NAME>
#define AGS_TIMESTAMP_FACTORY_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_TIMESTAMP_FACTORY, AgsTimestampFactoryClass))
</MACRO>
<ENUM>
<NAME>AgsTimestampFactoryFlags</NAME>
typedef enum{
  AGS_TIMESTAMP_FACTORY_UNIX      = 1,
}AgsTimestampFactoryFlags;
</ENUM>
<STRUCT>
<NAME>AgsTimestampFactory</NAME>
struct _AgsTimestampFactory
{
  GObject object;

  guint flags;

  GList *timestamp;
};
</STRUCT>
<STRUCT>
<NAME>AgsTimestampFactoryClass</NAME>
struct _AgsTimestampFactoryClass
{
  GObjectClass object;
  
  AgsTimestamp* (*create)(AgsTimestampFactory *timestamp_factory,
			  AgsTimestamp *predecor);
};
</STRUCT>
<FUNCTION>
<NAME>ags_timestamp_factory_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_timestamp_factory_create</NAME>
<RETURNS>AgsTimestamp * </RETURNS>
AgsTimestampFactory *timestamp_factory, AgsTimestamp *predecor 
</FUNCTION>
<FUNCTION>
<NAME>ags_timestamp_factory_get_instance</NAME>
<RETURNS>AgsTimestampFactory * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_timestamp_factory_new</NAME>
<RETURNS>AgsTimestampFactory * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_APPEND_AUDIO</NAME>
#define AGS_TYPE_APPEND_AUDIO                (ags_append_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_APPEND_AUDIO</NAME>
#define AGS_APPEND_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_APPEND_AUDIO, AgsAppendAudio))
</MACRO>
<MACRO>
<NAME>AGS_APPEND_AUDIO_CLASS</NAME>
#define AGS_APPEND_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_APPEND_AUDIO, AgsAppendAudioClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPEND_AUDIO</NAME>
#define AGS_IS_APPEND_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_APPEND_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPEND_AUDIO_CLASS</NAME>
#define AGS_IS_APPEND_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_APPEND_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_APPEND_AUDIO_GET_CLASS</NAME>
#define AGS_APPEND_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_APPEND_AUDIO, AgsAppendAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsAppendAudio</NAME>
struct _AgsAppendAudio
{
  AgsTask task;

  GObject *audio_loop;
  GObject *audio;
};
</STRUCT>
<STRUCT>
<NAME>AgsAppendAudioClass</NAME>
struct _AgsAppendAudioClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_append_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_append_audio_new</NAME>
<RETURNS>AgsAppendAudio * </RETURNS>
GObject *audio_loop, GObject *audio 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_ADD_AUDIO_SIGNAL</NAME>
#define AGS_TYPE_ADD_AUDIO_SIGNAL                (ags_add_audio_signal_get_type())
</MACRO>
<MACRO>
<NAME>AGS_ADD_AUDIO_SIGNAL</NAME>
#define AGS_ADD_AUDIO_SIGNAL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_ADD_AUDIO_SIGNAL, AgsAddAudioSignal))
</MACRO>
<MACRO>
<NAME>AGS_ADD_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_ADD_AUDIO_SIGNAL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_ADD_AUDIO_SIGNAL, AgsAddAudioSignalClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_AUDIO_SIGNAL</NAME>
#define AGS_IS_ADD_AUDIO_SIGNAL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_ADD_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_IS_ADD_AUDIO_SIGNAL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_ADD_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_ADD_AUDIO_SIGNAL_GET_CLASS</NAME>
#define AGS_ADD_AUDIO_SIGNAL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_ADD_AUDIO_SIGNAL, AgsAddAudioSignalClass))
</MACRO>
<STRUCT>
<NAME>AgsAddAudioSignal</NAME>
struct _AgsAddAudioSignal
{
  AgsTask task;

  AgsRecycling *recycling;
  AgsAudioSignal *audio_signal;
  GObject *soundcard;
  AgsRecallID *recall_id;
  guint audio_signal_flags;
};
</STRUCT>
<STRUCT>
<NAME>AgsAddAudioSignalClass</NAME>
struct _AgsAddAudioSignalClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_add_audio_signal_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_add_audio_signal_new</NAME>
<RETURNS>AgsAddAudioSignal * </RETURNS>
AgsRecycling *recycling, AgsAudioSignal *audio_signal, GObject *soundcard, AgsRecallID *recall_id, guint audio_signal_flags 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_INIT_AUDIO</NAME>
#define AGS_TYPE_INIT_AUDIO                (ags_init_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_INIT_AUDIO</NAME>
#define AGS_INIT_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_INIT_AUDIO, AgsInitAudio))
</MACRO>
<MACRO>
<NAME>AGS_INIT_AUDIO_CLASS</NAME>
#define AGS_INIT_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_INIT_AUDIO, AgsInitAudioClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_INIT_AUDIO</NAME>
#define AGS_IS_INIT_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_INIT_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_INIT_AUDIO_CLASS</NAME>
#define AGS_IS_INIT_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_INIT_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_INIT_AUDIO_GET_CLASS</NAME>
#define AGS_INIT_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_INIT_AUDIO, AgsInitAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsInitAudio</NAME>
struct _AgsInitAudio
{
  AgsTask task;

  AgsAudio *audio;
  gboolean playback;
  gboolean sequencer;
  gboolean notation;
};
</STRUCT>
<STRUCT>
<NAME>AgsInitAudioClass</NAME>
struct _AgsInitAudioClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_init_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_init_audio_new</NAME>
<RETURNS>AgsInitAudio * </RETURNS>
AgsAudio *audio, gboolean playback, gboolean sequencer, gboolean notation 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_OPEN_SINGLE_FILE</NAME>
#define AGS_TYPE_OPEN_SINGLE_FILE                (ags_open_single_file_get_type())
</MACRO>
<MACRO>
<NAME>AGS_OPEN_SINGLE_FILE</NAME>
#define AGS_OPEN_SINGLE_FILE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_OPEN_SINGLE_FILE, AgsOpenSingleFile))
</MACRO>
<MACRO>
<NAME>AGS_OPEN_SINGLE_FILE_CLASS</NAME>
#define AGS_OPEN_SINGLE_FILE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_OPEN_SINGLE_FILE, AgsOpenSingleFileClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_OPEN_SINGLE_FILE</NAME>
#define AGS_IS_OPEN_SINGLE_FILE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_OPEN_SINGLE_FILE))
</MACRO>
<MACRO>
<NAME>AGS_IS_OPEN_SINGLE_FILE_CLASS</NAME>
#define AGS_IS_OPEN_SINGLE_FILE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_OPEN_SINGLE_FILE))
</MACRO>
<MACRO>
<NAME>AGS_OPEN_SINGLE_FILE_GET_CLASS</NAME>
#define AGS_OPEN_SINGLE_FILE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_OPEN_SINGLE_FILE, AgsOpenSingleFileClass))
</MACRO>
<STRUCT>
<NAME>AgsOpenSingleFile</NAME>
struct _AgsOpenSingleFile
{
  AgsTask task;

  AgsChannel *channel;
  GObject *soundcard;

  gchar *filename;
  guint start_channel;
  guint audio_channels;
};
</STRUCT>
<STRUCT>
<NAME>AgsOpenSingleFileClass</NAME>
struct _AgsOpenSingleFileClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_open_single_file_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_open_single_file_new</NAME>
<RETURNS>AgsOpenSingleFile * </RETURNS>
AgsChannel *channel, GObject *soundcard, gchar *filename, guint start_channel, guint audio_channels 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_OPEN_FILE</NAME>
#define AGS_TYPE_OPEN_FILE                (ags_open_file_get_type())
</MACRO>
<MACRO>
<NAME>AGS_OPEN_FILE</NAME>
#define AGS_OPEN_FILE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_OPEN_FILE, AgsOpenFile))
</MACRO>
<MACRO>
<NAME>AGS_OPEN_FILE_CLASS</NAME>
#define AGS_OPEN_FILE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_OPEN_FILE, AgsOpenFileClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_OPEN_FILE</NAME>
#define AGS_IS_OPEN_FILE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_OPEN_FILE))
</MACRO>
<MACRO>
<NAME>AGS_IS_OPEN_FILE_CLASS</NAME>
#define AGS_IS_OPEN_FILE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_OPEN_FILE))
</MACRO>
<MACRO>
<NAME>AGS_OPEN_FILE_GET_CLASS</NAME>
#define AGS_OPEN_FILE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_OPEN_FILE, AgsOpenFileClass))
</MACRO>
<STRUCT>
<NAME>AgsOpenFile</NAME>
struct _AgsOpenFile
{
  AgsTask task;

  AgsAudio *audio;

  GSList *filenames;

  gboolean overwrite_channels;
  gboolean create_channels;
};
</STRUCT>
<STRUCT>
<NAME>AgsOpenFileClass</NAME>
struct _AgsOpenFileClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_open_file_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_open_file_new</NAME>
<RETURNS>AgsOpenFile * </RETURNS>
AgsAudio *audio, GSList *filenames, gboolean overwrite_channels, gboolean create_channels 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_APPEND_AUDIO_THREADED</NAME>
#define AGS_TYPE_APPEND_AUDIO_THREADED                (ags_append_audio_threaded_get_type())
</MACRO>
<MACRO>
<NAME>AGS_APPEND_AUDIO_THREADED</NAME>
#define AGS_APPEND_AUDIO_THREADED(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_APPEND_AUDIO_THREADED, AgsAppendAudioThreaded))
</MACRO>
<MACRO>
<NAME>AGS_APPEND_AUDIO_THREADED_CLASS</NAME>
#define AGS_APPEND_AUDIO_THREADED_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_APPEND_AUDIO_THREADED, AgsAppendAudioThreadedClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPEND_AUDIO_THREADED</NAME>
#define AGS_IS_APPEND_AUDIO_THREADED(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_APPEND_AUDIO_THREADED))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPEND_AUDIO_THREADED_CLASS</NAME>
#define AGS_IS_APPEND_AUDIO_THREADED_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_APPEND_AUDIO_THREADED))
</MACRO>
<MACRO>
<NAME>AGS_APPEND_AUDIO_THREADED_GET_CLASS</NAME>
#define AGS_APPEND_AUDIO_THREADED_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_APPEND_AUDIO_THREADED, AgsAppendAudioThreadedClass))
</MACRO>
<STRUCT>
<NAME>AgsAppendAudioThreaded</NAME>
struct _AgsAppendAudioThreaded
{
  AgsTask task;

  GObject *audio_loop;
  AgsPlayback *playback;
};
</STRUCT>
<STRUCT>
<NAME>AgsAppendAudioThreadedClass</NAME>
struct _AgsAppendAudioThreadedClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_append_audio_threaded_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_append_audio_threaded_new</NAME>
<RETURNS>AgsAppendAudioThreaded * </RETURNS>
GObject *audio_loop, AgsPlayback *playback 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUDIO_SET_RECYCLING</NAME>
#define AGS_TYPE_AUDIO_SET_RECYCLING                (ags_audio_set_recycling_get_type())
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_SET_RECYCLING</NAME>
#define AGS_AUDIO_SET_RECYCLING(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUDIO_SET_RECYCLING, AgsAudioSetRecycling))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_SET_RECYCLING_CLASS</NAME>
#define AGS_AUDIO_SET_RECYCLING_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_AUDIO_SET_RECYCLING, AgsAudioSetRecyclingClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_SET_RECYCLING</NAME>
#define AGS_IS_AUDIO_SET_RECYCLING(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_AUDIO_SET_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_SET_RECYCLING_CLASS</NAME>
#define AGS_IS_AUDIO_SET_RECYCLING_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_AUDIO_SET_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_SET_RECYCLING_GET_CLASS</NAME>
#define AGS_AUDIO_SET_RECYCLING_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_AUDIO_SET_RECYCLING, AgsAudioSetRecyclingClass))
</MACRO>
<STRUCT>
<NAME>AgsAudioSetRecycling</NAME>
struct _AgsAudioSetRecycling
{
  AgsTask task;

  AgsAudio *audio;

  GParameter *parameter;
};
</STRUCT>
<STRUCT>
<NAME>AgsAudioSetRecyclingClass</NAME>
struct _AgsAudioSetRecyclingClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_audio_set_recycling_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_set_recycling_new</NAME>
<RETURNS>AgsAudioSetRecycling * </RETURNS>
AgsAudio *audio, GParameter *parameter 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LINK_CHANNEL</NAME>
#define AGS_TYPE_LINK_CHANNEL                (ags_link_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LINK_CHANNEL</NAME>
#define AGS_LINK_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LINK_CHANNEL, AgsLinkChannel))
</MACRO>
<MACRO>
<NAME>AGS_LINK_CHANNEL_CLASS</NAME>
#define AGS_LINK_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LINK_CHANNEL, AgsLinkChannelClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINK_CHANNEL</NAME>
#define AGS_IS_LINK_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_LINK_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_LINK_CHANNEL_CLASS</NAME>
#define AGS_IS_LINK_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_LINK_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_LINK_CHANNEL_GET_CLASS</NAME>
#define AGS_LINK_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_LINK_CHANNEL, AgsLinkChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsLinkChannel</NAME>
struct _AgsLinkChannel
{
  AgsTask task;

  AgsChannel *channel;
  AgsChannel *link;

  GError *error;
};
</STRUCT>
<STRUCT>
<NAME>AgsLinkChannelClass</NAME>
struct _AgsLinkChannelClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_link_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_link_channel_new</NAME>
<RETURNS>AgsLinkChannel * </RETURNS>
AgsChannel *channel, AgsChannel *link 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_INIT_CHANNEL</NAME>
#define AGS_TYPE_INIT_CHANNEL                (ags_init_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_INIT_CHANNEL</NAME>
#define AGS_INIT_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_INIT_CHANNEL, AgsInitChannel))
</MACRO>
<MACRO>
<NAME>AGS_INIT_CHANNEL_CLASS</NAME>
#define AGS_INIT_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_INIT_CHANNEL, AgsInitChannelClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_INIT_CHANNEL</NAME>
#define AGS_IS_INIT_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_INIT_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_INIT_CHANNEL_CLASS</NAME>
#define AGS_IS_INIT_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_INIT_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_INIT_CHANNEL_GET_CLASS</NAME>
#define AGS_INIT_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_INIT_CHANNEL, AgsInitChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsInitChannel</NAME>
struct _AgsInitChannel
{
  AgsTask task;

  AgsChannel *channel;
  gboolean play_pad;

  gboolean playback;
  gboolean sequencer;
  gboolean notation;
};
</STRUCT>
<STRUCT>
<NAME>AgsInitChannelClass</NAME>
struct _AgsInitChannelClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_init_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_init_channel_new</NAME>
<RETURNS>AgsInitChannel * </RETURNS>
AgsChannel *channel, gboolean play_pad, gboolean playback, gboolean sequencer, gboolean notation 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_ADD_REGION_TO_SELECTION</NAME>
#define AGS_TYPE_ADD_REGION_TO_SELECTION                (ags_add_region_to_selection_get_type())
</MACRO>
<MACRO>
<NAME>AGS_ADD_REGION_TO_SELECTION</NAME>
#define AGS_ADD_REGION_TO_SELECTION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_ADD_REGION_TO_SELECTION, AgsAddRegionToSelection))
</MACRO>
<MACRO>
<NAME>AGS_ADD_REGION_TO_SELECTION_CLASS</NAME>
#define AGS_ADD_REGION_TO_SELECTION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_ADD_REGION_TO_SELECTION, AgsAddRegionToSelectionClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_REGION_TO_SELECTION</NAME>
#define AGS_IS_ADD_REGION_TO_SELECTION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_ADD_REGION_TO_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_REGION_TO_SELECTION_CLASS</NAME>
#define AGS_IS_ADD_REGION_TO_SELECTION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_ADD_REGION_TO_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_ADD_REGION_TO_SELECTION_GET_CLASS</NAME>
#define AGS_ADD_REGION_TO_SELECTION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_ADD_REGION_TO_SELECTION, AgsAddRegionToSelectionClass))
</MACRO>
<STRUCT>
<NAME>AgsAddRegionToSelection</NAME>
struct _AgsAddRegionToSelection
{
  AgsTask task;

  AgsNotation *notation;

  guint x0;
  guint y0;
  guint x1;
  guint y1;

  gboolean replace_current_selection;
};
</STRUCT>
<STRUCT>
<NAME>AgsAddRegionToSelectionClass</NAME>
struct _AgsAddRegionToSelectionClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_add_region_to_selection_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_add_region_to_selection_new</NAME>
<RETURNS>AgsAddRegionToSelection * </RETURNS>
AgsNotation *notation, guint x0, guint y0, guint x1, guint y1, gboolean replace_current_selection 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SET_PLAYBACK_FLAGS</NAME>
#define AGS_TYPE_SET_PLAYBACK_FLAGS                (ags_set_playback_flags_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SET_PLAYBACK_FLAGS</NAME>
#define AGS_SET_PLAYBACK_FLAGS(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SET_PLAYBACK_FLAGS, AgsSetPlaybackFlags))
</MACRO>
<MACRO>
<NAME>AGS_SET_PLAYBACK_FLAGS_CLASS</NAME>
#define AGS_SET_PLAYBACK_FLAGS_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SET_PLAYBACK_FLAGS, AgsSetPlaybackFlagsClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SET_PLAYBACK_FLAGS</NAME>
#define AGS_IS_SET_PLAYBACK_FLAGS(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SET_PLAYBACK_FLAGS))
</MACRO>
<MACRO>
<NAME>AGS_IS_SET_PLAYBACK_FLAGS_CLASS</NAME>
#define AGS_IS_SET_PLAYBACK_FLAGS_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SET_PLAYBACK_FLAGS))
</MACRO>
<MACRO>
<NAME>AGS_SET_PLAYBACK_FLAGS_GET_CLASS</NAME>
#define AGS_SET_PLAYBACK_FLAGS_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SET_PLAYBACK_FLAGS, AgsSetPlaybackFlagsClass))
</MACRO>
<STRUCT>
<NAME>AgsSetPlaybackFlags</NAME>
struct _AgsSetPlaybackFlags
{
  AgsTask task;

  AgsPlayback *playback;
  guint playback_flags;
};
</STRUCT>
<STRUCT>
<NAME>AgsSetPlaybackFlagsClass</NAME>
struct _AgsSetPlaybackFlagsClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_set_playback_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_set_playback_flags_new</NAME>
<RETURNS>AgsSetPlaybackFlags * </RETURNS>
AgsPlayback *play, guint playback_flags 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_REMOVE_REGION_FROM_SELECTION</NAME>
#define AGS_TYPE_REMOVE_REGION_FROM_SELECTION                (ags_remove_region_from_selection_get_type())
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_REGION_FROM_SELECTION</NAME>
#define AGS_REMOVE_REGION_FROM_SELECTION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_REMOVE_REGION_FROM_SELECTION, AgsRemoveRegionFromSelection))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_REGION_FROM_SELECTION_CLASS</NAME>
#define AGS_REMOVE_REGION_FROM_SELECTION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_REMOVE_REGION_FROM_SELECTION, AgsRemoveRegionFromSelectionClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_REGION_FROM_SELECTION</NAME>
#define AGS_IS_REMOVE_REGION_FROM_SELECTION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_REMOVE_REGION_FROM_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_REGION_FROM_SELECTION_CLASS</NAME>
#define AGS_IS_REMOVE_REGION_FROM_SELECTION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_REMOVE_REGION_FROM_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_REGION_FROM_SELECTION_GET_CLASS</NAME>
#define AGS_REMOVE_REGION_FROM_SELECTION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_REMOVE_REGION_FROM_SELECTION, AgsRemoveRegionFromSelectionClass))
</MACRO>
<STRUCT>
<NAME>AgsRemoveRegionFromSelection</NAME>
struct _AgsRemoveRegionFromSelection
{
  AgsTask task;

  AgsNotation *notation;

  guint x0;
  guint y0;
  guint x1;
  guint y1;
};
</STRUCT>
<STRUCT>
<NAME>AgsRemoveRegionFromSelectionClass</NAME>
struct _AgsRemoveRegionFromSelectionClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_remove_region_from_selection_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_remove_region_from_selection_new</NAME>
<RETURNS>AgsRemoveRegionFromSelection * </RETURNS>
AgsNotation *notation, guint x0, guint y0, guint x1, guint y1 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SET_OUTPUT_DEVICE</NAME>
#define AGS_TYPE_SET_OUTPUT_DEVICE                (ags_set_output_device_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SET_OUTPUT_DEVICE</NAME>
#define AGS_SET_OUTPUT_DEVICE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SET_OUTPUT_DEVICE, AgsSetOutputDevice))
</MACRO>
<MACRO>
<NAME>AGS_SET_OUTPUT_DEVICE_CLASS</NAME>
#define AGS_SET_OUTPUT_DEVICE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SET_OUTPUT_DEVICE, AgsSetOutputDeviceClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SET_OUTPUT_DEVICE</NAME>
#define AGS_IS_SET_OUTPUT_DEVICE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SET_OUTPUT_DEVICE))
</MACRO>
<MACRO>
<NAME>AGS_IS_SET_OUTPUT_DEVICE_CLASS</NAME>
#define AGS_IS_SET_OUTPUT_DEVICE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SET_OUTPUT_DEVICE))
</MACRO>
<MACRO>
<NAME>AGS_SET_OUTPUT_DEVICE_GET_CLASS</NAME>
#define AGS_SET_OUTPUT_DEVICE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SET_OUTPUT_DEVICE, AgsSetOutputDeviceClass))
</MACRO>
<STRUCT>
<NAME>AgsSetOutputDevice</NAME>
struct _AgsSetOutputDevice
{
  AgsTask task;

  GObject *devout;
  char *card_id;
};
</STRUCT>
<STRUCT>
<NAME>AgsSetOutputDeviceClass</NAME>
struct _AgsSetOutputDeviceClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_set_output_device_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_set_output_device_new</NAME>
<RETURNS>AgsSetOutputDevice * </RETURNS>
GObject *devout, char *card_id 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SET_AUDIO_CHANNELS</NAME>
#define AGS_TYPE_SET_AUDIO_CHANNELS                (ags_set_audio_channels_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SET_AUDIO_CHANNELS</NAME>
#define AGS_SET_AUDIO_CHANNELS(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SET_AUDIO_CHANNELS, AgsSetAudioChannels))
</MACRO>
<MACRO>
<NAME>AGS_SET_AUDIO_CHANNELS_CLASS</NAME>
#define AGS_SET_AUDIO_CHANNELS_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SET_AUDIO_CHANNELS, AgsSetAudioChannelsClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SET_AUDIO_CHANNELS</NAME>
#define AGS_IS_SET_AUDIO_CHANNELS(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SET_AUDIO_CHANNELS))
</MACRO>
<MACRO>
<NAME>AGS_IS_SET_AUDIO_CHANNELS_CLASS</NAME>
#define AGS_IS_SET_AUDIO_CHANNELS_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SET_AUDIO_CHANNELS))
</MACRO>
<MACRO>
<NAME>AGS_SET_AUDIO_CHANNELS_GET_CLASS</NAME>
#define AGS_SET_AUDIO_CHANNELS_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SET_AUDIO_CHANNELS, AgsSetAudioChannelsClass))
</MACRO>
<STRUCT>
<NAME>AgsSetAudioChannels</NAME>
struct _AgsSetAudioChannels
{
  AgsTask task;

  AgsDevout *devout;
  guint audio_channels;
};
</STRUCT>
<STRUCT>
<NAME>AgsSetAudioChannelsClass</NAME>
struct _AgsSetAudioChannelsClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_set_audio_channels_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_set_audio_channels_new</NAME>
<RETURNS>AgsSetAudioChannels * </RETURNS>
AgsDevout *devout, guint audio_channels 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_ADD_RECALL</NAME>
#define AGS_TYPE_ADD_RECALL                (ags_add_recall_get_type())
</MACRO>
<MACRO>
<NAME>AGS_ADD_RECALL</NAME>
#define AGS_ADD_RECALL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_ADD_RECALL, AgsAddRecall))
</MACRO>
<MACRO>
<NAME>AGS_ADD_RECALL_CLASS</NAME>
#define AGS_ADD_RECALL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_ADD_RECALL, AgsAddRecallClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_RECALL</NAME>
#define AGS_IS_ADD_RECALL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_ADD_RECALL))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_RECALL_CLASS</NAME>
#define AGS_IS_ADD_RECALL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_ADD_RECALL))
</MACRO>
<MACRO>
<NAME>AGS_ADD_RECALL_GET_CLASS</NAME>
#define AGS_ADD_RECALL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_ADD_RECALL, AgsAddRecallClass))
</MACRO>
<STRUCT>
<NAME>AgsAddRecall</NAME>
struct _AgsAddRecall
{
  AgsTask task;

  GObject *context;

  AgsRecall *recall;
  gboolean is_play;
};
</STRUCT>
<STRUCT>
<NAME>AgsAddRecallClass</NAME>
struct _AgsAddRecallClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_add_recall_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_add_recall_new</NAME>
<RETURNS>AgsAddRecall * </RETURNS>
GObject *context, AgsRecall *recall, gboolean is_play 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_START_SOUNDCARD</NAME>
#define AGS_TYPE_START_SOUNDCARD                (ags_start_soundcard_get_type())
</MACRO>
<MACRO>
<NAME>AGS_START_SOUNDCARD</NAME>
#define AGS_START_SOUNDCARD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_START_SOUNDCARD, AgsStartSoundcard))
</MACRO>
<MACRO>
<NAME>AGS_START_SOUNDCARD_CLASS</NAME>
#define AGS_START_SOUNDCARD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_START_SOUNDCARD, AgsStartSoundcardClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_START_SOUNDCARD</NAME>
#define AGS_IS_START_SOUNDCARD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_START_SOUNDCARD))
</MACRO>
<MACRO>
<NAME>AGS_IS_START_SOUNDCARD_CLASS</NAME>
#define AGS_IS_START_SOUNDCARD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_START_SOUNDCARD))
</MACRO>
<MACRO>
<NAME>AGS_START_SOUNDCARD_GET_CLASS</NAME>
#define AGS_START_SOUNDCARD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_START_SOUNDCARD, AgsStartSoundcardClass))
</MACRO>
<STRUCT>
<NAME>AgsStartSoundcard</NAME>
struct _AgsStartSoundcard
{
  AgsTask task;

  AgsSoundcard *soundcard;
};
</STRUCT>
<STRUCT>
<NAME>AgsStartSoundcardClass</NAME>
struct _AgsStartSoundcardClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_start_soundcard_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_start_soundcard_new</NAME>
<RETURNS>AgsStartSoundcard * </RETURNS>
GObject *soundcard 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_REMOVE_RECALL_CONTAINER</NAME>
#define AGS_TYPE_REMOVE_RECALL_CONTAINER                (ags_remove_recall_container_get_type())
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_RECALL_CONTAINER</NAME>
#define AGS_REMOVE_RECALL_CONTAINER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_REMOVE_RECALL_CONTAINER, AgsRemoveRecallContainer))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_RECALL_CONTAINER_CLASS</NAME>
#define AGS_REMOVE_RECALL_CONTAINER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_REMOVE_RECALL_CONTAINER, AgsRemoveRecallContainerClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_RECALL_CONTAINER</NAME>
#define AGS_IS_REMOVE_RECALL_CONTAINER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_REMOVE_RECALL_CONTAINER))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_RECALL_CONTAINER_CLASS</NAME>
#define AGS_IS_REMOVE_RECALL_CONTAINER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_REMOVE_RECALL_CONTAINER))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_RECALL_CONTAINER_GET_CLASS</NAME>
#define AGS_REMOVE_RECALL_CONTAINER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_REMOVE_RECALL_CONTAINER, AgsRemoveRecallContainerClass))
</MACRO>
<STRUCT>
<NAME>AgsRemoveRecallContainer</NAME>
struct _AgsRemoveRecallContainer
{
  AgsTask task;

  GObject *audio;

  AgsRecallContainer *recall_container;
};
</STRUCT>
<STRUCT>
<NAME>AgsRemoveRecallContainerClass</NAME>
struct _AgsRemoveRecallContainerClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_remove_recall_container_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_remove_recall_container_new</NAME>
<RETURNS>AgsRemoveRecallContainer * </RETURNS>
GObject *audio, AgsRecallContainer *recall_container 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_ADD_AUDIO</NAME>
#define AGS_TYPE_ADD_AUDIO                (ags_add_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_ADD_AUDIO</NAME>
#define AGS_ADD_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_ADD_AUDIO, AgsAddAudio))
</MACRO>
<MACRO>
<NAME>AGS_ADD_AUDIO_CLASS</NAME>
#define AGS_ADD_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_ADD_AUDIO, AgsAddAudioClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_AUDIO</NAME>
#define AGS_IS_ADD_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_ADD_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_AUDIO_CLASS</NAME>
#define AGS_IS_ADD_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_ADD_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_ADD_AUDIO_GET_CLASS</NAME>
#define AGS_ADD_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_ADD_AUDIO, AgsAddAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsAddAudio</NAME>
struct _AgsAddAudio
{
  AgsTask task;

  GObject *soundcard;
  AgsAudio *audio;
};
</STRUCT>
<STRUCT>
<NAME>AgsAddAudioClass</NAME>
struct _AgsAddAudioClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_add_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_add_audio_new</NAME>
<RETURNS>AgsAddAudio * </RETURNS>
GObject *soundcard, AgsAudio *audio 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_REMOVE_POINT_FROM_SELECTION</NAME>
#define AGS_TYPE_REMOVE_POINT_FROM_SELECTION                (ags_remove_point_from_selection_get_type())
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_POINT_FROM_SELECTION</NAME>
#define AGS_REMOVE_POINT_FROM_SELECTION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_REMOVE_POINT_FROM_SELECTION, AgsRemovePointFromSelection))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_POINT_FROM_SELECTION_CLASS</NAME>
#define AGS_REMOVE_POINT_FROM_SELECTION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_REMOVE_POINT_FROM_SELECTION, AgsRemovePointFromSelectionClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_POINT_FROM_SELECTION</NAME>
#define AGS_IS_REMOVE_POINT_FROM_SELECTION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_REMOVE_POINT_FROM_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_POINT_FROM_SELECTION_CLASS</NAME>
#define AGS_IS_REMOVE_POINT_FROM_SELECTION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_REMOVE_POINT_FROM_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_POINT_FROM_SELECTION_GET_CLASS</NAME>
#define AGS_REMOVE_POINT_FROM_SELECTION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_REMOVE_POINT_FROM_SELECTION, AgsRemovePointFromSelectionClass))
</MACRO>
<STRUCT>
<NAME>AgsRemovePointFromSelection</NAME>
struct _AgsRemovePointFromSelection
{
  AgsTask task;

  AgsNotation *notation;

  guint x;
  guint y;
};
</STRUCT>
<STRUCT>
<NAME>AgsRemovePointFromSelectionClass</NAME>
struct _AgsRemovePointFromSelectionClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_remove_point_from_selection_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_remove_point_from_selection_new</NAME>
<RETURNS>AgsRemovePointFromSelection * </RETURNS>
AgsNotation *notation, guint x, guint y 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_APPEND_CHANNEL</NAME>
#define AGS_TYPE_APPEND_CHANNEL                (ags_append_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_APPEND_CHANNEL</NAME>
#define AGS_APPEND_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_APPEND_CHANNEL, AgsAppendChannel))
</MACRO>
<MACRO>
<NAME>AGS_APPEND_CHANNEL_CLASS</NAME>
#define AGS_APPEND_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_APPEND_CHANNEL, AgsAppendChannelClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPEND_CHANNEL</NAME>
#define AGS_IS_APPEND_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_APPEND_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPEND_CHANNEL_CLASS</NAME>
#define AGS_IS_APPEND_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_APPEND_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_APPEND_CHANNEL_GET_CLASS</NAME>
#define AGS_APPEND_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_APPEND_CHANNEL, AgsAppendChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsAppendChannel</NAME>
struct _AgsAppendChannel
{
  AgsTask task;

  GObject *audio_loop;
  GObject *channel;
};
</STRUCT>
<STRUCT>
<NAME>AgsAppendChannelClass</NAME>
struct _AgsAppendChannelClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_append_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_append_channel_new</NAME>
<RETURNS>AgsAppendChannel * </RETURNS>
GObject *audio_loop, GObject *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_REMOVE_RECALL</NAME>
#define AGS_TYPE_REMOVE_RECALL                (ags_remove_recall_get_type())
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_RECALL</NAME>
#define AGS_REMOVE_RECALL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_REMOVE_RECALL, AgsRemoveRecall))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_RECALL_CLASS</NAME>
#define AGS_REMOVE_RECALL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_REMOVE_RECALL, AgsRemoveRecallClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_RECALL</NAME>
#define AGS_IS_REMOVE_RECALL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_REMOVE_RECALL))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_RECALL_CLASS</NAME>
#define AGS_IS_REMOVE_RECALL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_REMOVE_RECALL))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_RECALL_GET_CLASS</NAME>
#define AGS_REMOVE_RECALL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_REMOVE_RECALL, AgsRemoveRecallClass))
</MACRO>
<STRUCT>
<NAME>AgsRemoveRecall</NAME>
struct _AgsRemoveRecall
{
  AgsTask task;

  GObject *context;

  AgsRecall *recall;
  gboolean is_play;
  gboolean remove_all;
};
</STRUCT>
<STRUCT>
<NAME>AgsRemoveRecallClass</NAME>
struct _AgsRemoveRecallClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_remove_recall_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_remove_recall_new</NAME>
<RETURNS>AgsRemoveRecall * </RETURNS>
GObject *context, AgsRecall *recall, gboolean is_play, gboolean remove_all 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SET_BUFFER_SIZE</NAME>
#define AGS_TYPE_SET_BUFFER_SIZE                (ags_set_buffer_size_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SET_BUFFER_SIZE</NAME>
#define AGS_SET_BUFFER_SIZE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SET_BUFFER_SIZE, AgsSetBufferSize))
</MACRO>
<MACRO>
<NAME>AGS_SET_BUFFER_SIZE_CLASS</NAME>
#define AGS_SET_BUFFER_SIZE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SET_BUFFER_SIZE, AgsSetBufferSizeClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SET_BUFFER_SIZE</NAME>
#define AGS_IS_SET_BUFFER_SIZE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SET_BUFFER_SIZE))
</MACRO>
<MACRO>
<NAME>AGS_IS_SET_BUFFER_SIZE_CLASS</NAME>
#define AGS_IS_SET_BUFFER_SIZE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SET_BUFFER_SIZE))
</MACRO>
<MACRO>
<NAME>AGS_SET_BUFFER_SIZE_GET_CLASS</NAME>
#define AGS_SET_BUFFER_SIZE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SET_BUFFER_SIZE, AgsSetBufferSizeClass))
</MACRO>
<STRUCT>
<NAME>AgsSetBufferSize</NAME>
struct _AgsSetBufferSize
{
  AgsTask task;

  GObject *gobject;
  guint buffer_size;
};
</STRUCT>
<STRUCT>
<NAME>AgsSetBufferSizeClass</NAME>
struct _AgsSetBufferSizeClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_set_buffer_size_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_set_buffer_size_new</NAME>
<RETURNS>AgsSetBufferSize * </RETURNS>
GObject *gobject, guint buffer_size 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_ADD_NOTE</NAME>
#define AGS_TYPE_ADD_NOTE                (ags_add_note_get_type())
</MACRO>
<MACRO>
<NAME>AGS_ADD_NOTE</NAME>
#define AGS_ADD_NOTE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_ADD_NOTE, AgsAddNote))
</MACRO>
<MACRO>
<NAME>AGS_ADD_NOTE_CLASS</NAME>
#define AGS_ADD_NOTE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_ADD_NOTE, AgsAddNoteClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_NOTE</NAME>
#define AGS_IS_ADD_NOTE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_ADD_NOTE))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_NOTE_CLASS</NAME>
#define AGS_IS_ADD_NOTE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_ADD_NOTE))
</MACRO>
<MACRO>
<NAME>AGS_ADD_NOTE_GET_CLASS</NAME>
#define AGS_ADD_NOTE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_ADD_NOTE, AgsAddNoteClass))
</MACRO>
<STRUCT>
<NAME>AgsAddNote</NAME>
struct _AgsAddNote
{
  AgsTask task;

  AgsNotation *notation;

  AgsNote *note;
  gboolean use_selection_list;
};
</STRUCT>
<STRUCT>
<NAME>AgsAddNoteClass</NAME>
struct _AgsAddNoteClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_add_note_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_add_note_new</NAME>
<RETURNS>AgsAddNote * </RETURNS>
AgsNotation *notation, AgsNote *note, gboolean use_selection_list 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_REMOVE_AUDIO</NAME>
#define AGS_TYPE_REMOVE_AUDIO                (ags_remove_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_AUDIO</NAME>
#define AGS_REMOVE_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_REMOVE_AUDIO, AgsRemoveAudio))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_AUDIO_CLASS</NAME>
#define AGS_REMOVE_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_REMOVE_AUDIO, AgsRemoveAudioClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_AUDIO</NAME>
#define AGS_IS_REMOVE_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_REMOVE_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_AUDIO_CLASS</NAME>
#define AGS_IS_REMOVE_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_REMOVE_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_AUDIO_GET_CLASS</NAME>
#define AGS_REMOVE_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_REMOVE_AUDIO, AgsRemoveAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsRemoveAudio</NAME>
struct _AgsRemoveAudio
{
  AgsTask task;

  GObject *soundcard;
  AgsAudio *audio;
};
</STRUCT>
<STRUCT>
<NAME>AgsRemoveAudioClass</NAME>
struct _AgsRemoveAudioClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_remove_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_remove_audio_new</NAME>
<RETURNS>AgsRemoveAudio * </RETURNS>
GObject *soundcard, AgsAudio *audio 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_ADD_POINT_TO_SELECTION</NAME>
#define AGS_TYPE_ADD_POINT_TO_SELECTION                (ags_add_point_to_selection_get_type())
</MACRO>
<MACRO>
<NAME>AGS_ADD_POINT_TO_SELECTION</NAME>
#define AGS_ADD_POINT_TO_SELECTION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_ADD_POINT_TO_SELECTION, AgsAddPointToSelection))
</MACRO>
<MACRO>
<NAME>AGS_ADD_POINT_TO_SELECTION_CLASS</NAME>
#define AGS_ADD_POINT_TO_SELECTION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_ADD_POINT_TO_SELECTION, AgsAddPointToSelectionClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_POINT_TO_SELECTION</NAME>
#define AGS_IS_ADD_POINT_TO_SELECTION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_ADD_POINT_TO_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_POINT_TO_SELECTION_CLASS</NAME>
#define AGS_IS_ADD_POINT_TO_SELECTION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_ADD_POINT_TO_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_ADD_POINT_TO_SELECTION_GET_CLASS</NAME>
#define AGS_ADD_POINT_TO_SELECTION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_ADD_POINT_TO_SELECTION, AgsAddPointToSelectionClass))
</MACRO>
<STRUCT>
<NAME>AgsAddPointToSelection</NAME>
struct _AgsAddPointToSelection
{
  AgsTask task;

  AgsNotation *notation;

  guint x;
  guint y;

  gboolean replace_current_selection;
};
</STRUCT>
<STRUCT>
<NAME>AgsAddPointToSelectionClass</NAME>
struct _AgsAddPointToSelectionClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_add_point_to_selection_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_add_point_to_selection_new</NAME>
<RETURNS>AgsAddPointToSelection * </RETURNS>
AgsNotation *notation, guint x, guint y, gboolean replace_current_selection 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_EXPORT_OUTPUT</NAME>
#define AGS_TYPE_EXPORT_OUTPUT                (ags_export_output_get_type())
</MACRO>
<MACRO>
<NAME>AGS_EXPORT_OUTPUT</NAME>
#define AGS_EXPORT_OUTPUT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_EXPORT_OUTPUT, AgsExportOutput))
</MACRO>
<MACRO>
<NAME>AGS_EXPORT_OUTPUT_CLASS</NAME>
#define AGS_EXPORT_OUTPUT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_EXPORT_OUTPUT, AgsExportOutputClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_EXPORT_OUTPUT</NAME>
#define AGS_IS_EXPORT_OUTPUT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_EXPORT_OUTPUT))
</MACRO>
<MACRO>
<NAME>AGS_IS_EXPORT_OUTPUT_CLASS</NAME>
#define AGS_IS_EXPORT_OUTPUT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_EXPORT_OUTPUT))
</MACRO>
<MACRO>
<NAME>AGS_EXPORT_OUTPUT_GET_CLASS</NAME>
#define AGS_EXPORT_OUTPUT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_EXPORT_OUTPUT, AgsExportOutputClass))
</MACRO>
<STRUCT>
<NAME>AgsExportOutput</NAME>
struct _AgsExportOutput
{
  AgsTask task;

  AgsExportThread *export_thread;
  GObject *soundcard;
  gchar *filename;
  guint tic;
  gboolean live_performance;
};
</STRUCT>
<STRUCT>
<NAME>AgsExportOutputClass</NAME>
struct _AgsExportOutputClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_export_output_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_export_output_new</NAME>
<RETURNS>AgsExportOutput * </RETURNS>
AgsExportThread *export_thread, GObject *soundcard, gchar *filename, guint tic, gboolean live_performance 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CANCEL_AUDIO</NAME>
#define AGS_TYPE_CANCEL_AUDIO                (ags_cancel_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_CANCEL_AUDIO</NAME>
#define AGS_CANCEL_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CANCEL_AUDIO, AgsCancelAudio))
</MACRO>
<MACRO>
<NAME>AGS_CANCEL_AUDIO_CLASS</NAME>
#define AGS_CANCEL_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_CANCEL_AUDIO, AgsCancelAudioClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_CANCEL_AUDIO</NAME>
#define AGS_IS_CANCEL_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_CANCEL_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_CANCEL_AUDIO_CLASS</NAME>
#define AGS_IS_CANCEL_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_CANCEL_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_CANCEL_AUDIO_GET_CLASS</NAME>
#define AGS_CANCEL_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_CANCEL_AUDIO, AgsCancelAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsCancelAudio</NAME>
struct _AgsCancelAudio
{
  AgsTask task;

  AgsAudio *audio;

  gboolean playback;
  gboolean sequencer;
  gboolean notation;
};
</STRUCT>
<STRUCT>
<NAME>AgsCancelAudioClass</NAME>
struct _AgsCancelAudioClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_cancel_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_cancel_audio_new</NAME>
<RETURNS>AgsCancelAudio * </RETURNS>
AgsAudio *audio, gboolean playback, gboolean sequencer, gboolean notation 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CANCEL_CHANNEL</NAME>
#define AGS_TYPE_CANCEL_CHANNEL                (ags_cancel_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_CANCEL_CHANNEL</NAME>
#define AGS_CANCEL_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CANCEL_CHANNEL, AgsCancelChannel))
</MACRO>
<MACRO>
<NAME>AGS_CANCEL_CHANNEL_CLASS</NAME>
#define AGS_CANCEL_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_CANCEL_CHANNEL, AgsCancelChannelClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_CANCEL_CHANNEL</NAME>
#define AGS_IS_CANCEL_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_CANCEL_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_CANCEL_CHANNEL_CLASS</NAME>
#define AGS_IS_CANCEL_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_CANCEL_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_CANCEL_CHANNEL_GET_CLASS</NAME>
#define AGS_CANCEL_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_CANCEL_CHANNEL, AgsCancelChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsCancelChannel</NAME>
struct _AgsCancelChannel
{
  AgsTask task;

  AgsChannel *channel;
  AgsRecallID *recall_id;

  GObject *playback;
};
</STRUCT>
<STRUCT>
<NAME>AgsCancelChannelClass</NAME>
struct _AgsCancelChannelClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_cancel_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_cancel_channel_new</NAME>
<RETURNS>AgsCancelChannel * </RETURNS>
AgsChannel *channel, AgsRecallID *recall_id, GObject *playback 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TOGGLE_PATTERN_BIT</NAME>
#define AGS_TYPE_TOGGLE_PATTERN_BIT                (ags_toggle_pattern_bit_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TOGGLE_PATTERN_BIT</NAME>
#define AGS_TOGGLE_PATTERN_BIT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TOGGLE_PATTERN_BIT, AgsTogglePatternBit))
</MACRO>
<MACRO>
<NAME>AGS_TOGGLE_PATTERN_BIT_CLASS</NAME>
#define AGS_TOGGLE_PATTERN_BIT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_TOGGLE_PATTERN_BIT, AgsTogglePatternBitClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_TOGGLE_PATTERN_BIT</NAME>
#define AGS_IS_TOGGLE_PATTERN_BIT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_TOGGLE_PATTERN_BIT))
</MACRO>
<MACRO>
<NAME>AGS_IS_TOGGLE_PATTERN_BIT_CLASS</NAME>
#define AGS_IS_TOGGLE_PATTERN_BIT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_TOGGLE_PATTERN_BIT))
</MACRO>
<MACRO>
<NAME>AGS_TOGGLE_PATTERN_BIT_GET_CLASS</NAME>
#define AGS_TOGGLE_PATTERN_BIT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_TOGGLE_PATTERN_BIT, AgsTogglePatternBitClass))
</MACRO>
<STRUCT>
<NAME>AgsTogglePatternBit</NAME>
struct _AgsTogglePatternBit
{
  AgsTask task;
  
  AgsPattern *pattern;
  guint line;

  guint index_i;
  guint index_j;
  guint bit;
};
</STRUCT>
<STRUCT>
<NAME>AgsTogglePatternBitClass</NAME>
struct _AgsTogglePatternBitClass
{
  AgsTaskClass task;

  void (*refresh_gui)(AgsTogglePatternBit *toggle_pattern_bit);
};
</STRUCT>
<FUNCTION>
<NAME>ags_toggle_pattern_bit_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_toggle_pattern_bit_refresh_gui</NAME>
<RETURNS>void  </RETURNS>
AgsTogglePatternBit *toggle_pattern_bit 
</FUNCTION>
<FUNCTION>
<NAME>ags_toggle_pattern_bit_new</NAME>
<RETURNS>AgsTogglePatternBit * </RETURNS>
AgsPattern *pattern, guint line, guint index_i, guint index_j, guint bit 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CHANNEL_SET_RECYCLING</NAME>
#define AGS_TYPE_CHANNEL_SET_RECYCLING                (ags_channel_set_recycling_get_type())
</MACRO>
<MACRO>
<NAME>AGS_CHANNEL_SET_RECYCLING</NAME>
#define AGS_CHANNEL_SET_RECYCLING(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CHANNEL_SET_RECYCLING, AgsChannelSetRecycling))
</MACRO>
<MACRO>
<NAME>AGS_CHANNEL_SET_RECYCLING_CLASS</NAME>
#define AGS_CHANNEL_SET_RECYCLING_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_CHANNEL_SET_RECYCLING, AgsChannelSetRecyclingClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_CHANNEL_SET_RECYCLING</NAME>
#define AGS_IS_CHANNEL_SET_RECYCLING(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_CHANNEL_SET_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_IS_CHANNEL_SET_RECYCLING_CLASS</NAME>
#define AGS_IS_CHANNEL_SET_RECYCLING_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_CHANNEL_SET_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_CHANNEL_SET_RECYCLING_GET_CLASS</NAME>
#define AGS_CHANNEL_SET_RECYCLING_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_CHANNEL_SET_RECYCLING, AgsChannelSetRecyclingClass))
</MACRO>
<STRUCT>
<NAME>AgsChannelSetRecycling</NAME>
struct _AgsChannelSetRecycling
{
  AgsTask task;

  AgsChannel *channel;

  AgsRecycling *first_recycling;
  AgsRecycling *last_recycling;
};
</STRUCT>
<STRUCT>
<NAME>AgsChannelSetRecyclingClass</NAME>
struct _AgsChannelSetRecyclingClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_channel_set_recycling_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_channel_set_recycling_new</NAME>
<RETURNS>AgsChannelSetRecycling * </RETURNS>
AgsChannel *channel, AgsRecycling *first_recycling, AgsRecycling *last_recycling 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_APPLY_SYNTH</NAME>
#define AGS_TYPE_APPLY_SYNTH                (ags_apply_synth_get_type())
</MACRO>
<MACRO>
<NAME>AGS_APPLY_SYNTH</NAME>
#define AGS_APPLY_SYNTH(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_APPLY_SYNTH, AgsApplySynth))
</MACRO>
<MACRO>
<NAME>AGS_APPLY_SYNTH_CLASS</NAME>
#define AGS_APPLY_SYNTH_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_APPLY_SYNTH, AgsApplySynthClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPLY_SYNTH</NAME>
#define AGS_IS_APPLY_SYNTH(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_APPLY_SYNTH))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPLY_SYNTH_CLASS</NAME>
#define AGS_IS_APPLY_SYNTH_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_APPLY_SYNTH))
</MACRO>
<MACRO>
<NAME>AGS_APPLY_SYNTH_GET_CLASS</NAME>
#define AGS_APPLY_SYNTH_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_APPLY_SYNTH, AgsApplySynthClass))
</MACRO>
<ENUM>
<NAME>AgsApplySynthWave</NAME>
typedef enum{
  AGS_APPLY_SYNTH_INVALID,
  AGS_APPLY_SYNTH_SIN,
  AGS_APPLY_SYNTH_SAW,
  AGS_APPLY_SYNTH_SQUARE,
  AGS_APPLY_SYNTH_TRIANGLE,
}AgsApplySynthWave;
</ENUM>
<STRUCT>
<NAME>AgsApplySynth</NAME>
struct _AgsApplySynth
{
  AgsTask task;

  AgsChannel *start_channel;
  guint count;

  guint wave;

  guint attack;
  guint frame_count;
  guint frequency;
  guint phase;
  guint start;

  gdouble volume;

  guint loop_start;
  guint loop_end;
};
</STRUCT>
<STRUCT>
<NAME>AgsApplySynthClass</NAME>
struct _AgsApplySynthClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_apply_synth_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_apply_synth_new</NAME>
<RETURNS>AgsApplySynth * </RETURNS>
AgsChannel *start_channel, guint count, guint wave, guint attack, guint frame_count, guint frequency, guint phase, guint start, gdouble volume, guint loop_start, guint loop_end 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RESIZE_AUDIO</NAME>
#define AGS_TYPE_RESIZE_AUDIO                (ags_resize_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RESIZE_AUDIO</NAME>
#define AGS_RESIZE_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RESIZE_AUDIO, AgsResizeAudio))
</MACRO>
<MACRO>
<NAME>AGS_RESIZE_AUDIO_CLASS</NAME>
#define AGS_RESIZE_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_RESIZE_AUDIO, AgsResizeAudioClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RESIZE_AUDIO</NAME>
#define AGS_IS_RESIZE_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_RESIZE_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_RESIZE_AUDIO_CLASS</NAME>
#define AGS_IS_RESIZE_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_RESIZE_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_RESIZE_AUDIO_GET_CLASS</NAME>
#define AGS_RESIZE_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_RESIZE_AUDIO, AgsResizeAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsResizeAudio</NAME>
struct _AgsResizeAudio
{
  AgsTask task;

  AgsAudio *audio;
  guint output_pads;
  guint input_pads;
  guint audio_channels;
};
</STRUCT>
<STRUCT>
<NAME>AgsResizeAudioClass</NAME>
struct _AgsResizeAudioClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_resize_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_resize_audio_new</NAME>
<RETURNS>AgsResizeAudio * </RETURNS>
AgsAudio *audio, guint output_pads, guint input_pads, guint audio_channels 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SET_SAMPLERATE</NAME>
#define AGS_TYPE_SET_SAMPLERATE                (ags_set_samplerate_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SET_SAMPLERATE</NAME>
#define AGS_SET_SAMPLERATE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SET_SAMPLERATE, AgsSetSamplerate))
</MACRO>
<MACRO>
<NAME>AGS_SET_SAMPLERATE_CLASS</NAME>
#define AGS_SET_SAMPLERATE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SET_SAMPLERATE, AgsSetSamplerateClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SET_SAMPLERATE</NAME>
#define AGS_IS_SET_SAMPLERATE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SET_SAMPLERATE))
</MACRO>
<MACRO>
<NAME>AGS_IS_SET_SAMPLERATE_CLASS</NAME>
#define AGS_IS_SET_SAMPLERATE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SET_SAMPLERATE))
</MACRO>
<MACRO>
<NAME>AGS_SET_SAMPLERATE_GET_CLASS</NAME>
#define AGS_SET_SAMPLERATE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SET_SAMPLERATE, AgsSetSamplerateClass))
</MACRO>
<STRUCT>
<NAME>AgsSetSamplerate</NAME>
struct _AgsSetSamplerate
{
  AgsTask task;

  GObject *gobject;
  guint samplerate;
};
</STRUCT>
<STRUCT>
<NAME>AgsSetSamplerateClass</NAME>
struct _AgsSetSamplerateClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_set_samplerate_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_set_samplerate_new</NAME>
<RETURNS>AgsSetSamplerate * </RETURNS>
GObject *gobject, guint samplerate 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_REMOVE_AUDIO_SIGNAL</NAME>
#define AGS_TYPE_REMOVE_AUDIO_SIGNAL                (ags_remove_audio_signal_get_type())
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_AUDIO_SIGNAL</NAME>
#define AGS_REMOVE_AUDIO_SIGNAL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_REMOVE_AUDIO_SIGNAL, AgsRemoveAudioSignal))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_REMOVE_AUDIO_SIGNAL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_REMOVE_AUDIO_SIGNAL, AgsRemoveAudioSignalClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_AUDIO_SIGNAL</NAME>
#define AGS_IS_REMOVE_AUDIO_SIGNAL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_REMOVE_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_IS_REMOVE_AUDIO_SIGNAL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_REMOVE_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_AUDIO_SIGNAL_GET_CLASS</NAME>
#define AGS_REMOVE_AUDIO_SIGNAL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_REMOVE_AUDIO_SIGNAL, AgsRemoveAudioSignalClass))
</MACRO>
<STRUCT>
<NAME>AgsRemoveAudioSignal</NAME>
struct _AgsRemoveAudioSignal
{
  AgsTask task;

  AgsRecycling *recycling;
  AgsAudioSignal *audio_signal;
};
</STRUCT>
<STRUCT>
<NAME>AgsRemoveAudioSignalClass</NAME>
struct _AgsRemoveAudioSignalClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_remove_audio_signal_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_remove_audio_signal_new</NAME>
<RETURNS>AgsRemoveAudioSignal * </RETURNS>
AgsRecycling *recycling, AgsAudioSignal *audio_signal 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_ADD_RECALL_CONTAINER</NAME>
#define AGS_TYPE_ADD_RECALL_CONTAINER                (ags_add_recall_container_get_type())
</MACRO>
<MACRO>
<NAME>AGS_ADD_RECALL_CONTAINER</NAME>
#define AGS_ADD_RECALL_CONTAINER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_ADD_RECALL_CONTAINER, AgsAddRecallContainer))
</MACRO>
<MACRO>
<NAME>AGS_ADD_RECALL_CONTAINER_CLASS</NAME>
#define AGS_ADD_RECALL_CONTAINER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_ADD_RECALL_CONTAINER, AgsAddRecallContainerClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_RECALL_CONTAINER</NAME>
#define AGS_IS_ADD_RECALL_CONTAINER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_ADD_RECALL_CONTAINER))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_RECALL_CONTAINER_CLASS</NAME>
#define AGS_IS_ADD_RECALL_CONTAINER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_ADD_RECALL_CONTAINER))
</MACRO>
<MACRO>
<NAME>AGS_ADD_RECALL_CONTAINER_GET_CLASS</NAME>
#define AGS_ADD_RECALL_CONTAINER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_ADD_RECALL_CONTAINER, AgsAddRecallContainerClass))
</MACRO>
<STRUCT>
<NAME>AgsAddRecallContainer</NAME>
struct _AgsAddRecallContainer
{
  AgsTask task;

  GObject *audio;

  AgsRecallContainer *recall_container;
};
</STRUCT>
<STRUCT>
<NAME>AgsAddRecallContainerClass</NAME>
struct _AgsAddRecallContainerClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_add_recall_container_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_add_recall_container_new</NAME>
<RETURNS>AgsAddRecallContainer * </RETURNS>
GObject *audio, AgsRecallContainer *recall_container 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_REMOVE_NOTE</NAME>
#define AGS_TYPE_REMOVE_NOTE                (ags_remove_note_get_type())
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_NOTE</NAME>
#define AGS_REMOVE_NOTE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_REMOVE_NOTE, AgsRemoveNote))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_NOTE_CLASS</NAME>
#define AGS_REMOVE_NOTE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_REMOVE_NOTE, AgsRemoveNoteClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_NOTE</NAME>
#define AGS_IS_REMOVE_NOTE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_REMOVE_NOTE))
</MACRO>
<MACRO>
<NAME>AGS_IS_REMOVE_NOTE_CLASS</NAME>
#define AGS_IS_REMOVE_NOTE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_REMOVE_NOTE))
</MACRO>
<MACRO>
<NAME>AGS_REMOVE_NOTE_GET_CLASS</NAME>
#define AGS_REMOVE_NOTE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_REMOVE_NOTE, AgsRemoveNoteClass))
</MACRO>
<STRUCT>
<NAME>AgsRemoveNote</NAME>
struct _AgsRemoveNote
{
  AgsTask task;

  AgsNotation *notation;

  guint x;
  guint y;
};
</STRUCT>
<STRUCT>
<NAME>AgsRemoveNoteClass</NAME>
struct _AgsRemoveNoteClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_remove_note_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_remove_note_new</NAME>
<RETURNS>AgsRemoveNote * </RETURNS>
AgsNotation *notation, guint x, guint y 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CANCEL_RECALL</NAME>
#define AGS_TYPE_CANCEL_RECALL                (ags_cancel_recall_get_type())
</MACRO>
<MACRO>
<NAME>AGS_CANCEL_RECALL</NAME>
#define AGS_CANCEL_RECALL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CANCEL_RECALL, AgsCancelRecall))
</MACRO>
<MACRO>
<NAME>AGS_CANCEL_RECALL_CLASS</NAME>
#define AGS_CANCEL_RECALL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_CANCEL_RECALL, AgsCancelRecallClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_CANCEL_RECALL</NAME>
#define AGS_IS_CANCEL_RECALL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_CANCEL_RECALL))
</MACRO>
<MACRO>
<NAME>AGS_IS_CANCEL_RECALL_CLASS</NAME>
#define AGS_IS_CANCEL_RECALL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_CANCEL_RECALL))
</MACRO>
<MACRO>
<NAME>AGS_CANCEL_RECALL_GET_CLASS</NAME>
#define AGS_CANCEL_RECALL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_CANCEL_RECALL, AgsCancelRecallClass))
</MACRO>
<STRUCT>
<NAME>AgsCancelRecall</NAME>
struct _AgsCancelRecall
{
  AgsTask task;

  AgsRecall *recall;

  AgsPlayback *playback;
};
</STRUCT>
<STRUCT>
<NAME>AgsCancelRecallClass</NAME>
struct _AgsCancelRecallClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_cancel_recall_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_cancel_recall_new</NAME>
<RETURNS>AgsCancelRecall * </RETURNS>
AgsRecall *recall, AgsPlayback *playback 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_ADD_EFFECT</NAME>
#define AGS_TYPE_ADD_EFFECT                (ags_add_effect_get_type())
</MACRO>
<MACRO>
<NAME>AGS_ADD_EFFECT</NAME>
#define AGS_ADD_EFFECT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_ADD_EFFECT, AgsAddEffect))
</MACRO>
<MACRO>
<NAME>AGS_ADD_EFFECT_CLASS</NAME>
#define AGS_ADD_EFFECT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_ADD_EFFECT, AgsAddEffectClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_EFFECT</NAME>
#define AGS_IS_ADD_EFFECT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_ADD_EFFECT))
</MACRO>
<MACRO>
<NAME>AGS_IS_ADD_EFFECT_CLASS</NAME>
#define AGS_IS_ADD_EFFECT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_ADD_EFFECT))
</MACRO>
<MACRO>
<NAME>AGS_ADD_EFFECT_GET_CLASS</NAME>
#define AGS_ADD_EFFECT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_ADD_EFFECT, AgsAddEffectClass))
</MACRO>
<STRUCT>
<NAME>AgsAddEffect</NAME>
struct _AgsAddEffect
{
  AgsTask task;

  AgsChannel *channel;

  gchar *filename;
  gchar *effect;
};
</STRUCT>
<STRUCT>
<NAME>AgsAddEffectClass</NAME>
struct _AgsAddEffectClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_add_effect_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_add_effect_new</NAME>
<RETURNS>AgsAddEffect * </RETURNS>
AgsChannel *channel, gchar *filename, gchar *effect 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_UNREF_AUDIO_SIGNAL</NAME>
#define AGS_TYPE_UNREF_AUDIO_SIGNAL                (ags_unref_audio_signal_get_type())
</MACRO>
<MACRO>
<NAME>AGS_UNREF_AUDIO_SIGNAL</NAME>
#define AGS_UNREF_AUDIO_SIGNAL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_UNREF_AUDIO_SIGNAL, AgsUnrefAudioSignal))
</MACRO>
<MACRO>
<NAME>AGS_UNREF_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_UNREF_AUDIO_SIGNAL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_UNREF_AUDIO_SIGNAL, AgsUnrefAudioSignalClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_UNREF_AUDIO_SIGNAL</NAME>
#define AGS_IS_UNREF_AUDIO_SIGNAL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_UNREF_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_IS_UNREF_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_IS_UNREF_AUDIO_SIGNAL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_UNREF_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_UNREF_AUDIO_SIGNAL_GET_CLASS</NAME>
#define AGS_UNREF_AUDIO_SIGNAL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_UNREF_AUDIO_SIGNAL, AgsUnrefAudioSignalClass))
</MACRO>
<STRUCT>
<NAME>AgsUnrefAudioSignal</NAME>
struct _AgsUnrefAudioSignal
{
  AgsTask task;

  AgsAudioSignal *audio_signal;
};
</STRUCT>
<STRUCT>
<NAME>AgsUnrefAudioSignalClass</NAME>
struct _AgsUnrefAudioSignalClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_unref_audio_signal_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_unref_audio_signal_new</NAME>
<RETURNS>AgsUnrefAudioSignal * </RETURNS>
AgsAudioSignal *audio_signal 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_FREE_SELECTION</NAME>
#define AGS_TYPE_FREE_SELECTION                (ags_free_selection_get_type())
</MACRO>
<MACRO>
<NAME>AGS_FREE_SELECTION</NAME>
#define AGS_FREE_SELECTION(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_FREE_SELECTION, AgsFreeSelection))
</MACRO>
<MACRO>
<NAME>AGS_FREE_SELECTION_CLASS</NAME>
#define AGS_FREE_SELECTION_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_FREE_SELECTION, AgsFreeSelectionClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_FREE_SELECTION</NAME>
#define AGS_IS_FREE_SELECTION(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_FREE_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_IS_FREE_SELECTION_CLASS</NAME>
#define AGS_IS_FREE_SELECTION_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_FREE_SELECTION))
</MACRO>
<MACRO>
<NAME>AGS_FREE_SELECTION_GET_CLASS</NAME>
#define AGS_FREE_SELECTION_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_FREE_SELECTION, AgsFreeSelectionClass))
</MACRO>
<STRUCT>
<NAME>AgsFreeSelection</NAME>
struct _AgsFreeSelection
{
  AgsTask task;

  AgsNotation *notation;
};
</STRUCT>
<STRUCT>
<NAME>AgsFreeSelectionClass</NAME>
struct _AgsFreeSelectionClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_free_selection_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_free_selection_new</NAME>
<RETURNS>AgsFreeSelection * </RETURNS>
AgsNotation *notation 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_APPEND_RECALL</NAME>
#define AGS_TYPE_APPEND_RECALL                (ags_append_recall_get_type())
</MACRO>
<MACRO>
<NAME>AGS_APPEND_RECALL</NAME>
#define AGS_APPEND_RECALL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_APPEND_RECALL, AgsAppendRecall))
</MACRO>
<MACRO>
<NAME>AGS_APPEND_RECALL_CLASS</NAME>
#define AGS_APPEND_RECALL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_APPEND_RECALL, AgsAppendRecallClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPEND_RECALL</NAME>
#define AGS_IS_APPEND_RECALL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_APPEND_RECALL))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPEND_RECALL_CLASS</NAME>
#define AGS_IS_APPEND_RECALL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_APPEND_RECALL))
</MACRO>
<MACRO>
<NAME>AGS_APPEND_RECALL_GET_CLASS</NAME>
#define AGS_APPEND_RECALL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_APPEND_RECALL, AgsAppendRecallClass))
</MACRO>
<STRUCT>
<NAME>AgsAppendRecall</NAME>
struct _AgsAppendRecall
{
  AgsTask task;

  GObject *audio_loop;
  AgsPlayback *playback;
};
</STRUCT>
<STRUCT>
<NAME>AgsAppendRecallClass</NAME>
struct _AgsAppendRecallClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_append_recall_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_append_recall_new</NAME>
<RETURNS>AgsAppendRecall * </RETURNS>
GObject *audio_loop, AgsPlayback *playback 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SET_MUTED</NAME>
#define AGS_TYPE_SET_MUTED                (ags_set_muted_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SET_MUTED</NAME>
#define AGS_SET_MUTED(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SET_MUTED, AgsSetMuted))
</MACRO>
<MACRO>
<NAME>AGS_SET_MUTED_CLASS</NAME>
#define AGS_SET_MUTED_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SET_MUTED, AgsSetMutedClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SET_MUTED</NAME>
#define AGS_IS_SET_MUTED(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SET_MUTED))
</MACRO>
<MACRO>
<NAME>AGS_IS_SET_MUTED_CLASS</NAME>
#define AGS_IS_SET_MUTED_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SET_MUTED))
</MACRO>
<MACRO>
<NAME>AGS_SET_MUTED_GET_CLASS</NAME>
#define AGS_SET_MUTED_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SET_MUTED, AgsSetMutedClass))
</MACRO>
<STRUCT>
<NAME>AgsSetMuted</NAME>
struct _AgsSetMuted
{
  AgsTask task;

  GObject *gobject;

  gboolean muted;
};
</STRUCT>
<STRUCT>
<NAME>AgsSetMutedClass</NAME>
struct _AgsSetMutedClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_set_muted_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_set_muted_new</NAME>
<RETURNS>AgsSetMuted * </RETURNS>
GObject *gobject, gboolean muted 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_APPLY_TACT</NAME>
#define AGS_TYPE_APPLY_TACT                (ags_apply_tact_get_type())
</MACRO>
<MACRO>
<NAME>AGS_APPLY_TACT</NAME>
#define AGS_APPLY_TACT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_APPLY_TACT, AgsApplyTact))
</MACRO>
<MACRO>
<NAME>AGS_APPLY_TACT_CLASS</NAME>
#define AGS_APPLY_TACT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_APPLY_TACT, AgsApplyTactClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPLY_TACT</NAME>
#define AGS_IS_APPLY_TACT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_APPLY_TACT))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPLY_TACT_CLASS</NAME>
#define AGS_IS_APPLY_TACT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_APPLY_TACT))
</MACRO>
<MACRO>
<NAME>AGS_APPLY_TACT_GET_CLASS</NAME>
#define AGS_APPLY_TACT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_APPLY_TACT, AgsApplyTactClass))
</MACRO>
<STRUCT>
<NAME>AgsApplyTact</NAME>
struct _AgsApplyTact
{
  AgsTask task;

  GObject *gobject;

  gdouble tact;
};
</STRUCT>
<STRUCT>
<NAME>AgsApplyTactClass</NAME>
struct _AgsApplyTactClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_apply_tact_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_apply_tact_new</NAME>
<RETURNS>AgsApplyTact * </RETURNS>
GObject *gobject, gdouble tact 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_APPLY_BPM</NAME>
#define AGS_TYPE_APPLY_BPM                (ags_apply_bpm_get_type())
</MACRO>
<MACRO>
<NAME>AGS_APPLY_BPM</NAME>
#define AGS_APPLY_BPM(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_APPLY_BPM, AgsApplyBpm))
</MACRO>
<MACRO>
<NAME>AGS_APPLY_BPM_CLASS</NAME>
#define AGS_APPLY_BPM_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_APPLY_BPM, AgsApplyBpmClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPLY_BPM</NAME>
#define AGS_IS_APPLY_BPM(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_APPLY_BPM))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPLY_BPM_CLASS</NAME>
#define AGS_IS_APPLY_BPM_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_APPLY_BPM))
</MACRO>
<MACRO>
<NAME>AGS_APPLY_BPM_GET_CLASS</NAME>
#define AGS_APPLY_BPM_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_APPLY_BPM, AgsApplyBpmClass))
</MACRO>
<STRUCT>
<NAME>AgsApplyBpm</NAME>
struct _AgsApplyBpm
{
  AgsTask task;

  GObject *gobject;

  gdouble bpm;
};
</STRUCT>
<STRUCT>
<NAME>AgsApplyBpmClass</NAME>
struct _AgsApplyBpmClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_apply_bpm_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_apply_bpm_new</NAME>
<RETURNS>AgsApplyBpm * </RETURNS>
GObject *gobject, gdouble bpm 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_APPLY_SEQUENCER_LENGTH</NAME>
#define AGS_TYPE_APPLY_SEQUENCER_LENGTH                (ags_apply_sequencer_length_get_type())
</MACRO>
<MACRO>
<NAME>AGS_APPLY_SEQUENCER_LENGTH</NAME>
#define AGS_APPLY_SEQUENCER_LENGTH(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_APPLY_SEQUENCER_LENGTH, AgsApplySequencerLength))
</MACRO>
<MACRO>
<NAME>AGS_APPLY_SEQUENCER_LENGTH_CLASS</NAME>
#define AGS_APPLY_SEQUENCER_LENGTH_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_APPLY_SEQUENCER_LENGTH, AgsApplySequencerLengthClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPLY_SEQUENCER_LENGTH</NAME>
#define AGS_IS_APPLY_SEQUENCER_LENGTH(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_APPLY_SEQUENCER_LENGTH))
</MACRO>
<MACRO>
<NAME>AGS_IS_APPLY_SEQUENCER_LENGTH_CLASS</NAME>
#define AGS_IS_APPLY_SEQUENCER_LENGTH_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_APPLY_SEQUENCER_LENGTH))
</MACRO>
<MACRO>
<NAME>AGS_APPLY_SEQUENCER_LENGTH_GET_CLASS</NAME>
#define AGS_APPLY_SEQUENCER_LENGTH_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_APPLY_SEQUENCER_LENGTH, AgsApplySequencerLengthClass))
</MACRO>
<STRUCT>
<NAME>AgsApplySequencerLength</NAME>
struct _AgsApplySequencerLength
{
  AgsTask task;

  GObject *gobject;

  gdouble length;
};
</STRUCT>
<STRUCT>
<NAME>AgsApplySequencerLengthClass</NAME>
struct _AgsApplySequencerLengthClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_apply_sequencer_length_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_apply_sequencer_length_new</NAME>
<RETURNS>AgsApplySequencerLength * </RETURNS>
GObject *gobject, gdouble length 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_IPATCH_SF2_READER</NAME>
#define AGS_TYPE_IPATCH_SF2_READER                (ags_ipatch_sf2_reader_get_type())
</MACRO>
<MACRO>
<NAME>AGS_IPATCH_SF2_READER</NAME>
#define AGS_IPATCH_SF2_READER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_IPATCH_SF2_READER, AgsIpatchSF2Reader))
</MACRO>
<MACRO>
<NAME>AGS_IPATCH_SF2_READER_CLASS</NAME>
#define AGS_IPATCH_SF2_READER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_IPATCH_SF2_READER, AgsIpatchSF2ReaderClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_IPATCH_SF2_READER</NAME>
#define AGS_IS_IPATCH_SF2_READER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_IPATCH_SF2_READER))
</MACRO>
<MACRO>
<NAME>AGS_IS_IPATCH_SF2_READER_CLASS</NAME>
#define AGS_IS_IPATCH_SF2_READER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_IPATCH_SF2_READER))
</MACRO>
<MACRO>
<NAME>AGS_IPATCH_SF2_READER_GET_CLASS</NAME>
#define AGS_IPATCH_SF2_READER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_IPATCH_SF2_READER, AgsIpatchSF2ReaderClass))
</MACRO>
<ENUM>
<NAME>AgsSF2Levels</NAME>
typedef enum{
  AGS_SF2_FILENAME = 0,
  AGS_SF2_PHDR = 1,
  AGS_SF2_IHDR = 2,
  AGS_SF2_SHDR = 3,
}AgsSF2Levels;
</ENUM>
<STRUCT>
<NAME>AgsIpatchSF2Reader</NAME>
struct _AgsIpatchSF2Reader
{
  GObject object;

  AgsIpatch *ipatch;

  gchar **selected;

  IpatchSF2Reader *reader;

  IpatchSF2 *sf2;

  int bank;
  int program;

  IpatchContainer *preset;
  IpatchContainer *instrument;
  IpatchContainer *sample;

  int count;
};
</STRUCT>
<STRUCT>
<NAME>AgsIpatchSF2ReaderClass</NAME>
struct _AgsIpatchSF2ReaderClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_ipatch_sf2_reader_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_ipatch_sf2_reader_new</NAME>
<RETURNS>AgsIpatchSF2Reader * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAYABLE</NAME>
#define AGS_TYPE_PLAYABLE                    (ags_playable_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAYABLE</NAME>
#define AGS_PLAYABLE(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAYABLE, AgsPlayable))
</MACRO>
<MACRO>
<NAME>AGS_PLAYABLE_INTERFACE</NAME>
#define AGS_PLAYABLE_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_PLAYABLE, AgsPlayableInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAYABLE</NAME>
#define AGS_IS_PLAYABLE(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PLAYABLE))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAYABLE_INTERFACE</NAME>
#define AGS_IS_PLAYABLE_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_PLAYABLE))
</MACRO>
<MACRO>
<NAME>AGS_PLAYABLE_GET_INTERFACE</NAME>
#define AGS_PLAYABLE_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_PLAYABLE, AgsPlayableInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsPlayable</NAME>
typedef void AgsPlayable;
</TYPEDEF>
<MACRO>
<NAME>AGS_PLAYABLE_ERROR</NAME>
#define AGS_PLAYABLE_ERROR (ags_playable_error_quark())
</MACRO>
<ENUM>
<NAME>AgsPlayableError</NAME>
typedef enum{
  AGS_PLAYABLE_ERROR_NO_SUCH_LEVEL,
  AGS_PLAYABLE_ERROR_NO_SAMPLE,
}AgsPlayableError;
</ENUM>
<STRUCT>
<NAME>AgsPlayableInterface</NAME>
struct _AgsPlayableInterface
{
  GTypeInterface interface;

  gboolean (*open)(AgsPlayable *playable, gchar *name);
  gboolean (*rw_open)(AgsPlayable *playable, gchar *name,
		      gboolean create);

  /* these functions are especially for soundfonts */
  guint (*level_count)(AgsPlayable *playable);
  guint (*nth_level)(AgsPlayable *playable);
  gchar* (*selected_level)(AgsPlayable *playable);

  gchar** (*sublevel_names)(AgsPlayable *playable);
  void (*level_select)(AgsPlayable *playable,
		       guint nth_level, gchar *sublevel_name,
		       GError **error);
  void (*level_up)(AgsPlayable *playable,
		   guint levels,
		   GError **error);

  void (*iter_start)(AgsPlayable *playable);
  gboolean (*iter_next)(AgsPlayable *playable);

  /* low-level */
  void (*set_pointer)(AgsPlayable *playable,
		      guchar *data);
  guchar* (*get_pointer)(AgsPlayable *playable);

  void (*set_current)(AgsPlayable *playable,
		      guchar *current);
  guchar* (*get_current)(AgsPlayable *playable);
  
  /* read sample data */
  void (*info)(AgsPlayable *playable,
	       guint *channels, guint *frames,
	       guint *loop_start, guint *loop_end,
	       GError **error);

  void (*set_presets)(AgsPlayable *playable,
		      guint samplerate,
		      guint buffer_size,
		      guint channels,
		      guint format);
  void (*get_presets)(AgsPlayable *playable,
		      guint *samplerate,
		      guint *buffer_size,
		      guint *channels,
		      guint *format);

  void (*set_channels)(AgsPlayable *playable,
		       guint channels);
  guint (*get_channels)(AgsPlayable *playable);

  void (*set_frames)(AgsPlayable *playable,
		      guint frames);
  guint (*get_frames)(AgsPlayable *playable);

  void (*set_loop)(AgsPlayable *playable,
		   guint loop_start, guint loop_end);
  void (*get_loop)(AgsPlayable *playable,
		   guint *loop_start, guint *loop_end);

  /* read/write sample data */
  signed short* (*read)(AgsPlayable *playable,
			guint channel,
			GError **error);

  void (*write)(AgsPlayable *playable,
		signed short *buffer, guint buffer_length);
  void (*flush)(AgsPlayable *playable);

  /* position */
  void (*seek)(AgsPlayable *playable,
	       guint frames, gint whence);

  /* close */
  void (*close)(AgsPlayable *playable);
};
</STRUCT>
<FUNCTION>
<NAME>ags_playable_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_open</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPlayable *playable, gchar *name 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_rw_open</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPlayable *playable, gchar *name, gboolean create 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_level_count</NAME>
<RETURNS>guint  </RETURNS>
AgsPlayable *playable 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_nth_level</NAME>
<RETURNS>guint  </RETURNS>
AgsPlayable *playable 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_selected_level</NAME>
<RETURNS>gchar * </RETURNS>
AgsPlayable *playable 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_sublevel_names</NAME>
<RETURNS>gchar ** </RETURNS>
AgsPlayable *playable 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_level_select</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, guint nth_level, gchar *sublevel_name, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_level_up</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, guint levels, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_iter_start</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_iter_next</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPlayable *playable 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_set_pointer</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, guchar *data 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_get_pointer</NAME>
<RETURNS>guchar * </RETURNS>
AgsPlayable *playable 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_set_current</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, guchar *current 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_get_current</NAME>
<RETURNS>guchar * </RETURNS>
AgsPlayable *playable 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_info</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, guint *channels, guint *frames, guint *loop_start, guint *loop_end, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_set_presets</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, guint samplerate, guint buffer_size, guint channels, guint format 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_get_presets</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, guint *samplerate, guint *buffer_size, guint *channels, guint *format 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_set_channels</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, guint channels 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_get_channels</NAME>
<RETURNS>guint  </RETURNS>
AgsPlayable *playable 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_set_frames</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, guint frames 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_get_frames</NAME>
<RETURNS>guint  </RETURNS>
AgsPlayable *playable 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_set_loop</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, guint loop_start, guint loop_end 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_get_loop</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, guint *loop_start, guint *loop_end 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_read</NAME>
<RETURNS>signed short * </RETURNS>
AgsPlayable *playable, guint channel, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_write</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, signed short *buffer, guint buffer_length 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_flush</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_seek</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable, guint frames, gint whence 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_close</NAME>
<RETURNS>void  </RETURNS>
AgsPlayable *playable 
</FUNCTION>
<FUNCTION>
<NAME>ags_playable_read_audio_signal</NAME>
<RETURNS>GList * </RETURNS>
AgsPlayable *playable, AgsSoundcard *soundcard, guint start_channel, guint channels 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_devout</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsDevout **devout 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_devout</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsDevout *devout 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_devout_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **devout 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_devout_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *devout 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_playback</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsPlayback **playback 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_playback</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsPlayback *playback 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_playback_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **playback 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_playback_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *playback 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_audio</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsAudio **audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_audio</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsAudio *audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_audio_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_audio_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_channel</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsChannel **channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_channel</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsChannel *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_channel_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_channel_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_input</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsChannel *input 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_input</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsChannel *input 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_output</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsChannel *output 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_output</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsChannel *output 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_recall</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsRecall **recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_recall</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_recall_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_recall_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_recall_container</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsRecallContainer **recall_container 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_recall_container</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsRecallContainer *recall_container 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_recall_container_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **recall_container 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_recall_container_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *recall_container 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_recall_audio</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_recall_audio</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_recall_audio_run</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_recall_audio_run</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_recall_channel</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_recall_channel</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_recall_channel_run</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_recall_channel_run</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_recall_recycling</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_recall_recycling</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_recall_audio_signal</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_recall_audio_signal</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsRecall *recall 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_port</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsPort **port 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_port</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsPort *port 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_port_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **port 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_port_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *port 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_recycling</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsRecycling **recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_recycling</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsRecycling *recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_recycling_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_recycling_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *recycling 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_audio_signal</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsAudioSignal **audio_signal 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_audio_signal</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsAudioSignal *audio_signal 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_audio_signal_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **audio_signal 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_audio_signal_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *audio_signal 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_stream</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **stream, guint *index, guint buffer_size 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_stream</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *stream, guint index, guint buffer_size 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_stream_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **stream, guint buffer_size 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_stream_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *stream, guint buffer_size 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_pattern</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsPattern **pattern 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_pattern</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsPattern *pattern 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_pattern_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **pattern 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_pattern_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *pattern 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_pattern_data</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsPattern *pattern, guint *i, guint *j, guint length 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_pattern_data</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsPattern *pattern, guint i, guint j, guint length 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_pattern_data_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsPattern *pattern, guint length 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_pattern_data_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsPattern *pattern, guint length 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_notation</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsNotation **notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_notation</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsNotation *notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_notation_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_notation_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *notation 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_note</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsNote **note 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_note</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsNote *note 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_note_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **note 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_note_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *note 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_task</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsTask **task 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_task</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsTask *task 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_task_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **task 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_task_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *task 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_timestamp</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsTimestamp **timestamp 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_timestamp</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsTimestamp *timestamp 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_timestamp_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **timestamp 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_timestamp_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *timestamp 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_embedded_audio</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, gchar **embedded_audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_embedded_audio</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, gchar *embedded_audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_embedded_audio_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **embedded_audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_embedded_audio_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *embedded_audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_file_link</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsFileLink **file_link 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_file_link</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsFileLink *file_link 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_file_link_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **file_link 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_file_link_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *file_link 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SNDFILE</NAME>
#define AGS_TYPE_SNDFILE                (ags_sndfile_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SNDFILE</NAME>
#define AGS_SNDFILE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SNDFILE, AgsSndfile))
</MACRO>
<MACRO>
<NAME>AGS_SNDFILE_CLASS</NAME>
#define AGS_SNDFILE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_SNDFILE, AgsSndfileClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SNDFILE</NAME>
#define AGS_IS_SNDFILE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_SNDFILE))
</MACRO>
<MACRO>
<NAME>AGS_IS_SNDFILE_CLASS</NAME>
#define AGS_IS_SNDFILE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_SNDFILE))
</MACRO>
<MACRO>
<NAME>AGS_SNDFILE_GET_CLASS</NAME>
#define AGS_SNDFILE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_SNDFILE, AgsSndfileClass))
</MACRO>
<ENUM>
<NAME>AgsSndfileFlags</NAME>
typedef enum{
  AGS_SNDFILE_ITER_START    = 1,
  AGS_SNDFILE_VIRTUAL       = 1 << 1,
}AgsSndfileFlags;
</ENUM>
<STRUCT>
<NAME>AgsSndfile</NAME>
struct _AgsSndfile
{
  GObject object;

  guint flags;

  SF_INFO *info;
  SNDFILE *file;

  guchar *pointer;
  guchar *current;
  gsize length;
};
</STRUCT>
<STRUCT>
<NAME>AgsSndfileClass</NAME>
struct _AgsSndfileClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_sndfile_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_sndfile_new</NAME>
<RETURNS>AgsSndfile * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_IPATCH</NAME>
#define AGS_TYPE_IPATCH                (ags_ipatch_get_type())
</MACRO>
<MACRO>
<NAME>AGS_IPATCH</NAME>
#define AGS_IPATCH(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_IPATCH, AgsIpatch))
</MACRO>
<MACRO>
<NAME>AGS_IPATCH_CLASS</NAME>
#define AGS_IPATCH_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_IPATCH, AgsIpatchClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_IPATCH</NAME>
#define AGS_IS_IPATCH(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_IPATCH))
</MACRO>
<MACRO>
<NAME>AGS_IS_IPATCH_CLASS</NAME>
#define AGS_IS_IPATCH_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_IPATCH))
</MACRO>
<MACRO>
<NAME>AGS_IPATCH_GET_CLASS</NAME>
#define AGS_IPATCH_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_IPATCH, AgsIpatchClass))
</MACRO>
<MACRO>
<NAME>AGS_IPATCH_DEFAULT_CHANNELS</NAME>
#define AGS_IPATCH_DEFAULT_CHANNELS 2
</MACRO>
<MACRO>
<NAME>AGS_IPATCH_READ</NAME>
#define AGS_IPATCH_READ "r"
</MACRO>
<MACRO>
<NAME>AGS_IPATCH_WRITE</NAME>
#define AGS_IPATCH_WRITE "w"
</MACRO>
<ENUM>
<NAME>AgsIpatchFlags</NAME>
typedef enum{
  AGS_IPATCH_DLS2   = 1,
  AGS_IPATCH_SF2    = 1 << 1,
  AGS_IPATCH_GIG    = 1 << 2,
}AgsIpatchFlags;
</ENUM>
<STRUCT>
<NAME>AgsIpatch</NAME>
struct _AgsIpatch
{
  GObject object;

  guint flags;

  GObject *soundcard;
  GList *audio_signal;

  IpatchFile *file;
  char *filename;
  char *mode;

  IpatchFileHandle *handle;
  GError *error;

  IpatchBase *base;
  GObject *reader;

  IpatchList *samples;
  GList *iter;

  guint nth_level;
};
</STRUCT>
<STRUCT>
<NAME>AgsIpatchClass</NAME>
struct _AgsIpatchClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_ipatch_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_ipatch_new</NAME>
<RETURNS>AgsIpatch * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUDIO_FILE</NAME>
#define AGS_TYPE_AUDIO_FILE                (ags_audio_file_get_type())
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_FILE</NAME>
#define AGS_AUDIO_FILE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUDIO_FILE, AgsAudioFile))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_FILE_CLASS</NAME>
#define AGS_AUDIO_FILE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_AUDIO_FILE, AgsAudioFileClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_FILE</NAME>
#define AGS_IS_AUDIO_FILE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_AUDIO_FILE))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_FILE_CLASS</NAME>
#define AGS_IS_AUDIO_FILE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_AUDIO_FILE))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_FILE_GET_CLASS</NAME>
#define AGS_AUDIO_FILE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_AUDIO_FILE, AgsAudioFileClass))
</MACRO>
<STRUCT>
<NAME>AgsAudioFile</NAME>
struct _AgsAudioFile
{
  GObject object;

  GObject *soundcard;
  
  gchar *filename;
  guint samplerate;
  guint frames;
  guint channels;
  guint format;

  guint start_channel;
  guint audio_channels;
  
  GObject *playable;
  
  GList *audio_signal;
};
</STRUCT>
<STRUCT>
<NAME>AgsAudioFileClass</NAME>
struct _AgsAudioFileClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_audio_file_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_file_open</NAME>
<RETURNS>gboolean  </RETURNS>
AgsAudioFile *audio_file 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_file_open_from_data</NAME>
<RETURNS>gboolean  </RETURNS>
AgsAudioFile *audio_file, gchar *data 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_file_rw_open</NAME>
<RETURNS>gboolean  </RETURNS>
AgsAudioFile *audio_file, gboolean create 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_file_close</NAME>
<RETURNS>void  </RETURNS>
AgsAudioFile *audio_file 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_file_read_audio_signal</NAME>
<RETURNS>void  </RETURNS>
AgsAudioFile *audio_file 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_file_seek</NAME>
<RETURNS>void  </RETURNS>
AgsAudioFile *audio_file, guint frames, gint whence 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_file_write</NAME>
<RETURNS>void  </RETURNS>
AgsAudioFile *audio_file, signed short *buffer, guint buffer_size 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_file_flush</NAME>
<RETURNS>void  </RETURNS>
AgsAudioFile *audio_file 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_file_new</NAME>
<RETURNS>AgsAudioFile * </RETURNS>
gchar *filename, GObject *soundcard, guint start_channel, guint audio_channels 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_VOLUME_AUDIO_SIGNAL</NAME>
#define AGS_TYPE_VOLUME_AUDIO_SIGNAL                (ags_volume_audio_signal_get_type())
</MACRO>
<MACRO>
<NAME>AGS_VOLUME_AUDIO_SIGNAL</NAME>
#define AGS_VOLUME_AUDIO_SIGNAL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_VOLUME_AUDIO_SIGNAL, AgsVolumeAudioSignal))
</MACRO>
<MACRO>
<NAME>AGS_VOLUME_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_VOLUME_AUDIO_SIGNAL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_VOLUME_AUDIO_SIGNAL, AgsVolumeAudioSignalClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_VOLUME_AUDIO_SIGNAL</NAME>
#define AGS_IS_VOLUME_AUDIO_SIGNAL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_VOLUME_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_IS_VOLUME_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_IS_VOLUME_AUDIO_SIGNAL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_VOLUME_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_VOLUME_AUDIO_SIGNAL_GET_CLASS</NAME>
#define AGS_VOLUME_AUDIO_SIGNAL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_VOLUME_AUDIO_SIGNAL, AgsVolumeAudioSignalClass))
</MACRO>
<STRUCT>
<NAME>AgsVolumeAudioSignal</NAME>
struct _AgsVolumeAudioSignal
{
  AgsRecallAudioSignal recall_audio_signal;
};
</STRUCT>
<STRUCT>
<NAME>AgsVolumeAudioSignalClass</NAME>
struct _AgsVolumeAudioSignalClass
{
  AgsRecallAudioSignalClass recall_audio_signal;
};
</STRUCT>
<FUNCTION>
<NAME>ags_volume_audio_signal_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_volume_audio_signal_new</NAME>
<RETURNS>AgsVolumeAudioSignal * </RETURNS>
AgsAudioSignal *audio_signal 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CLONE_CHANNEL_RUN</NAME>
#define AGS_TYPE_CLONE_CHANNEL_RUN                (ags_clone_channel_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_CLONE_CHANNEL_RUN</NAME>
#define AGS_CLONE_CHANNEL_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CLONE_CHANNEL_RUN, AgsCloneChannelRun))
</MACRO>
<MACRO>
<NAME>AGS_CLONE_CHANNEL_RUN_CLASS</NAME>
#define AGS_CLONE_CHANNEL_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_CLONE_CHANNEL_RUN, AgsCloneChannelRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_CLONE_CHANNEL_RUN</NAME>
#define AGS_IS_CLONE_CHANNEL_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_CLONE_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_CLONE_CHANNEL_RUN_CLASS</NAME>
#define AGS_IS_CLONE_CHANNEL_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_CLONE_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_CLONE_CHANNEL_RUN_GET_CLASS</NAME>
#define AGS_CLONE_CHANNEL_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_CLONE_CHANNEL_RUN, AgsCloneChannelRunClass))
</MACRO>
<STRUCT>
<NAME>AgsCloneChannelRun</NAME>
struct _AgsCloneChannelRun
{
  AgsRecallChannelRun recall_channel_run;
};
</STRUCT>
<STRUCT>
<NAME>AgsCloneChannelRunClass</NAME>
struct _AgsCloneChannelRunClass
{
  AgsRecallChannelRunClass recall_channel_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_clone_channel_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_clone_channel_run_new</NAME>
<RETURNS>AgsCloneChannelRun * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_VOLUME_RECYCLING</NAME>
#define AGS_TYPE_VOLUME_RECYCLING                (ags_volume_recycling_get_type())
</MACRO>
<MACRO>
<NAME>AGS_VOLUME_RECYCLING</NAME>
#define AGS_VOLUME_RECYCLING(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_VOLUME_RECYCLING, AgsVolumeRecycling))
</MACRO>
<MACRO>
<NAME>AGS_VOLUME_RECYCLING_CLASS</NAME>
#define AGS_VOLUME_RECYCLING_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_VOLUME_RECYCLING, AgsVolumeRecyclingClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_VOLUME_RECYCLING</NAME>
#define AGS_IS_VOLUME_RECYCLING(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_VOLUME_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_IS_VOLUME_RECYCLING_CLASS</NAME>
#define AGS_IS_VOLUME_RECYCLING_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_VOLUME_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_VOLUME_RECYCLING_GET_CLASS</NAME>
#define AGS_VOLUME_RECYCLING_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_VOLUME_RECYCLING, AgsVolumeRecyclingClass))
</MACRO>
<STRUCT>
<NAME>AgsVolumeRecycling</NAME>
struct _AgsVolumeRecycling
{
  AgsRecallRecycling recall_recycling;
};
</STRUCT>
<STRUCT>
<NAME>AgsVolumeRecyclingClass</NAME>
struct _AgsVolumeRecyclingClass
{
  AgsRecallRecyclingClass recall_recycling;
};
</STRUCT>
<FUNCTION>
<NAME>ags_volume_recycling_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_volume_recycling_new</NAME>
<RETURNS>AgsVolumeRecycling * </RETURNS>
AgsRecycling *recycling 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LOOP_CHANNEL</NAME>
#define AGS_TYPE_LOOP_CHANNEL                (ags_loop_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LOOP_CHANNEL</NAME>
#define AGS_LOOP_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LOOP_CHANNEL, AgsLoopChannel))
</MACRO>
<MACRO>
<NAME>AGS_LOOP_CHANNEL_CLASS</NAME>
#define AGS_LOOP_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LOOP_CHANNEL, AgsLoopChannelClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LOOP_CHANNEL</NAME>
#define AGS_IS_LOOP_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LOOP_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_LOOP_CHANNEL_CLASS</NAME>
#define AGS_IS_LOOP_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LOOP_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_LOOP_CHANNEL_GET_CLASS</NAME>
#define AGS_LOOP_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_LOOP_CHANNEL, AgsLoopChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsLoopChannel</NAME>
struct _AgsLoopChannel
{
  AgsRecallChannel recall_channel;
  
  AgsDelayAudio *delay_audio;
  gulong sequencer_duration_changed_handler;
};
</STRUCT>
<STRUCT>
<NAME>AgsLoopChannelClass</NAME>
struct _AgsLoopChannelClass
{
  AgsRecallChannelClass recall_channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_loop_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_loop_channel_new</NAME>
<RETURNS>AgsLoopChannel * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAY_AUDIO_SIGNAL</NAME>
#define AGS_TYPE_PLAY_AUDIO_SIGNAL                (ags_play_audio_signal_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAY_AUDIO_SIGNAL</NAME>
#define AGS_PLAY_AUDIO_SIGNAL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAY_AUDIO_SIGNAL, AgsPlayAudioSignal))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_PLAY_AUDIO_SIGNAL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PLAY_AUDIO_SIGNAL, AgsPlayAudioSignalClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_AUDIO_SIGNAL</NAME>
#define AGS_IS_PLAY_AUDIO_SIGNAL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PLAY_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_IS_PLAY_AUDIO_SIGNAL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PLAY_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_AUDIO_SIGNAL_GET_CLASS</NAME>
#define AGS_PLAY_AUDIO_SIGNAL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_PLAY_AUDIO_SIGNAL, AgsPlayAudioSignalClass))
</MACRO>
<STRUCT>
<NAME>AgsPlayAudioSignal</NAME>
struct _AgsPlayAudioSignal
{
  AgsRecallAudioSignal recall_audio_signal;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlayAudioSignalClass</NAME>
struct _AgsPlayAudioSignalClass
{
  AgsRecallAudioSignalClass recall_audio_signal;
};
</STRUCT>
<FUNCTION>
<NAME>ags_play_audio_signal_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_audio_signal_new</NAME>
<RETURNS>AgsPlayAudioSignal * </RETURNS>
AgsAudioSignal *source, GObject *soundcard, guint audio_channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAY_AUDIO</NAME>
#define AGS_TYPE_PLAY_AUDIO                (ags_play_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAY_AUDIO</NAME>
#define AGS_PLAY_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAY_AUDIO, AgsPlayAudio))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_AUDIO_CLASS</NAME>
#define AGS_PLAY_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PLAY_AUDIO, AgsPlayAudio))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_AUDIO</NAME>
#define AGS_IS_PLAY_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PLAY_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_AUDIO_CLASS</NAME>
#define AGS_IS_PLAY_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PLAY_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_AUDIO_GET_CLASS</NAME>
#define AGS_PLAY_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_PLAY_AUDIO, AgsPlayAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsPlayAudio</NAME>
struct _AgsPlayAudio
{
  AgsRecallAudio recall_audio;

  AgsPort *muted;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlayAudioClass</NAME>
struct _AgsPlayAudioClass
{
  AgsRecallAudioClass recall_audio;
};
</STRUCT>
<FUNCTION>
<NAME>ags_play_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_audio_new</NAME>
<RETURNS>AgsPlayAudio * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MUTE_AUDIO</NAME>
#define AGS_TYPE_MUTE_AUDIO                (ags_mute_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MUTE_AUDIO</NAME>
#define AGS_MUTE_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MUTE_AUDIO, AgsMuteAudio))
</MACRO>
<MACRO>
<NAME>AGS_MUTE_AUDIO_CLASS</NAME>
#define AGS_MUTE_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MUTE_AUDIO, AgsMuteAudio))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTE_AUDIO</NAME>
#define AGS_IS_MUTE_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_MUTE_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTE_AUDIO_CLASS</NAME>
#define AGS_IS_MUTE_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MUTE_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_MUTE_AUDIO_GET_CLASS</NAME>
#define AGS_MUTE_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_MUTE_AUDIO, AgsMuteAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsMuteAudio</NAME>
struct _AgsMuteAudio
{
  AgsRecallAudio recall_audio;

  AgsPort *muted;
};
</STRUCT>
<STRUCT>
<NAME>AgsMuteAudioClass</NAME>
struct _AgsMuteAudioClass
{
  AgsRecallAudioClass recall_audio;
};
</STRUCT>
<FUNCTION>
<NAME>ags_mute_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_mute_audio_new</NAME>
<RETURNS>AgsMuteAudio * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PEAK_CHANNEL_RUN</NAME>
#define AGS_TYPE_PEAK_CHANNEL_RUN            (ags_peak_channel_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PEAK_CHANNEL_RUN</NAME>
#define AGS_PEAK_CHANNEL_RUN(obj)            (G_TYPE_CHECK_INSTANCE_CAST(obj, AGS_TYPE_PEAK_CHANNEL_RUN, AgsPeakChannelRun))
</MACRO>
<MACRO>
<NAME>AGS_PEAK_CHANNEL_RUN_CLASS</NAME>
#define AGS_PEAK_CHANNEL_RUN_CLASS(class)    (G_TYPE_CHECK_INSTANCE_CAST(class, AGS_TYPE_PEAK_CHANNEL_RUN, AgsPeakChannelRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PEAK_CHANNEL_RUN</NAME>
#define AGS_IS_PEAK_CHANNEL_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PEAK_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_PEAK_CHANNEL_RUN_CLASS</NAME>
#define AGS_IS_PEAK_CHANNEL_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_PEAK_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_PEAK_CHANNEL_RUN_GET_CLASS</NAME>
#define AGS_PEAK_CHANNEL_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PEAK_CHANNEL_RUN, AgsPeakChannelRunClass))
</MACRO>
<STRUCT>
<NAME>AgsPeakChannelRun</NAME>
struct _AgsPeakChannelRun
{
  AgsRecallChannelRun recall_channel_run;
};
</STRUCT>
<STRUCT>
<NAME>AgsPeakChannelRunClass</NAME>
struct _AgsPeakChannelRunClass
{
  AgsRecallChannelRunClass recall_channel_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_peak_channel_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_peak_channel_run_new</NAME>
<RETURNS>AgsPeakChannelRun * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COPY_CHANNEL_RUN</NAME>
#define AGS_TYPE_COPY_CHANNEL_RUN                (ags_copy_channel_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COPY_CHANNEL_RUN</NAME>
#define AGS_COPY_CHANNEL_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COPY_CHANNEL_RUN, AgsCopyChannelRun))
</MACRO>
<MACRO>
<NAME>AGS_COPY_CHANNEL_RUN_CLASS</NAME>
#define AGS_COPY_CHANNEL_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_COPY_CHANNEL_RUN, AgsCopyChannelRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_CHANNEL_RUN</NAME>
#define AGS_IS_COPY_CHANNEL_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_COPY_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_CHANNEL_RUN_CLASS</NAME>
#define AGS_IS_COPY_CHANNEL_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_COPY_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_COPY_CHANNEL_RUN_GET_CLASS</NAME>
#define AGS_COPY_CHANNEL_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_COPY_CHANNEL_RUN, AgsCopyChannelRunClass))
</MACRO>
<ENUM>
<NAME>AgsCopyChannelRunFlags</NAME>
typedef enum{
  AGS_COPY_CHANNEL_RUN_EXACT_LENGTH         = 1,
  AGS_COPY_CHANNEL_RUN_OMIT_FURTHER_ATTACK  = 1 << 1,
}AgsCopyChannelRunFlags;
</ENUM>
<STRUCT>
<NAME>AgsCopyChannelRun</NAME>
struct _AgsCopyChannelRun
{
  AgsRecallChannelRun recall_channel_run;

  guint flags;
};
</STRUCT>
<STRUCT>
<NAME>AgsCopyChannelRunClass</NAME>
struct _AgsCopyChannelRunClass
{
  AgsRecallChannelRunClass recall_channel_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_copy_channel_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_copy_channel_run_new</NAME>
<RETURNS>AgsCopyChannelRun * </RETURNS>
AgsChannel *destination, AgsChannel *source, GObject *soundcard 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_BUFFER_RECYCLING</NAME>
#define AGS_TYPE_BUFFER_RECYCLING                (ags_buffer_recycling_get_type())
</MACRO>
<MACRO>
<NAME>AGS_BUFFER_RECYCLING</NAME>
#define AGS_BUFFER_RECYCLING(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_BUFFER_RECYCLING, AgsBufferRecycling))
</MACRO>
<MACRO>
<NAME>AGS_BUFFER_RECYCLING_CLASS</NAME>
#define AGS_BUFFER_RECYCLING_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_BUFFER_RECYCLING, AgsBufferRecyclingClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_BUFFER_RECYCLING</NAME>
#define AGS_IS_BUFFER_RECYCLING(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_BUFFER_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_IS_BUFFER_RECYCLING_CLASS</NAME>
#define AGS_IS_BUFFER_RECYCLING_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_BUFFER_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_BUFFER_RECYCLING_GET_CLASS</NAME>
#define AGS_BUFFER_RECYCLING_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_BUFFER_RECYCLING, AgsBufferRecyclingClass))
</MACRO>
<STRUCT>
<NAME>AgsBufferRecycling</NAME>
struct _AgsBufferRecycling
{
  AgsRecallRecycling recall_recycling;
};
</STRUCT>
<STRUCT>
<NAME>AgsBufferRecyclingClass</NAME>
struct _AgsBufferRecyclingClass
{
  AgsRecallRecyclingClass recall_recycling;
};
</STRUCT>
<FUNCTION>
<NAME>ags_buffer_recycling_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_buffer_recycling_new</NAME>
<RETURNS>AgsBufferRecycling * </RETURNS>
AgsRecycling *recycling 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COUNT_BEATS_AUDIO</NAME>
#define AGS_TYPE_COUNT_BEATS_AUDIO                (ags_count_beats_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COUNT_BEATS_AUDIO</NAME>
#define AGS_COUNT_BEATS_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COUNT_BEATS_AUDIO, AgsCountBeatsAudio))
</MACRO>
<MACRO>
<NAME>AGS_COUNT_BEATS_AUDIO_CLASS</NAME>
#define AGS_COUNT_BEATS_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_COUNT_BEATS_AUDIO, AgsCountBeatsAudio))
</MACRO>
<MACRO>
<NAME>AGS_IS_COUNT_BEATS_AUDIO</NAME>
#define AGS_IS_COUNT_BEATS_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_COUNT_BEATS_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_COUNT_BEATS_AUDIO_CLASS</NAME>
#define AGS_IS_COUNT_BEATS_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_COUNT_BEATS_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_COUNT_BEATS_AUDIO_GET_CLASS</NAME>
#define AGS_COUNT_BEATS_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_COUNT_BEATS_AUDIO, AgsCountBeatsAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsCountBeatsAudio</NAME>
struct _AgsCountBeatsAudio
{
  AgsRecallAudio recall_audio;

  AgsPort *loop;

  AgsPort *notation_loop_start;
  AgsPort *notation_loop_end;
  AgsPort *sequencer_loop_start;
  AgsPort *sequencer_loop_end;
};
</STRUCT>
<STRUCT>
<NAME>AgsCountBeatsAudioClass</NAME>
struct _AgsCountBeatsAudioClass
{
  AgsRecallAudioClass recall_audio;
};
</STRUCT>
<FUNCTION>
<NAME>ags_count_beats_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_count_beats_audio_new</NAME>
<RETURNS>AgsCountBeatsAudio * </RETURNS>
gboolean loop 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PEAK_CHANNEL</NAME>
#define AGS_TYPE_PEAK_CHANNEL                (ags_peak_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PEAK_CHANNEL</NAME>
#define AGS_PEAK_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PEAK_CHANNEL, AgsPeakChannel))
</MACRO>
<MACRO>
<NAME>AGS_PEAK_CHANNEL_CLASS</NAME>
#define AGS_PEAK_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PEAK_CHANNEL, AgsPeakChannel))
</MACRO>
<MACRO>
<NAME>AGS_IS_PEAK_CHANNEL</NAME>
#define AGS_IS_PEAK_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PEAK_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_PEAK_CHANNEL_CLASS</NAME>
#define AGS_IS_PEAK_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PEAK_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_PEAK_CHANNEL_GET_CLASS</NAME>
#define AGS_PEAK_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_PEAK_CHANNEL, AgsPeakChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsPeakChannel</NAME>
struct _AgsPeakChannel
{
  AgsRecallChannel recall_channel;

  AgsPort *peak;
};
</STRUCT>
<STRUCT>
<NAME>AgsPeakChannelClass</NAME>
struct _AgsPeakChannelClass
{
  AgsRecallChannelClass recall_channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_peak_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_peak_channel_retrieve_peak</NAME>
<RETURNS>void  </RETURNS>
AgsPeakChannel *peak_channel, gboolean is_play 
</FUNCTION>
<FUNCTION>
<NAME>ags_peak_channel_new</NAME>
<RETURNS>AgsPeakChannel * </RETURNS>
AgsChannel *source 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COPY_RECYCLING</NAME>
#define AGS_TYPE_COPY_RECYCLING                (ags_copy_recycling_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COPY_RECYCLING</NAME>
#define AGS_COPY_RECYCLING(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COPY_RECYCLING, AgsCopyRecycling))
</MACRO>
<MACRO>
<NAME>AGS_COPY_RECYCLING_CLASS</NAME>
#define AGS_COPY_RECYCLING_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_COPY_RECYCLING, AgsCopyRecyclingClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_RECYCLING</NAME>
#define AGS_IS_COPY_RECYCLING(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_COPY_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_RECYCLING_CLASS</NAME>
#define AGS_IS_COPY_RECYCLING_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_COPY_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_COPY_RECYCLING_GET_CLASS</NAME>
#define AGS_COPY_RECYCLING_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_COPY_RECYCLING, AgsCopyRecyclingClass))
</MACRO>
<STRUCT>
<NAME>AgsCopyRecycling</NAME>
struct _AgsCopyRecycling
{
  AgsRecallRecycling recall_recycling;
};
</STRUCT>
<STRUCT>
<NAME>AgsCopyRecyclingClass</NAME>
struct _AgsCopyRecyclingClass
{
  AgsRecallRecyclingClass recall_recycling;
};
</STRUCT>
<FUNCTION>
<NAME>ags_copy_recycling_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_copy_recycling_new</NAME>
<RETURNS>AgsCopyRecycling * </RETURNS>
AgsRecycling *destination, AgsRecycling *source, GObject *soundcard 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAY_AUDIO_FILE</NAME>
#define AGS_TYPE_PLAY_AUDIO_FILE                (ags_play_audio_file_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAY_AUDIO_FILE</NAME>
#define AGS_PLAY_AUDIO_FILE(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAY_AUDIO_FILE, AgsPlayAudioFile))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_AUDIO_FILE_CLASS</NAME>
#define AGS_PLAY_AUDIO_FILE_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AgsPlayAudioFileClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_AUDIO_FILE</NAME>
#define AGS_IS_PLAY_AUDIO_FILE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PLAY_AUDIO_FILE))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_AUDIO_FILE_CLASS</NAME>
#define AGS_IS_PLAY_AUDIO_FILE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PLAY_AUDIO_FILE))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_AUDIO_FILE_GET_CLASS</NAME>
#define AGS_PLAY_AUDIO_FILE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_PLAY_AUDIO_FILE, AgsPlayAudioFileClass))
</MACRO>
<STRUCT>
<NAME>AgsPlayAudioFile</NAME>
struct _AgsPlayAudioFile
{
  AgsRecall recall;

  AgsAudioFile *audio_file;
  guint current_frame;

  GObject *soundcard;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlayAudioFileClass</NAME>
struct _AgsPlayAudioFileClass
{
  AgsRecallClass recall;
};
</STRUCT>
<FUNCTION>
<NAME>ags_play_audio_file_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_audio_file_new</NAME>
<RETURNS>AgsPlayAudioFile * </RETURNS>
AgsAudioFile *audio_file, GObject *soundcard 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COPY_PATTERN_AUDIO</NAME>
#define AGS_TYPE_COPY_PATTERN_AUDIO                (ags_copy_pattern_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COPY_PATTERN_AUDIO</NAME>
#define AGS_COPY_PATTERN_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COPY_PATTERN_AUDIO, AgsCopyPatternAudio))
</MACRO>
<MACRO>
<NAME>AGS_COPY_PATTERN_AUDIO_CLASS</NAME>
#define AGS_COPY_PATTERN_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_COPY_PATTERN_AUDIO, AgsCopyPatternAudio))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_PATTERN_AUDIO</NAME>
#define AGS_IS_COPY_PATTERN_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_COPY_PATTERN_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_PATTERN_AUDIO_CLASS</NAME>
#define AGS_IS_COPY_PATTERN_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_COPY_PATTERN_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_COPY_PATTERN_AUDIO_GET_CLASS</NAME>
#define AGS_COPY_PATTERN_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_COPY_PATTERN_AUDIO, AgsCopyPatternAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsCopyPatternAudio</NAME>
struct _AgsCopyPatternAudio
{
  AgsRecallAudio recall_audio;

  AgsPort *bank_index_0;
  AgsPort *bank_index_1;
};
</STRUCT>
<STRUCT>
<NAME>AgsCopyPatternAudioClass</NAME>
struct _AgsCopyPatternAudioClass
{
  AgsRecallAudioClass recall_audio;
};
</STRUCT>
<FUNCTION>
<NAME>ags_copy_pattern_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_copy_pattern_audio_new</NAME>
<RETURNS>AgsCopyPatternAudio * </RETURNS>
GObject *soundcard, gdouble tact, guint i, guint j 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COPY_PATTERN_CHANNEL</NAME>
#define AGS_TYPE_COPY_PATTERN_CHANNEL                (ags_copy_pattern_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COPY_PATTERN_CHANNEL</NAME>
#define AGS_COPY_PATTERN_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COPY_PATTERN_CHANNEL, AgsCopyPatternChannel))
</MACRO>
<MACRO>
<NAME>AGS_COPY_PATTERN_CHANNEL_CLASS</NAME>
#define AGS_COPY_PATTERN_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_COPY_PATTERN_CHANNEL, AgsCopyPatternChannel))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_PATTERN_CHANNEL</NAME>
#define AGS_IS_COPY_PATTERN_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_COPY_PATTERN_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_PATTERN_CHANNEL_CLASS</NAME>
#define AGS_IS_COPY_PATTERN_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_COPY_PATTERN_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_COPY_PATTERN_CHANNEL_GET_CLASS</NAME>
#define AGS_COPY_PATTERN_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_COPY_PATTERN_CHANNEL, AgsCopyPatternChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsCopyPatternChannel</NAME>
struct _AgsCopyPatternChannel
{
  AgsRecallChannel recall_channel;

  AgsPort *pattern;

  AgsPort *bank_index_0;
  AgsPort *bank_index_1;

  AgsPort *current_bit;
};
</STRUCT>
<STRUCT>
<NAME>AgsCopyPatternChannelClass</NAME>
struct _AgsCopyPatternChannelClass
{
  AgsRecallChannelClass recall_channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_copy_pattern_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_copy_pattern_channel_template_find_source_and_destination</NAME>
<RETURNS>GList * </RETURNS>
GList *recall, AgsChannel *destination, AgsChannel *source 
</FUNCTION>
<FUNCTION>
<NAME>ags_copy_pattern_channel_new</NAME>
<RETURNS>AgsCopyPatternChannel * </RETURNS>
AgsChannel *destination, AgsChannel *source, AgsPort *pattern 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAY_CHANNEL</NAME>
#define AGS_TYPE_PLAY_CHANNEL                (ags_play_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAY_CHANNEL</NAME>
#define AGS_PLAY_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAY_CHANNEL, AgsPlayChannel))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_CHANNEL_CLASS</NAME>
#define AGS_PLAY_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PLAY_CHANNEL, AgsPlayChannelClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_CHANNEL</NAME>
#define AGS_IS_PLAY_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PLAY_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_CHANNEL_CLASS</NAME>
#define AGS_IS_PLAY_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_PLAY_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_CHANNEL_GET_CLASS</NAME>
#define AGS_PLAY_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PLAY_CHANNEL, AgsPlayChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsPlayChannel</NAME>
struct _AgsPlayChannel
{
  AgsRecallChannel recall_channel;

  AgsPort *audio_channel;

  AgsPort *muted;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlayChannelClass</NAME>
struct _AgsPlayChannelClass
{
  AgsRecallChannelClass recall_channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_play_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_channel_new</NAME>
<RETURNS>AgsPlayChannel * </RETURNS>
GObject *soundcard, guint audio_channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COPY_PATTERN_AUDIO_RUN</NAME>
#define AGS_TYPE_COPY_PATTERN_AUDIO_RUN                (ags_copy_pattern_audio_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COPY_PATTERN_AUDIO_RUN</NAME>
#define AGS_COPY_PATTERN_AUDIO_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COPY_PATTERN_AUDIO_RUN, AgsCopyPatternAudioRun))
</MACRO>
<MACRO>
<NAME>AGS_COPY_PATTERN_AUDIO_RUN_CLASS</NAME>
#define AGS_COPY_PATTERN_AUDIO_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_COPY_PATTERN_AUDIO_RUN, AgsCopyPatternAudioRun))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_PATTERN_AUDIO_RUN</NAME>
#define AGS_IS_COPY_PATTERN_AUDIO_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_COPY_PATTERN_AUDIO_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_PATTERN_AUDIO_RUN_CLASS</NAME>
#define AGS_IS_COPY_PATTERN_AUDIO_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_COPY_PATTERN_AUDIO_RUN))
</MACRO>
<MACRO>
<NAME>AGS_COPY_PATTERN_AUDIO_RUN_GET_CLASS</NAME>
#define AGS_COPY_PATTERN_AUDIO_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_COPY_PATTERN_AUDIO_RUN, AgsCopyPatternAudioRunClass))
</MACRO>
<STRUCT>
<NAME>AgsCopyPatternAudioRun</NAME>
struct _AgsCopyPatternAudioRun
{
  AgsRecallAudioRun recall_audio_run;

  guint hide_ref;
  guint hide_ref_counter;

  AgsDelayAudioRun *delay_audio_run;
  AgsCountBeatsAudioRun *count_beats_audio_run;
};
</STRUCT>
<STRUCT>
<NAME>AgsCopyPatternAudioRunClass</NAME>
struct _AgsCopyPatternAudioRunClass
{
  AgsRecallAudioRunClass recall_audio_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_copy_pattern_audio_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_copy_pattern_audio_run_new</NAME>
<RETURNS>AgsCopyPatternAudioRun * </RETURNS>
AgsCountBeatsAudioRun *count_beats_audio_run 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_VOLUME_CHANNEL</NAME>
#define AGS_TYPE_VOLUME_CHANNEL                (ags_volume_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_VOLUME_CHANNEL</NAME>
#define AGS_VOLUME_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_VOLUME_CHANNEL, AgsVolumeChannel))
</MACRO>
<MACRO>
<NAME>AGS_VOLUME_CHANNEL_CLASS</NAME>
#define AGS_VOLUME_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_VOLUME_CHANNEL, AgsVolumeChannelClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_VOLUME_CHANNEL</NAME>
#define AGS_IS_VOLUME_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_VOLUME_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_VOLUME_CHANNEL_CLASS</NAME>
#define AGS_IS_VOLUME_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_VOLUME_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_VOLUME_CHANNEL_GET_CLASS</NAME>
#define AGS_VOLUME_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_VOLUME_CHANNEL, AgsVolumeChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsVolumeChannel</NAME>
struct _AgsVolumeChannel
{
  AgsRecallChannel recall_channel;

  AgsPort *volume;
};
</STRUCT>
<STRUCT>
<NAME>AgsVolumeChannelClass</NAME>
struct _AgsVolumeChannelClass
{
  AgsRecallChannelClass recall_channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_volume_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_volume_channel_new</NAME>
<RETURNS>AgsVolumeChannel * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAY_NOTATION_AUDIO_RUN</NAME>
#define AGS_TYPE_PLAY_NOTATION_AUDIO_RUN                (ags_play_notation_audio_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAY_NOTATION_AUDIO_RUN</NAME>
#define AGS_PLAY_NOTATION_AUDIO_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAY_NOTATION_AUDIO_RUN, AgsPlayNotationAudioRun))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_NOTATION_AUDIO_RUN_CLASS</NAME>
#define AGS_PLAY_NOTATION_AUDIO_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PLAY_NOTATION_AUDIO_RUN, AgsPlayNotationAudioRun))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_NOTATION_AUDIO_RUN</NAME>
#define AGS_IS_PLAY_NOTATION_AUDIO_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PLAY_NOTATION_AUDIO_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_NOTATION_AUDIO_RUN_CLASS</NAME>
#define AGS_IS_PLAY_NOTATION_AUDIO_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PLAY_NOTATION_AUDIO_RUN))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_NOTATION_AUDIO_RUN_GET_CLASS</NAME>
#define AGS_PLAY_NOTATION_AUDIO_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_PLAY_NOTATION_AUDIO_RUN, AgsPlayNotationAudioRunClass))
</MACRO>
<ENUM>
<NAME>AgsPlayNotationAudioRunFlags</NAME>
typedef enum{
  AGS_PLAY_NOTATION_AUDIO_RUN_DEFAULT  =  1,
}AgsPlayNotationAudioRunFlags;
</ENUM>
<STRUCT>
<NAME>AgsPlayNotationAudioRun</NAME>
struct _AgsPlayNotationAudioRun
{
  AgsRecallAudioRun recall;

  guint flags;

  AgsDelayAudioRun *delay_audio_run;
  gulong notation_alloc_input_handler;

  AgsCountBeatsAudioRun *count_beats_audio_run;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlayNotationAudioRunClass</NAME>
struct _AgsPlayNotationAudioRunClass
{
  AgsRecallAudioRunClass recall;
};
</STRUCT>
<FUNCTION>
<NAME>ags_play_notation_audio_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_notation_audio_run_new</NAME>
<RETURNS>AgsPlayNotationAudioRun * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_STREAM_CHANNEL_RUN</NAME>
#define AGS_TYPE_STREAM_CHANNEL_RUN                (ags_stream_channel_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_STREAM_CHANNEL_RUN</NAME>
#define AGS_STREAM_CHANNEL_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_STREAM_CHANNEL_RUN, AgsStreamChannelRun))
</MACRO>
<MACRO>
<NAME>AGS_STREAM_CHANNEL_RUN_CLASS</NAME>
#define AGS_STREAM_CHANNEL_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_STREAM_CHANNEL_RUN, AgsStreamChannelRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_STREAM_CHANNEL_RUN</NAME>
#define AGS_IS_STREAM_CHANNEL_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_STREAM_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_STREAM_CHANNEL_RUN_CLASS</NAME>
#define AGS_IS_STREAM_CHANNEL_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_STREAM_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_STREAM_CHANNEL_RUN_GET_CLASS</NAME>
#define AGS_STREAM_CHANNEL_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_STREAM_CHANNEL_RUN, AgsStreamChannelRunClass))
</MACRO>
<STRUCT>
<NAME>AgsStreamChannelRun</NAME>
struct _AgsStreamChannelRun
{
  AgsRecallChannelRun recall_channel_run;
};
</STRUCT>
<STRUCT>
<NAME>AgsStreamChannelRunClass</NAME>
struct _AgsStreamChannelRunClass
{
  AgsRecallChannelRunClass recall_channel_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_stream_channel_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_stream_channel_run_new</NAME>
<RETURNS>AgsStreamChannelRun * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LOOP_CHANNEL_RUN</NAME>
#define AGS_TYPE_LOOP_CHANNEL_RUN                (ags_loop_channel_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LOOP_CHANNEL_RUN</NAME>
#define AGS_LOOP_CHANNEL_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LOOP_CHANNEL_RUN, AgsLoopChannelRun))
</MACRO>
<MACRO>
<NAME>AGS_LOOP_CHANNEL_RUN_CLASS</NAME>
#define AGS_LOOP_CHANNEL_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LOOP_CHANNEL_RUN, AgsLoopChannelRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LOOP_CHANNEL_RUN</NAME>
#define AGS_IS_LOOP_CHANNEL_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LOOP_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_LOOP_CHANNEL_RUN_CLASS</NAME>
#define AGS_IS_LOOP_CHANNEL_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LOOP_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_LOOP_CHANNEL_RUN_GET_CLASS</NAME>
#define AGS_LOOP_CHANNEL_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_LOOP_CHANNEL_RUN, AgsLoopChannelRunClass))
</MACRO>
<STRUCT>
<NAME>AgsLoopChannelRun</NAME>
struct _AgsLoopChannelRun
{
  AgsRecallChannelRun recall_channel_run;

  AgsCountBeatsAudioRun *count_beats_audio_run;
  gulong start_handler;
  gulong loop_handler;
  gulong stop_handler;
};
</STRUCT>
<STRUCT>
<NAME>AgsLoopChannelRunClass</NAME>
struct _AgsLoopChannelRunClass
{
  AgsRecallChannelRunClass recall_channel_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_loop_channel_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_loop_channel_run_new</NAME>
<RETURNS>AgsLoopChannelRun * </RETURNS>
AgsChannel *channel, AgsCountBeatsAudioRun *count_beats_audio_run, gboolean is_template 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_VOLUME_CHANNEL_RUN</NAME>
#define AGS_TYPE_VOLUME_CHANNEL_RUN            (ags_volume_channel_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_VOLUME_CHANNEL_RUN</NAME>
#define AGS_VOLUME_CHANNEL_RUN(obj)            (G_TYPE_CHECK_INSTANCE_CAST(obj, AGS_TYPE_VOLUME_CHANNEL_RUN, AgsVolumeChannelRun))
</MACRO>
<MACRO>
<NAME>AGS_VOLUME_CHANNEL_RUN_CLASS</NAME>
#define AGS_VOLUME_CHANNEL_RUN_CLASS(class)    (G_TYPE_CHECK_INSTANCE_CAST(class, AGS_TYPE_VOLUME_CHANNEL_RUN, AgsVolumeChannelRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_VOLUME_CHANNEL_RUN</NAME>
#define AGS_IS_VOLUME_CHANNEL_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_VOLUME_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_VOLUME_CHANNEL_RUN_CLASS</NAME>
#define AGS_IS_VOLUME_CHANNEL_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_VOLUME_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_VOLUME_CHANNEL_RUN_GET_CLASS</NAME>
#define AGS_VOLUME_CHANNEL_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_VOLUME_CHANNEL_RUN, AgsVolumeChannelRunClass))
</MACRO>
<STRUCT>
<NAME>AgsVolumeChannelRun</NAME>
struct _AgsVolumeChannelRun
{
  AgsRecallChannelRun recall_channel_run;
};
</STRUCT>
<STRUCT>
<NAME>AgsVolumeChannelRunClass</NAME>
struct _AgsVolumeChannelRunClass
{
  AgsRecallChannelRunClass recall_channel_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_volume_channel_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_volume_channel_run_new</NAME>
<RETURNS>AgsVolumeChannelRun * </RETURNS>
AgsChannel *channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAY_NOTATION_AUDIO</NAME>
#define AGS_TYPE_PLAY_NOTATION_AUDIO                (ags_play_notation_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAY_NOTATION_AUDIO</NAME>
#define AGS_PLAY_NOTATION_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAY_NOTATION_AUDIO, AgsPlayNotationAudio))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_NOTATION_AUDIO_CLASS</NAME>
#define AGS_PLAY_NOTATION_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PLAY_NOTATION_AUDIO, AgsPlayNotationAudio))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_NOTATION_AUDIO</NAME>
#define AGS_IS_PLAY_NOTATION_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PLAY_NOTATION_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_NOTATION_AUDIO_CLASS</NAME>
#define AGS_IS_PLAY_NOTATION_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PLAY_NOTATION_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_NOTATION_AUDIO_GET_CLASS</NAME>
#define AGS_PLAY_NOTATION_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_PLAY_NOTATION_AUDIO, AgsPlayNotationAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsPlayNotationAudio</NAME>
struct _AgsPlayNotationAudio
{
  AgsRecallAudio recall_audio;

  AgsPort *notation;
  AgsPort *monotonic;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlayNotationAudioClass</NAME>
struct _AgsPlayNotationAudioClass
{
  AgsRecallAudioClass recall_audio;
};
</STRUCT>
<FUNCTION>
<NAME>ags_play_notation_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_notation_audio_new</NAME>
<RETURNS>AgsPlayNotationAudio * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COPY_NOTATION_AUDIO</NAME>
#define AGS_TYPE_COPY_NOTATION_AUDIO                (ags_copy_notation_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COPY_NOTATION_AUDIO</NAME>
#define AGS_COPY_NOTATION_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COPY_NOTATION_AUDIO, AgsCopyNotationAudio))
</MACRO>
<MACRO>
<NAME>AGS_COPY_NOTATION_AUDIO_CLASS</NAME>
#define AGS_COPY_NOTATION_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_COPY_NOTATION_AUDIO, AgsCopyNotationAudio))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_NOTATION_AUDIO</NAME>
#define AGS_IS_COPY_NOTATION_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_COPY_NOTATION_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_NOTATION_AUDIO_CLASS</NAME>
#define AGS_IS_COPY_NOTATION_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_COPY_NOTATION_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_COPY_NOTATION_AUDIO_GET_CLASS</NAME>
#define AGS_COPY_NOTATION_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_COPY_NOTATION_AUDIO, AgsCopyNotationAudioClass))
</MACRO>
<ENUM>
<NAME>AgsCopyNotationAudioFlags</NAME>
typedef enum{
  AGS_COPY_NOTATION_AUDIO_FIT_AUDIO_SIGNAL  = 1,
}AgsCopyNotationAudioFlags;
</ENUM>
<STRUCT>
<NAME>AgsCopyNotationAudio</NAME>
struct _AgsCopyNotationAudio
{
  AgsRecallAudio recall_audio;

  guint flags;

  GObject *soundcard;

  AgsNotation *notation;
  guint audio_channel;
};
</STRUCT>
<STRUCT>
<NAME>AgsCopyNotationAudioClass</NAME>
struct _AgsCopyNotationAudioClass
{
  AgsRecallAudioClass recall_audio;
};
</STRUCT>
<FUNCTION>
<NAME>ags_copy_notation_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_copy_notation_audio_new</NAME>
<RETURNS>AgsCopyNotationAudio * </RETURNS>
GObject *soundcard, AgsNotation *notation, guint audio_channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COPY_CHANNEL</NAME>
#define AGS_TYPE_COPY_CHANNEL                (ags_copy_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COPY_CHANNEL</NAME>
#define AGS_COPY_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COPY_CHANNEL, AgsCopyChannel))
</MACRO>
<MACRO>
<NAME>AGS_COPY_CHANNEL_CLASS</NAME>
#define AGS_COPY_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_COPY_CHANNEL, AgsCopyChannel))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_CHANNEL</NAME>
#define AGS_IS_COPY_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_COPY_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_CHANNEL_CLASS</NAME>
#define AGS_IS_COPY_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_COPY_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_COPY_CHANNEL_GET_CLASS</NAME>
#define AGS_COPY_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_COPY_CHANNEL, AgsCopyChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsCopyChannel</NAME>
struct _AgsCopyChannel
{
  AgsRecallChannel recall_channel;

  AgsPort *muted;
};
</STRUCT>
<STRUCT>
<NAME>AgsCopyChannelClass</NAME>
struct _AgsCopyChannelClass
{
  AgsRecallChannelClass recall_channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_copy_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_copy_channel_new</NAME>
<RETURNS>AgsCopyChannel * </RETURNS>
AgsChannel *destination, AgsChannel *source 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MUTE_CHANNEL</NAME>
#define AGS_TYPE_MUTE_CHANNEL                (ags_mute_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MUTE_CHANNEL</NAME>
#define AGS_MUTE_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MUTE_CHANNEL, AgsMuteChannel))
</MACRO>
<MACRO>
<NAME>AGS_MUTE_CHANNEL_CLASS</NAME>
#define AGS_MUTE_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MUTE_CHANNEL, AgsMuteChannel))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTE_CHANNEL</NAME>
#define AGS_IS_MUTE_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_MUTE_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTE_CHANNEL_CLASS</NAME>
#define AGS_IS_MUTE_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MUTE_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_MUTE_CHANNEL_GET_CLASS</NAME>
#define AGS_MUTE_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_MUTE_CHANNEL, AgsMuteChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsMuteChannel</NAME>
struct _AgsMuteChannel
{
  AgsRecallChannel recall_channel;

  AgsPort *muted;
};
</STRUCT>
<STRUCT>
<NAME>AgsMuteChannelClass</NAME>
struct _AgsMuteChannelClass
{
  AgsRecallChannelClass recall_channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_mute_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_mute_channel_new</NAME>
<RETURNS>AgsMuteChannel * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAY_CHANNEL_RUN_MASTER</NAME>
#define AGS_TYPE_PLAY_CHANNEL_RUN_MASTER                (ags_play_channel_run_master_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAY_CHANNEL_RUN_MASTER</NAME>
#define AGS_PLAY_CHANNEL_RUN_MASTER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAY_CHANNEL_RUN_MASTER, AgsPlayChannelRunMaster))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_CHANNEL_RUN_MASTER_CLASS</NAME>
#define AGS_PLAY_CHANNEL_RUN_MASTER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PLAY_CHANNEL_RUN_MASTER, AgsPlayChannelRunMasterClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_CHANNEL_RUN_MASTER</NAME>
#define AGS_IS_PLAY_CHANNEL_RUN_MASTER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PLAY_CHANNEL_RUN_MASTER))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_CHANNEL_RUN_MASTER_CLASS</NAME>
#define AGS_IS_PLAY_CHANNEL_RUN_MASTER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_PLAY_CHANNEL_RUN_MASTER))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_CHANNEL_RUN_MASTER_GET_CLASS</NAME>
#define AGS_PLAY_CHANNEL_RUN_MASTER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PLAY_CHANNEL_RUN_MASTER, AgsPlayChannelRunMasterClass))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_CHANNEL_RUN_MASTER_STREAMER</NAME>
#define AGS_PLAY_CHANNEL_RUN_MASTER_STREAMER(strct)     ((AgsPlayChannelRunMasterStreamer *)(strct))
</MACRO>
<ENUM>
<NAME>AgsPlayChannelRunMasterFlags</NAME>
typedef enum{
  AGS_PLAY_CHANNEL_RUN_MASTER_TERMINATING        = 1,
}AgsPlayChannelRunMasterFlags;
</ENUM>
<STRUCT>
<NAME>AgsPlayChannelRunMaster</NAME>
struct _AgsPlayChannelRunMaster
{
  AgsRecallChannelRun recall_channel_run;

  guint flags;

  GList *streamer;

  gulong source_recycling_changed_handler;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlayChannelRunMasterClass</NAME>
struct _AgsPlayChannelRunMasterClass
{
  AgsRecallChannelRunClass recall_channel_run;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlayChannelRunMasterStreamer</NAME>
struct _AgsPlayChannelRunMasterStreamer
{
  AgsPlayChannelRunMaster *play_channel_run_master;

  AgsStreamChannelRun *stream_channel_run;
  gulong done_handler;
};
</STRUCT>
<FUNCTION>
<NAME>ags_play_channel_run_master_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_channel_run_master_streamer_alloc</NAME>
<RETURNS>AgsPlayChannelRunMasterStreamer * </RETURNS>
AgsPlayChannelRunMaster *play_channel_run_master, AgsStreamChannelRun *stream_channel_run 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_channel_run_master_find_streamer</NAME>
<RETURNS>GList * </RETURNS>
GList *list, AgsStreamChannelRun *stream_channel_run 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_channel_run_master_new</NAME>
<RETURNS>AgsPlayChannelRunMaster * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COPY_AUDIO_SIGNAL</NAME>
#define AGS_TYPE_COPY_AUDIO_SIGNAL                (ags_copy_audio_signal_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COPY_AUDIO_SIGNAL</NAME>
#define AGS_COPY_AUDIO_SIGNAL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COPY_AUDIO_SIGNAL, AgsCopyAudioSignal))
</MACRO>
<MACRO>
<NAME>AGS_COPY_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_COPY_AUDIO_SIGNAL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_COPY_AUDIO_SIGNAL, AgsCopyAudioSignalClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_AUDIO_SIGNAL</NAME>
#define AGS_IS_COPY_AUDIO_SIGNAL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_COPY_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_IS_COPY_AUDIO_SIGNAL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_COPY_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_COPY_AUDIO_SIGNAL_GET_CLASS</NAME>
#define AGS_COPY_AUDIO_SIGNAL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_COPY_AUDIO_SIGNAL, AgsCopyAudioSignalClass))
</MACRO>
<STRUCT>
<NAME>AgsCopyAudioSignal</NAME>
struct _AgsCopyAudioSignal
{
  AgsRecallAudioSignal recall_audio_signal;
};
</STRUCT>
<STRUCT>
<NAME>AgsCopyAudioSignalClass</NAME>
struct _AgsCopyAudioSignalClass
{
  AgsRecallAudioSignalClass recall_audio_signal;
};
</STRUCT>
<FUNCTION>
<NAME>ags_copy_audio_signal_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_copy_audio_signal_new</NAME>
<RETURNS>AgsCopyAudioSignal * </RETURNS>
AgsAudioSignal *destination, AgsAudioSignal *source, GObject *soundcard, guint attack 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_BUFFER_AUDIO_SIGNAL</NAME>
#define AGS_TYPE_BUFFER_AUDIO_SIGNAL                (ags_buffer_audio_signal_get_type())
</MACRO>
<MACRO>
<NAME>AGS_BUFFER_AUDIO_SIGNAL</NAME>
#define AGS_BUFFER_AUDIO_SIGNAL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_BUFFER_AUDIO_SIGNAL, AgsBufferAudioSignal))
</MACRO>
<MACRO>
<NAME>AGS_BUFFER_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_BUFFER_AUDIO_SIGNAL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_BUFFER_AUDIO_SIGNAL, AgsBufferAudioSignalClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_BUFFER_AUDIO_SIGNAL</NAME>
#define AGS_IS_BUFFER_AUDIO_SIGNAL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_BUFFER_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_IS_BUFFER_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_IS_BUFFER_AUDIO_SIGNAL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_BUFFER_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_BUFFER_AUDIO_SIGNAL_GET_CLASS</NAME>
#define AGS_BUFFER_AUDIO_SIGNAL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_BUFFER_AUDIO_SIGNAL, AgsBufferAudioSignalClass))
</MACRO>
<STRUCT>
<NAME>AgsBufferAudioSignal</NAME>
struct _AgsBufferAudioSignal
{
  AgsRecallAudioSignal recall_audio_signal;
};
</STRUCT>
<STRUCT>
<NAME>AgsBufferAudioSignalClass</NAME>
struct _AgsBufferAudioSignalClass
{
  AgsRecallAudioSignalClass recall_audio_signal;
};
</STRUCT>
<FUNCTION>
<NAME>ags_buffer_audio_signal_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_buffer_audio_signal_new</NAME>
<RETURNS>AgsBufferAudioSignal * </RETURNS>
AgsAudioSignal *audio_signal 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_STREAM_RECYCLING</NAME>
#define AGS_TYPE_STREAM_RECYCLING                (ags_stream_recycling_get_type())
</MACRO>
<MACRO>
<NAME>AGS_STREAM_RECYCLING</NAME>
#define AGS_STREAM_RECYCLING(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_STREAM_RECYCLING, AgsStreamRecycling))
</MACRO>
<MACRO>
<NAME>AGS_STREAM_RECYCLING_CLASS</NAME>
#define AGS_STREAM_RECYCLING_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_STREAM_RECYCLING, AgsStreamRecyclingClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_STREAM_RECYCLING</NAME>
#define AGS_IS_STREAM_RECYCLING(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_STREAM_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_IS_STREAM_RECYCLING_CLASS</NAME>
#define AGS_IS_STREAM_RECYCLING_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_STREAM_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_STREAM_RECYCLING_GET_CLASS</NAME>
#define AGS_STREAM_RECYCLING_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_STREAM_RECYCLING, AgsStreamRecyclingClass))
</MACRO>
<STRUCT>
<NAME>AgsStreamRecycling</NAME>
struct _AgsStreamRecycling
{
  AgsRecallRecycling recall_recycling;
};
</STRUCT>
<STRUCT>
<NAME>AgsStreamRecyclingClass</NAME>
struct _AgsStreamRecyclingClass
{
  AgsRecallRecyclingClass recall_recycling;
};
</STRUCT>
<FUNCTION>
<NAME>ags_stream_recycling_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_stream_recycling_new</NAME>
<RETURNS>AgsStreamRecycling * </RETURNS>
AgsRecycling *recycling 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_BUFFER_CHANNEL</NAME>
#define AGS_TYPE_BUFFER_CHANNEL                (ags_buffer_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_BUFFER_CHANNEL</NAME>
#define AGS_BUFFER_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_BUFFER_CHANNEL, AgsBufferChannel))
</MACRO>
<MACRO>
<NAME>AGS_BUFFER_CHANNEL_CLASS</NAME>
#define AGS_BUFFER_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_BUFFER_CHANNEL, AgsBufferChannelClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_BUFFER_CHANNEL</NAME>
#define AGS_IS_BUFFER_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_BUFFER_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_BUFFER_CHANNEL_CLASS</NAME>
#define AGS_IS_BUFFER_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_BUFFER_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_BUFFER_CHANNEL_GET_CLASS</NAME>
#define AGS_BUFFER_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_BUFFER_CHANNEL, AgsBufferChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsBufferChannel</NAME>
struct _AgsBufferChannel
{
  AgsRecallChannel recall_channel;

  AgsPort *muted;
};
</STRUCT>
<STRUCT>
<NAME>AgsBufferChannelClass</NAME>
struct _AgsBufferChannelClass
{
  AgsRecallChannelClass recall_channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_buffer_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_buffer_channel_new</NAME>
<RETURNS>AgsBufferChannel * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COPY_PATTERN_CHANNEL_RUN</NAME>
#define AGS_TYPE_COPY_PATTERN_CHANNEL_RUN                (ags_copy_pattern_channel_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COPY_PATTERN_CHANNEL_RUN</NAME>
#define AGS_COPY_PATTERN_CHANNEL_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COPY_PATTERN_CHANNEL_RUN, AgsCopyPatternChannelRun))
</MACRO>
<MACRO>
<NAME>AGS_COPY_PATTERN_CHANNEL_RUN_CLASS</NAME>
#define AGS_COPY_PATTERN_CHANNEL_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_COPY_PATTERN_CHANNEL_RUN, AgsCopyPatternChannelRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_PATTERN_CHANNEL_RUN</NAME>
#define AGS_IS_COPY_PATTERN_CHANNEL_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_COPY_PATTERN_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_PATTERN_CHANNEL_RUN_CLASS</NAME>
#define AGS_IS_COPY_PATTERN_CHANNEL_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_COPY_PATTERN_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_COPY_PATTERN_CHANNEL_RUN_GET_CLASS</NAME>
#define AGS_COPY_PATTERN_CHANNEL_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_COPY_PATTERN_CHANNEL_RUN, AgsCopyPatternChannelRunClass))
</MACRO>
<STRUCT>
<NAME>AgsCopyPatternChannelRun</NAME>
struct _AgsCopyPatternChannelRun
{
  AgsRecallChannelRun recall_channel_run;

  gulong sequencer_alloc_handler;
};
</STRUCT>
<STRUCT>
<NAME>AgsCopyPatternChannelRunClass</NAME>
struct _AgsCopyPatternChannelRunClass
{
  AgsRecallChannelRunClass recall_channel_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_copy_pattern_channel_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_copy_pattern_channel_run_new</NAME>
<RETURNS>AgsCopyPatternChannelRun * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAY_RECYCLING</NAME>
#define AGS_TYPE_PLAY_RECYCLING                (ags_play_recycling_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAY_RECYCLING</NAME>
#define AGS_PLAY_RECYCLING(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAY_RECYCLING, AgsPlayRecycling))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_RECYCLING_CLASS</NAME>
#define AGS_PLAY_RECYCLING_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PLAY_RECYCLING, AgsPlayRecyclingClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_RECYCLING</NAME>
#define AGS_IS_PLAY_RECYCLING(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PLAY_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_RECYCLING_CLASS</NAME>
#define AGS_IS_PLAY_RECYCLING_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PLAY_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_RECYCLING_GET_CLASS</NAME>
#define AGS_PLAY_RECYCLING_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_PLAY_RECYCLING, AgsPlayRecyclingClass))
</MACRO>
<STRUCT>
<NAME>AgsPlayRecycling</NAME>
struct _AgsPlayRecycling
{
  AgsRecallRecycling recall_recycling;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlayRecyclingClass</NAME>
struct _AgsPlayRecyclingClass
{
  AgsRecallRecyclingClass recall_recycling;
};
</STRUCT>
<FUNCTION>
<NAME>ags_play_recycling_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_recycling_new</NAME>
<RETURNS>AgsPlayRecycling * </RETURNS>
AgsRecycling *source, GObject *soundcard, guint audio_channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAY_PATTERN</NAME>
#define AGS_TYPE_PLAY_PATTERN             (ags_play_pattern_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAY_PATTERN</NAME>
#define AGS_PLAY_PATTERN(obj)             (G_TYPE_CHECK_INSTANCE_CAST(obj, AGS_TYPE_PLAY_PATTERN, AgsPlayPattern))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_PATTERN_CLASS</NAME>
#define AGS_PLAY_PATTERN_CLASS(class)     (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_PLAY_PATTERN, AgsPlayPattern))
</MACRO>
<STRUCT>
<NAME>AgsPlayPattern</NAME>
struct _AgsPlayPattern{
  AgsRecall recall;

  //  AgsDelay *delay;

  AgsChannel *channel;
  AgsPattern *pattern;

  guint i;
  guint j;
  guint bit;
  guint length;

  gboolean loop;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlayPatternClass</NAME>
struct _AgsPlayPatternClass{
  AgsRecallClass recall;
};
</STRUCT>
<FUNCTION>
<NAME>ags_play_pattern_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_pattern_connect</NAME>
<RETURNS>void  </RETURNS>
AgsPlayPattern *play_pattern 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_STREAM_AUDIO_SIGNAL</NAME>
#define AGS_TYPE_STREAM_AUDIO_SIGNAL                (ags_stream_audio_signal_get_type())
</MACRO>
<MACRO>
<NAME>AGS_STREAM_AUDIO_SIGNAL</NAME>
#define AGS_STREAM_AUDIO_SIGNAL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_STREAM_AUDIO_SIGNAL, AgsStreamAudioSignal))
</MACRO>
<MACRO>
<NAME>AGS_STREAM_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_STREAM_AUDIO_SIGNAL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_STREAM_AUDIO_SIGNAL, AgsStreamAudioSignalClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_STREAM_AUDIO_SIGNAL</NAME>
#define AGS_IS_STREAM_AUDIO_SIGNAL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_STREAM_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_IS_STREAM_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_IS_STREAM_AUDIO_SIGNAL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_STREAM_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_STREAM_AUDIO_SIGNAL_GET_CLASS</NAME>
#define AGS_STREAM_AUDIO_SIGNAL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_STREAM_AUDIO_SIGNAL, AgsStreamAudioSignalClass))
</MACRO>
<STRUCT>
<NAME>AgsStreamAudioSignal</NAME>
struct _AgsStreamAudioSignal
{
  AgsRecallAudioSignal recall_audio_signal;
};
</STRUCT>
<STRUCT>
<NAME>AgsStreamAudioSignalClass</NAME>
struct _AgsStreamAudioSignalClass
{
  AgsRecallAudioSignalClass recall_audio_signal;
};
</STRUCT>
<FUNCTION>
<NAME>ags_stream_audio_signal_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_stream_audio_signal_new</NAME>
<RETURNS>AgsStreamAudioSignal * </RETURNS>
AgsAudioSignal *audio_signal 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MUTE_AUDIO_SIGNAL</NAME>
#define AGS_TYPE_MUTE_AUDIO_SIGNAL                (ags_mute_audio_signal_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MUTE_AUDIO_SIGNAL</NAME>
#define AGS_MUTE_AUDIO_SIGNAL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MUTE_AUDIO_SIGNAL, AgsMuteAudioSignal))
</MACRO>
<MACRO>
<NAME>AGS_MUTE_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_MUTE_AUDIO_SIGNAL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MUTE_AUDIO_SIGNAL, AgsMuteAudioSignalClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTE_AUDIO_SIGNAL</NAME>
#define AGS_IS_MUTE_AUDIO_SIGNAL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_MUTE_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTE_AUDIO_SIGNAL_CLASS</NAME>
#define AGS_IS_MUTE_AUDIO_SIGNAL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MUTE_AUDIO_SIGNAL))
</MACRO>
<MACRO>
<NAME>AGS_MUTE_AUDIO_SIGNAL_GET_CLASS</NAME>
#define AGS_MUTE_AUDIO_SIGNAL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_MUTE_AUDIO_SIGNAL, AgsMuteAudioSignalClass))
</MACRO>
<STRUCT>
<NAME>AgsMuteAudioSignal</NAME>
struct _AgsMuteAudioSignal
{
  AgsRecallAudioSignal recall_audio_signal;
};
</STRUCT>
<STRUCT>
<NAME>AgsMuteAudioSignalClass</NAME>
struct _AgsMuteAudioSignalClass
{
  AgsRecallAudioSignalClass recall_audio_signal;
};
</STRUCT>
<FUNCTION>
<NAME>ags_mute_audio_signal_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_mute_audio_signal_new</NAME>
<RETURNS>AgsMuteAudioSignal * </RETURNS>
AgsAudioSignal *source 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_STREAM_CHANNEL</NAME>
#define AGS_TYPE_STREAM_CHANNEL                (ags_stream_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_STREAM_CHANNEL</NAME>
#define AGS_STREAM_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_STREAM_CHANNEL, AgsStreamChannel))
</MACRO>
<MACRO>
<NAME>AGS_STREAM_CHANNEL_CLASS</NAME>
#define AGS_STREAM_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_STREAM_CHANNEL, AgsStreamChannelClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_STREAM_CHANNEL</NAME>
#define AGS_IS_STREAM_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_STREAM_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_STREAM_CHANNEL_CLASS</NAME>
#define AGS_IS_STREAM_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_STREAM_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_STREAM_CHANNEL_GET_CLASS</NAME>
#define AGS_STREAM_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_STREAM_CHANNEL, AgsStreamChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsStreamChannel</NAME>
struct _AgsStreamChannel
{
  AgsRecallChannel recall_channel;

  AgsPort *auto_sense;
};
</STRUCT>
<STRUCT>
<NAME>AgsStreamChannelClass</NAME>
struct _AgsStreamChannelClass
{
  AgsRecallChannelClass recall_channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_stream_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_stream_channel_new</NAME>
<RETURNS>AgsStreamChannel * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COUNT_BEATS_AUDIO_RUN</NAME>
#define AGS_TYPE_COUNT_BEATS_AUDIO_RUN                (ags_count_beats_audio_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COUNT_BEATS_AUDIO_RUN</NAME>
#define AGS_COUNT_BEATS_AUDIO_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COUNT_BEATS_AUDIO_RUN, AgsCountBeatsAudioRun))
</MACRO>
<MACRO>
<NAME>AGS_COUNT_BEATS_AUDIO_RUN_CLASS</NAME>
#define AGS_COUNT_BEATS_AUDIO_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_COUNT_BEATS_AUDIO_RUN, AgsCountBeatsAudioRun))
</MACRO>
<MACRO>
<NAME>AGS_IS_COUNT_BEATS_AUDIO_RUN</NAME>
#define AGS_IS_COUNT_BEATS_AUDIO_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_COUNT_BEATS_AUDIO_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_COUNT_BEATS_AUDIO_RUN_CLASS</NAME>
#define AGS_IS_COUNT_BEATS_AUDIO_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_COUNT_BEATS_AUDIO_RUN))
</MACRO>
<MACRO>
<NAME>AGS_COUNT_BEATS_AUDIO_RUN_GET_CLASS</NAME>
#define AGS_COUNT_BEATS_AUDIO_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_COUNT_BEATS_AUDIO_RUN, AgsCountBeatsAudioRunClass))
</MACRO>
<STRUCT>
<NAME>AgsCountBeatsAudioRun</NAME>
struct _AgsCountBeatsAudioRun
{
  AgsRecallAudioRun recall_audio_run;

  gboolean first_run;

  guint notation_counter;
  guint sequencer_counter;

  guint recall_ref;

  guint hide_ref;
  guint notation_hide_ref_counter;
  guint sequencer_hide_ref_counter;

  gulong sequencer_alloc_output_handler;
  gulong sequencer_count_handler;

  gulong notation_alloc_output_handler;
  gulong notation_count_handler;

  AgsDelayAudioRun *delay_audio_run;
};
</STRUCT>
<STRUCT>
<NAME>AgsCountBeatsAudioRunClass</NAME>
struct _AgsCountBeatsAudioRunClass
{
  AgsRecallAudioRunClass recall_audio_run;
  
  void (*notation_start)(AgsCountBeatsAudioRun *count_beats_audio_run,
			 guint run_order);
  void (*notation_loop)(AgsCountBeatsAudioRun *count_beats_audio_run,
			guint run_order);
  void (*notation_stop)(AgsCountBeatsAudioRun *count_beats_audio_run,
			guint run_order);
  
  void (*sequencer_start)(AgsCountBeatsAudioRun *count_beats_audio_run,
			  guint run_order);
  void (*sequencer_loop)(AgsCountBeatsAudioRun *count_beats_audio_run,
			 guint run_order);
  void (*sequencer_stop)(AgsCountBeatsAudioRun *count_beats_audio_run,
			 guint run_order);
};
</STRUCT>
<FUNCTION>
<NAME>ags_count_beats_audio_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_count_beats_audio_run_notation_start</NAME>
<RETURNS>void  </RETURNS>
AgsCountBeatsAudioRun *count_beats_audio_run, guint run_order 
</FUNCTION>
<FUNCTION>
<NAME>ags_count_beats_audio_run_notation_loop</NAME>
<RETURNS>void  </RETURNS>
AgsCountBeatsAudioRun *count_beats_audio_run, guint run_order 
</FUNCTION>
<FUNCTION>
<NAME>ags_count_beats_audio_run_notation_stop</NAME>
<RETURNS>void  </RETURNS>
AgsCountBeatsAudioRun *count_beats_audio_run, guint run_order 
</FUNCTION>
<FUNCTION>
<NAME>ags_count_beats_audio_run_sequencer_start</NAME>
<RETURNS>void  </RETURNS>
AgsCountBeatsAudioRun *count_beats_audio_run, guint run_order 
</FUNCTION>
<FUNCTION>
<NAME>ags_count_beats_audio_run_sequencer_loop</NAME>
<RETURNS>void  </RETURNS>
AgsCountBeatsAudioRun *count_beats_audio_run, guint run_order 
</FUNCTION>
<FUNCTION>
<NAME>ags_count_beats_audio_run_sequencer_stop</NAME>
<RETURNS>void  </RETURNS>
AgsCountBeatsAudioRun *count_beats_audio_run, guint run_order 
</FUNCTION>
<FUNCTION>
<NAME>ags_count_beats_audio_run_new</NAME>
<RETURNS>AgsCountBeatsAudioRun * </RETURNS>
AgsDelayAudioRun *delay_audio_run 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_COPY_NOTATION_AUDIO_RUN</NAME>
#define AGS_TYPE_COPY_NOTATION_AUDIO_RUN                (ags_copy_notation_audio_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_COPY_NOTATION_AUDIO_RUN</NAME>
#define AGS_COPY_NOTATION_AUDIO_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_COPY_NOTATION_AUDIO_RUN, AgsCopyNotationAudioRun))
</MACRO>
<MACRO>
<NAME>AGS_COPY_NOTATION_AUDIO_RUN_CLASS</NAME>
#define AGS_COPY_NOTATION_AUDIO_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_COPY_NOTATION_AUDIO_RUN, AgsCopyNotationAudioRun))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_NOTATION_AUDIO_RUN</NAME>
#define AGS_IS_COPY_NOTATION_AUDIO_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_COPY_NOTATION_AUDIO_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_COPY_NOTATION_AUDIO_RUN_CLASS</NAME>
#define AGS_IS_COPY_NOTATION_AUDIO_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_COPY_NOTATION_AUDIO_RUN))
</MACRO>
<MACRO>
<NAME>AGS_COPY_NOTATION_AUDIO_RUN_GET_CLASS</NAME>
#define AGS_COPY_NOTATION_AUDIO_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_COPY_NOTATION_AUDIO_RUN, AgsCopyNotationAudioRunClass))
</MACRO>
<STRUCT>
<NAME>AgsCopyNotationAudioRun</NAME>
struct _AgsCopyNotationAudioRun
{
  AgsRecallAudioRun recall_audio_run;

  AgsCountBeatsAudioRun *count_beats_audio_run;

  gulong tic_alloc_input_handler;

  GList *current_note;
};
</STRUCT>
<STRUCT>
<NAME>AgsCopyNotationAudioRunClass</NAME>
struct _AgsCopyNotationAudioRunClass
{
  AgsRecallAudioRunClass recall_audio_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_copy_notation_audio_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_copy_notation_audio_run_new</NAME>
<RETURNS>AgsCopyNotationAudioRun * </RETURNS>
AgsCountBeatsAudioRun *count_beats_audio_run 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MUTE_RECYCLING</NAME>
#define AGS_TYPE_MUTE_RECYCLING                (ags_mute_recycling_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MUTE_RECYCLING</NAME>
#define AGS_MUTE_RECYCLING(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MUTE_RECYCLING, AgsMuteRecycling))
</MACRO>
<MACRO>
<NAME>AGS_MUTE_RECYCLING_CLASS</NAME>
#define AGS_MUTE_RECYCLING_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MUTE_RECYCLING, AgsMuteRecyclingClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTE_RECYCLING</NAME>
#define AGS_IS_MUTE_RECYCLING(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_MUTE_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTE_RECYCLING_CLASS</NAME>
#define AGS_IS_MUTE_RECYCLING_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MUTE_RECYCLING))
</MACRO>
<MACRO>
<NAME>AGS_MUTE_RECYCLING_GET_CLASS</NAME>
#define AGS_MUTE_RECYCLING_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_MUTE_RECYCLING, AgsMuteRecyclingClass))
</MACRO>
<STRUCT>
<NAME>AgsMuteRecycling</NAME>
struct _AgsMuteRecycling
{
  AgsRecallRecycling recall_recycling;
};
</STRUCT>
<STRUCT>
<NAME>AgsMuteRecyclingClass</NAME>
struct _AgsMuteRecyclingClass
{
  AgsRecallRecyclingClass recall_recycling;
};
</STRUCT>
<FUNCTION>
<NAME>ags_mute_recycling_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_mute_recycling_new</NAME>
<RETURNS>AgsMuteRecycling * </RETURNS>
AgsRecycling *source 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_DELAY_AUDIO_RUN</NAME>
#define AGS_TYPE_DELAY_AUDIO_RUN                (ags_delay_audio_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_DELAY_AUDIO_RUN</NAME>
#define AGS_DELAY_AUDIO_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_DELAY_AUDIO_RUN, AgsDelayAudioRun))
</MACRO>
<MACRO>
<NAME>AGS_DELAY_AUDIO_RUN_CLASS</NAME>
#define AGS_DELAY_AUDIO_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_DELAY_AUDIO_RUN, AgsDelayAudioRun))
</MACRO>
<MACRO>
<NAME>AGS_IS_DELAY_AUDIO_RUN</NAME>
#define AGS_IS_DELAY_AUDIO_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_DELAY_AUDIO_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_DELAY_AUDIO_RUN_CLASS</NAME>
#define AGS_IS_DELAY_AUDIO_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_DELAY_AUDIO_RUN))
</MACRO>
<MACRO>
<NAME>AGS_DELAY_AUDIO_RUN_GET_CLASS</NAME>
#define AGS_DELAY_AUDIO_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_DELAY_AUDIO_RUN, AgsDelayAudioRunClass))
</MACRO>
<STRUCT>
<NAME>AgsDelayAudioRun</NAME>
struct _AgsDelayAudioRun
{
  AgsRecallAudioRun recall_audio_run;

  guint dependency_ref;

  guint hide_ref;
  guint hide_ref_counter;
  
  guint notation_counter;
  guint sequencer_counter;
};
</STRUCT>
<STRUCT>
<NAME>AgsDelayAudioRunClass</NAME>
struct _AgsDelayAudioRunClass
{
  AgsRecallAudioRunClass recall_audio_run;

  void (*notation_alloc_output)(AgsDelayAudioRun *delay_audio_run, guint run_order,
				gdouble delay, guint attack);
  void (*notation_alloc_input)(AgsDelayAudioRun *delay_audio_run, guint run_order,
			       gdouble delay, guint attack);
  void (*notation_count)(AgsDelayAudioRun *delay_audio_run, guint run_order,
			 gdouble delay, guint attack);

  void (*sequencer_alloc_output)(AgsDelayAudioRun *delay_audio_run, guint run_order,
				 gdouble delay, guint attack);
  void (*sequencer_alloc_input)(AgsDelayAudioRun *delay_audio_run, guint run_order,
				gdouble delay, guint attack);
  void (*sequencer_count)(AgsDelayAudioRun *delay_audio_run, guint run_order,
			  gdouble delay, guint attack);
};
</STRUCT>
<FUNCTION>
<NAME>ags_delay_audio_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_delay_audio_run_notation_alloc_output</NAME>
<RETURNS>void  </RETURNS>
AgsDelayAudioRun *delay_audio_run, guint run_order, gdouble delay, guint attack 
</FUNCTION>
<FUNCTION>
<NAME>ags_delay_audio_run_notation_alloc_input</NAME>
<RETURNS>void  </RETURNS>
AgsDelayAudioRun *delay_audio_run, guint run_order, gdouble delay, guint attack 
</FUNCTION>
<FUNCTION>
<NAME>ags_delay_audio_run_notation_count</NAME>
<RETURNS>void  </RETURNS>
AgsDelayAudioRun *delay_audio_run, guint run_order, gdouble delay, guint attack 
</FUNCTION>
<FUNCTION>
<NAME>ags_delay_audio_run_sequencer_alloc_output</NAME>
<RETURNS>void  </RETURNS>
AgsDelayAudioRun *delay_audio_run, guint run_order, gdouble delay, guint attack 
</FUNCTION>
<FUNCTION>
<NAME>ags_delay_audio_run_sequencer_alloc_input</NAME>
<RETURNS>void  </RETURNS>
AgsDelayAudioRun *delay_audio_run, guint run_order, gdouble delay, guint attack 
</FUNCTION>
<FUNCTION>
<NAME>ags_delay_audio_run_sequencer_count</NAME>
<RETURNS>void  </RETURNS>
AgsDelayAudioRun *delay_audio_run, guint run_order, gdouble delay, guint attack 
</FUNCTION>
<FUNCTION>
<NAME>ags_delay_audio_run_new</NAME>
<RETURNS>AgsDelayAudioRun * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAY_NOTE</NAME>
#define AGS_TYPE_PLAY_NOTE             (ags_play_note_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAY_NOTE</NAME>
#define AGS_PLAY_NOTE(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAY_NOTE, AgsPlayNote))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_NOTE_CLASS</NAME>
#define AGS_PLAY_NOTE_CLASS(class)     (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PLAY_NOTE, AgsPlayNote))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_NOTE</NAME>
#define AGS_IS_PLAY_NOTE(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_PLAY_NOTE))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_NOTE_CLASS</NAME>
#define AGS_IS_PLAY_NOTE_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_PLAY_NOTE))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_NOTE_GET_CLASS</NAME>
#define AGS_PLAY_NOTE_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_PLAY_NOTE, AgsPlayNoteClass))
</MACRO>
<STRUCT>
<NAME>AgsPlayNote</NAME>
struct _AgsPlayNote
{
  AgsRecall recall;

  GObject *soundcard;

  AgsChannel *channel;
  AgsNote *note;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlayNoteClass</NAME>
struct _AgsPlayNoteClass
{
  AgsRecallClass recall;
};
</STRUCT>
<FUNCTION>
<NAME>ags_play_note_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_note_new</NAME>
<RETURNS>AgsPlayNote * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_DELAY_AUDIO</NAME>
#define AGS_TYPE_DELAY_AUDIO                (ags_delay_audio_get_type())
</MACRO>
<MACRO>
<NAME>AGS_DELAY_AUDIO</NAME>
#define AGS_DELAY_AUDIO(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_DELAY_AUDIO, AgsDelayAudio))
</MACRO>
<MACRO>
<NAME>AGS_DELAY_AUDIO_CLASS</NAME>
#define AGS_DELAY_AUDIO_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_DELAY_AUDIO, AgsDelayAudio))
</MACRO>
<MACRO>
<NAME>AGS_IS_DELAY_AUDIO</NAME>
#define AGS_IS_DELAY_AUDIO(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_DELAY_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_IS_DELAY_AUDIO_CLASS</NAME>
#define AGS_IS_DELAY_AUDIO_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_DELAY_AUDIO))
</MACRO>
<MACRO>
<NAME>AGS_DELAY_AUDIO_GET_CLASS</NAME>
#define AGS_DELAY_AUDIO_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_DELAY_AUDIO, AgsDelayAudioClass))
</MACRO>
<STRUCT>
<NAME>AgsDelayAudio</NAME>
struct _AgsDelayAudio
{
  AgsRecallAudio recall_audio;

  AgsPort *bpm;
  AgsPort *tact;

  AgsPort *notation_delay;
  AgsPort *sequencer_delay;

  AgsPort *sequencer_duration;
  AgsPort *notation_duration;
};
</STRUCT>
<STRUCT>
<NAME>AgsDelayAudioClass</NAME>
struct _AgsDelayAudioClass
{
  AgsRecallAudioClass recall_audio;

  void (*notation_duration_changed)(AgsDelayAudio *delay_audio);
  void (*sequencer_duration_changed)(AgsDelayAudio *delay_audio);
};
</STRUCT>
<FUNCTION>
<NAME>ags_delay_audio_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_delay_audio_notation_duration_changed</NAME>
<RETURNS>void  </RETURNS>
AgsDelayAudio *delay_audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_delay_audio_sequencer_duration_changed</NAME>
<RETURNS>void  </RETURNS>
AgsDelayAudio *delay_audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_delay_audio_new</NAME>
<RETURNS>AgsDelayAudio * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CLONE_CHANNEL</NAME>
#define AGS_TYPE_CLONE_CHANNEL                (ags_clone_channel_get_type())
</MACRO>
<MACRO>
<NAME>AGS_CLONE_CHANNEL</NAME>
#define AGS_CLONE_CHANNEL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CLONE_CHANNEL, AgsCloneChannel))
</MACRO>
<MACRO>
<NAME>AGS_CLONE_CHANNEL_CLASS</NAME>
#define AGS_CLONE_CHANNEL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_CLONE_CHANNEL, AgsCloneChannel))
</MACRO>
<MACRO>
<NAME>AGS_IS_CLONE_CHANNEL</NAME>
#define AGS_IS_CLONE_CHANNEL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_CLONE_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_IS_CLONE_CHANNEL_CLASS</NAME>
#define AGS_IS_CLONE_CHANNEL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_CLONE_CHANNEL))
</MACRO>
<MACRO>
<NAME>AGS_CLONE_CHANNEL_GET_CLASS</NAME>
#define AGS_CLONE_CHANNEL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_CLONE_CHANNEL, AgsCloneChannelClass))
</MACRO>
<STRUCT>
<NAME>AgsCloneChannel</NAME>
struct _AgsCloneChannel
{
  AgsRecallChannel recall_channel;

  guint audio_channel;
};
</STRUCT>
<STRUCT>
<NAME>AgsCloneChannelClass</NAME>
struct _AgsCloneChannelClass
{
  AgsRecallChannelClass recall_channel;
};
</STRUCT>
<FUNCTION>
<NAME>ags_clone_channel_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_clone_channel_new</NAME>
<RETURNS>AgsCloneChannel * </RETURNS>
GObject *soundcard, guint audio_channel 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MUTE_CHANNEL_RUN</NAME>
#define AGS_TYPE_MUTE_CHANNEL_RUN                (ags_mute_channel_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MUTE_CHANNEL_RUN</NAME>
#define AGS_MUTE_CHANNEL_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MUTE_CHANNEL_RUN, AgsMuteChannelRun))
</MACRO>
<MACRO>
<NAME>AGS_MUTE_CHANNEL_RUN_CLASS</NAME>
#define AGS_MUTE_CHANNEL_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MUTE_CHANNEL_RUN, AgsMuteChannelRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTE_CHANNEL_RUN</NAME>
#define AGS_IS_MUTE_CHANNEL_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_MUTE_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTE_CHANNEL_RUN_CLASS</NAME>
#define AGS_IS_MUTE_CHANNEL_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_MUTE_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_MUTE_CHANNEL_RUN_GET_CLASS</NAME>
#define AGS_MUTE_CHANNEL_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_MUTE_CHANNEL_RUN, AgsMuteChannelRunClass))
</MACRO>
<STRUCT>
<NAME>AgsMuteChannelRun</NAME>
struct _AgsMuteChannelRun
{
  AgsRecallChannelRun recall_channel_run;
};
</STRUCT>
<STRUCT>
<NAME>AgsMuteChannelRunClass</NAME>
struct _AgsMuteChannelRunClass
{
  AgsRecallChannelRunClass recall_channel_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_mute_channel_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_mute_channel_run_new</NAME>
<RETURNS>AgsMuteChannelRun * </RETURNS>
AgsChannel *source 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_BUFFER_CHANNEL_RUN</NAME>
#define AGS_TYPE_BUFFER_CHANNEL_RUN                (ags_buffer_channel_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_BUFFER_CHANNEL_RUN</NAME>
#define AGS_BUFFER_CHANNEL_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_BUFFER_CHANNEL_RUN, AgsBufferChannelRun))
</MACRO>
<MACRO>
<NAME>AGS_BUFFER_CHANNEL_RUN_CLASS</NAME>
#define AGS_BUFFER_CHANNEL_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_BUFFER_CHANNEL_RUN, AgsBufferChannelRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_BUFFER_CHANNEL_RUN</NAME>
#define AGS_IS_BUFFER_CHANNEL_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_BUFFER_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_BUFFER_CHANNEL_RUN_CLASS</NAME>
#define AGS_IS_BUFFER_CHANNEL_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_BUFFER_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_BUFFER_CHANNEL_RUN_GET_CLASS</NAME>
#define AGS_BUFFER_CHANNEL_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_BUFFER_CHANNEL_RUN, AgsBufferChannelRunClass))
</MACRO>
<STRUCT>
<NAME>AgsBufferChannelRun</NAME>
struct _AgsBufferChannelRun
{
  AgsRecallChannelRun recall_channel_run;
};
</STRUCT>
<STRUCT>
<NAME>AgsBufferChannelRunClass</NAME>
struct _AgsBufferChannelRunClass
{
  AgsRecallChannelRunClass recall_channel_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_buffer_channel_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_buffer_channel_run_new</NAME>
<RETURNS>AgsBufferChannelRun * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PLAY_CHANNEL_RUN</NAME>
#define AGS_TYPE_PLAY_CHANNEL_RUN                (ags_play_channel_run_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PLAY_CHANNEL_RUN</NAME>
#define AGS_PLAY_CHANNEL_RUN(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_PLAY_CHANNEL_RUN, AgsPlayChannelRun))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_CHANNEL_RUN_CLASS</NAME>
#define AGS_PLAY_CHANNEL_RUN_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_PLAY_CHANNEL_RUN, AgsPlayChannelRunClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_CHANNEL_RUN</NAME>
#define AGS_IS_PLAY_CHANNEL_RUN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_PLAY_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_IS_PLAY_CHANNEL_RUN_CLASS</NAME>
#define AGS_IS_PLAY_CHANNEL_RUN_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_PLAY_CHANNEL_RUN))
</MACRO>
<MACRO>
<NAME>AGS_PLAY_CHANNEL_RUN_GET_CLASS</NAME>
#define AGS_PLAY_CHANNEL_RUN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_PLAY_CHANNEL_RUN, AgsPlayChannelRunClass))
</MACRO>
<ENUM>
<NAME>AgsPlayChannelRunFlags</NAME>
typedef enum{
  AGS_PLAY_CHANNEL_RUN_TERMINATING        = 1,
  AGS_PLAY_CHANNEL_RUN_INITIAL_RUN        = 1 << 1,
}AgsPlayChannelRunFlags;
</ENUM>
<STRUCT>
<NAME>AgsPlayChannelRun</NAME>
struct _AgsPlayChannelRun
{
  AgsRecallChannelRun recall_channel_run;

  guint flags;

  AgsStreamChannelRun *stream_channel_run;
  gulong done_handler;

  gulong source_recycling_changed_handler;
};
</STRUCT>
<STRUCT>
<NAME>AgsPlayChannelRunClass</NAME>
struct _AgsPlayChannelRunClass
{
  AgsRecallChannelRunClass recall_channel_run;
};
</STRUCT>
<FUNCTION>
<NAME>ags_play_channel_run_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_play_channel_run_new</NAME>
<RETURNS>AgsPlayChannelRun * </RETURNS>
AgsStreamChannelRun *stream_channel_run 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MIDI_PARSER</NAME>
#define AGS_TYPE_MIDI_PARSER                (ags_midi_parser_get_type ())
</MACRO>
<MACRO>
<NAME>AGS_MIDI_PARSER</NAME>
#define AGS_MIDI_PARSER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MIDI_PARSER, AgsMidiParser))
</MACRO>
<MACRO>
<NAME>AGS_MIDI_PARSER_CLASS</NAME>
#define AGS_MIDI_PARSER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_MIDI_PARSER, AgsMidiParserClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MIDI_PARSER</NAME>
#define AGS_IS_MIDI_PARSER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_MIDI_PARSER))
</MACRO>
<MACRO>
<NAME>AGS_IS_MIDI_PARSER_CLASS</NAME>
#define AGS_IS_MIDI_PARSER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MIDI_PARSER))
</MACRO>
<MACRO>
<NAME>AGS_MIDI_PARSER_GET_CLASS</NAME>
#define AGS_MIDI_PARSER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), AGS_TYPE_MIDI_PARSER, AgsMidiParserClass))
</MACRO>
<MACRO>
<NAME>AGS_MIDI_PARSER_MTHD</NAME>
#define AGS_MIDI_PARSER_MTHD "MThd\0"
</MACRO>
<MACRO>
<NAME>AGS_MIDI_PARSER_MTCK</NAME>
#define AGS_MIDI_PARSER_MTCK "MTrk\0"
</MACRO>
<ENUM>
<NAME>AgsMidiParserFlags</NAME>
typedef enum{
  AGS_MIDI_PARSER_EOF  = 1,
  AGS_MIDI_PARSER_EOT  = 1 << 1,
}AgsMidiParserFlags;
</ENUM>
<ENUM>
<NAME>AgsMidiChunkFlags</NAME>
typedef enum{
  AGS_MIDI_CHUNK_HEADER   = 1,
  AGS_MIDI_CHUNK_TRACK    = 1 << 1,
  AGS_MIDI_CHUNK_UNKNOWN  = 1 << 2,
}AgsMidiChunkFlags;
</ENUM>
<STRUCT>
<NAME>AgsMidiParser</NAME>
struct _AgsMidiParser
{
  GObject gobject;

  guint flags;

  FILE *file;
  guint nth_chunk;

  size_t file_length;
  size_t offset;

  guint current_time;
};
</STRUCT>
<STRUCT>
<NAME>AgsMidiParserClass</NAME>
struct _AgsMidiParserClass
{
  GObjectClass gobject;

  int (*midi_getc)(AgsMidiParser *midi_parser);
  void (*on_error)(AgsMidiParser *midi_parser,
		   GError **error);
  
  xmlNode* (*parse_header)(AgsMidiParser *midi_parser);
  xmlNode* (*parse_track)(AgsMidiParser *midi_parser);

  xmlNode* (*key_on)(AgsMidiParser *midi_parser, guint status);
  xmlNode* (*key_off)(AgsMidiParser *midi_parser, guint status);
  xmlNode* (*key_pressure)(AgsMidiParser *midi_parser, guint status);

  xmlNode* (*change_parameter)(AgsMidiParser *midi_parser, guint status);
  xmlNode* (*change_pitch_bend)(AgsMidiParser *midi_parser, guint status);
  xmlNode* (*change_program)(AgsMidiParser *midi_parser, guint status);
  xmlNode* (*change_channel_pressure)(AgsMidiParser *midi_parser, guint status);
  xmlNode* (*not_defined)(AgsMidiParser *midi_parser, guint status);

  xmlNode* (*sysex)(AgsMidiParser *midi_parser, guint status);
  xmlNode* (*system_common)(AgsMidiParser *midi_parser, guint status);

  xmlNode* (*meta_event)(AgsMidiParser *midi_parser, guint status);
  xmlNode* (*sequence_number)(AgsMidiParser *midi_parser, guint meta_type);
  xmlNode* (*end_of_track)(AgsMidiParser *midi_parser, guint meta_type);
  xmlNode* (*smpte)(AgsMidiParser *midi_parser, guint meta_type);
  xmlNode* (*tempo)(AgsMidiParser *midi_parser, guint meta_type);
  xmlNode* (*time_signature)(AgsMidiParser *midi_parser, guint meta_type);
  xmlNode* (*key_signature)(AgsMidiParser *midi_parser, guint meta_type);
  xmlNode* (*sequencer_meta_event)(AgsMidiParser *midi_parser, guint meta_type);
  xmlNode* (*text_event)(AgsMidiParser *midi_parser, guint meta_type);
  
  xmlDoc* (*parse_full)(AgsMidiParser *midi_parser);
};
</STRUCT>
<FUNCTION>
<NAME>ags_midi_parser_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_read_gint16</NAME>
<RETURNS>gint16  </RETURNS>
AgsMidiParser *midi_parser 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_read_gint24</NAME>
<RETURNS>gint32  </RETURNS>
AgsMidiParser *midi_parser 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_read_gint32</NAME>
<RETURNS>gint32  </RETURNS>
AgsMidiParser *midi_parser 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_read_varlength</NAME>
<RETURNS>long  </RETURNS>
AgsMidiParser *midi_parser 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_read_text</NAME>
<RETURNS>gchar * </RETURNS>
AgsMidiParser *midi_parser, gint length 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_ticks_to_sec</NAME>
<RETURNS>gdouble  </RETURNS>
AgsMidiParser *midi_parser, guint ticks, gint division, guint tempo 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_midi_getc</NAME>
<RETURNS>int  </RETURNS>
AgsMidiParser *midi_parser 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_on_error</NAME>
<RETURNS>void  </RETURNS>
AgsMidiParser *midi_parser, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_parse_full</NAME>
<RETURNS>xmlDoc * </RETURNS>
AgsMidiParser *midi_parser 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_parse_header</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_parse_track</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_channel_message</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint status 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_key_on</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint status 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_key_off</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint status 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_key_pressure</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint status 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_change_parameter</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint status 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_change_pitch_bend</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint status 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_change_program</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint status 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_change_channel_pressure</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint status 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_not_defined</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint status 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_sysex</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint status 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_system_common</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint status 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_meta_event</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint status 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_sequence_number</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint meta_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_end_of_track</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint meta_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_smpte</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint meta_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_tempo</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint meta_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_time_signature</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint meta_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_key_signature</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint meta_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_sequencer_meta_event</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint meta_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_meta_misc</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint meta_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_text_event</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsMidiParser *midi_parser, guint meta_type 
</FUNCTION>
<FUNCTION>
<NAME>ags_midi_parser_new</NAME>
<RETURNS>AgsMidiParser * </RETURNS>
FILE *file 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECYCLING_THREAD</NAME>
#define AGS_TYPE_RECYCLING_THREAD                (ags_recycling_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECYCLING_THREAD</NAME>
#define AGS_RECYCLING_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECYCLING_THREAD, AgsRecyclingThread))
</MACRO>
<MACRO>
<NAME>AGS_RECYCLING_THREAD_CLASS</NAME>
#define AGS_RECYCLING_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_RECYCLING_THREAD, AgsRecyclingThread))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECYCLING_THREAD</NAME>
#define AGS_IS_RECYCLING_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECYCLING_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECYCLING_THREAD_CLASS</NAME>
#define AGS_IS_RECYCLING_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECYCLING_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_RECYCLING_THREAD_GET_CLASS</NAME>
#define AGS_RECYCLING_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_RECYCLING_THREAD, AgsRecyclingThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_RECYCLING_THREAD_DEFAULT_JIFFIE</NAME>
#define AGS_RECYCLING_THREAD_DEFAULT_JIFFIE (100)
</MACRO>
<ENUM>
<NAME>AgsRecyclingThreadFlags</NAME>
typedef enum{
  AGS_RECYCLING_THREAD_RUNNING   = 1,
  AGS_RECYCLING_THREAD_WAIT      = 1 << 1,
  AGS_RECYCLING_THREAD_DONE      = 1 << 2,
}AgsRecyclingThreadFlags;
</ENUM>
<STRUCT>
<NAME>AgsRecyclingThread</NAME>
struct _AgsRecyclingThread
{
  AgsThread thread;

  guint flags;

  AgsThread *iterator_thread;

  pthread_mutex_t iteration_mutex;
  pthread_cond_t iteration_cond;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecyclingThreadClass</NAME>
struct _AgsRecyclingThreadClass
{
  AgsThreadClass thread;

  void (*play_channel)(AgsRecyclingThread *recycling_thread,
		       GObject *channel,
		       AgsRecallID *recall_id,
		       gint stage);

  void (*play_audio)(AgsRecyclingThread *recycling_thread,
		     GObject *output, GObject *audio,
		     AgsRecallID *recall_id,
		     gint stage);
};
</STRUCT>
<FUNCTION>
<NAME>ags_recycling_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_thread_play_channel</NAME>
<RETURNS>void  </RETURNS>
AgsRecyclingThread *recycling_thread, GObject *channel, AgsRecallID *recall_id, gint stage 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_thread_play_audio</NAME>
<RETURNS>void  </RETURNS>
AgsRecyclingThread *recycling_thread, GObject *output, GObject *audio, AgsRecallID *recall_id, gint stage 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_thread_new</NAME>
<RETURNS>AgsRecyclingThread * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_ITERATOR_THREAD</NAME>
#define AGS_TYPE_ITERATOR_THREAD                (ags_iterator_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_ITERATOR_THREAD</NAME>
#define AGS_ITERATOR_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_ITERATOR_THREAD, AgsIteratorThread))
</MACRO>
<MACRO>
<NAME>AGS_ITERATOR_THREAD_CLASS</NAME>
#define AGS_ITERATOR_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_ITERATOR_THREAD, AgsIteratorThread))
</MACRO>
<MACRO>
<NAME>AGS_IS_ITERATOR_THREAD</NAME>
#define AGS_IS_ITERATOR_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_ITERATOR_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_ITERATOR_THREAD_CLASS</NAME>
#define AGS_IS_ITERATOR_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_ITERATOR_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_ITERATOR_THREAD_GET_CLASS</NAME>
#define AGS_ITERATOR_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_ITERATOR_THREAD, AgsIteratorThreadClass))
</MACRO>
<ENUM>
<NAME>AgsIteratorThreadFlags</NAME>
typedef enum{
  AGS_ITERATOR_THREAD_DONE      = 1,
  AGS_ITERATOR_THREAD_WAIT      = 1 << 1,
}AgsIteratorThreadFlags;
</ENUM>
<STRUCT>
<NAME>AgsIteratorThread</NAME>
struct _AgsIteratorThread
{
  AgsThread thread;

  guint flags;

  pthread_mutex_t tic_mutex;
  pthread_cond_t tic_cond;

  AgsThread *recycling_thread;

  AgsChannel *channel;
  AgsRecallID *recall_id;
  gint stage;
};
</STRUCT>
<STRUCT>
<NAME>AgsIteratorThreadClass</NAME>
struct _AgsIteratorThreadClass
{
  AgsThreadClass thread;
  
  void (*children_ready)(AgsIteratorThread *iterator_thread,
			 AgsThread *current);
};
</STRUCT>
<FUNCTION>
<NAME>ags_iterator_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_iterator_thread_children_ready</NAME>
<RETURNS>void  </RETURNS>
AgsIteratorThread *iterator_thread, AgsThread *current 
</FUNCTION>
<FUNCTION>
<NAME>ags_iterator_thread_new</NAME>
<RETURNS>AgsIteratorThread * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUDIO_LOOP</NAME>
#define AGS_TYPE_AUDIO_LOOP                (ags_audio_loop_get_type())
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_LOOP</NAME>
#define AGS_AUDIO_LOOP(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUDIO_LOOP, AgsAudioLoop))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_LOOP_CLASS</NAME>
#define AGS_AUDIO_LOOP_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_AUDIO_LOOP, AgsAudioLoopClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_LOOP</NAME>
#define AGS_IS_AUDIO_LOOP(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_AUDIO_LOOP))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUDIO_LOOP_CLASS</NAME>
#define AGS_IS_AUDIO_LOOP_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_AUDIO_LOOP))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_LOOP_GET_CLASS</NAME>
#define AGS_AUDIO_LOOP_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_AUDIO_LOOP, AgsAudioLoopClass))
</MACRO>
<MACRO>
<NAME>AGS_AUDIO_LOOP_DEFAULT_JIFFIE</NAME>
#define AGS_AUDIO_LOOP_DEFAULT_JIFFIE (48.0)
</MACRO>
<ENUM>
<NAME>AgsAudioLoopFlags</NAME>
typedef enum{
  AGS_AUDIO_LOOP_PLAY_RECALL                    = 1,
  AGS_AUDIO_LOOP_PLAYING_RECALL                 = 1 << 1,
  AGS_AUDIO_LOOP_PLAY_RECALL_TERMINATING        = 1 << 2,
  AGS_AUDIO_LOOP_PLAY_CHANNEL                   = 1 << 3,
  AGS_AUDIO_LOOP_PLAYING_CHANNEL                = 1 << 4,
  AGS_AUDIO_LOOP_PLAY_CHANNEL_TERMINATING       = 1 << 5,
  AGS_AUDIO_LOOP_PLAY_AUDIO                     = 1 << 6,
  AGS_AUDIO_LOOP_PLAYING_AUDIO                  = 1 << 7,
  AGS_AUDIO_LOOP_PLAY_NOTATION                  = 1 << 8,
  AGS_AUDIO_LOOP_PLAYING_NOTATION               = 1 << 9,
  AGS_AUDIO_LOOP_PLAY_AUDIO_TERMINATING         = 1 << 10,
}AgsAudioLoopFlags;
</ENUM>
<STRUCT>
<NAME>AgsAudioLoop</NAME>
struct _AgsAudioLoop
{
  AgsThread thread;

  guint flags;

  volatile guint tic;
  volatile guint last_sync;

  GCond cond;
  GMutex mutex;

  gdouble frequency;

  GObject *application_context;
  pthread_mutex_t *application_mutex;
  
  GObject *soundcard;
  
  pthread_mutex_t recall_mutex;

  guint play_recall_ref;
  GList *play_recall; // play AgsRecall

  guint play_channel_ref;
  GList *play_channel; // play AgsChannel

  guint play_audio_ref;
  GList *play_audio; // play AgsAudio

  guint play_notation_ref;
  GList *play_notation;

  GList *tree_sanity;
};
</STRUCT>
<STRUCT>
<NAME>AgsAudioLoopClass</NAME>
struct _AgsAudioLoopClass
{
  AgsThreadClass thread;

  void (*stopped_all)(AgsAudioLoop *audio_loop);
};
</STRUCT>
<FUNCTION>
<NAME>ags_audio_loop_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_loop_add_audio</NAME>
<RETURNS>void  </RETURNS>
AgsAudioLoop *audio_loop, GObject *audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_loop_remove_audio</NAME>
<RETURNS>void  </RETURNS>
AgsAudioLoop *audio_loop, GObject *audio 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_loop_add_channel</NAME>
<RETURNS>void  </RETURNS>
AgsAudioLoop *audio_loop, GObject *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_loop_remove_channel</NAME>
<RETURNS>void  </RETURNS>
AgsAudioLoop *audio_loop, GObject *channel 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_loop_add_recall</NAME>
<RETURNS>void  </RETURNS>
AgsAudioLoop *audio_loop, GObject *playback 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_loop_remove_recall</NAME>
<RETURNS>void  </RETURNS>
AgsAudioLoop *audio_loop, GObject *playback 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_loop_stopped_all</NAME>
<RETURNS>void  </RETURNS>
AgsAudioLoop *audio_loop 
</FUNCTION>
<FUNCTION>
<NAME>ags_audio_loop_new</NAME>
<RETURNS>AgsAudioLoop * </RETURNS>
GObject *soundcard, GObject *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_EXPORT_THREAD</NAME>
#define AGS_TYPE_EXPORT_THREAD                (ags_export_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_EXPORT_THREAD</NAME>
#define AGS_EXPORT_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_EXPORT_THREAD, AgsExportThread))
</MACRO>
<MACRO>
<NAME>AGS_EXPORT_THREAD_CLASS</NAME>
#define AGS_EXPORT_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_EXPORT_THREAD, AgsExportThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_EXPORT_THREAD</NAME>
#define AGS_IS_EXPORT_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_EXPORT_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_EXPORT_THREAD_CLASS</NAME>
#define AGS_IS_EXPORT_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_EXPORT_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_EXPORT_THREAD_GET_CLASS</NAME>
#define AGS_EXPORT_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_EXPORT_THREAD, AgsExportThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_EXPORT_THREAD_DEFAULT_JIFFIE</NAME>
#define AGS_EXPORT_THREAD_DEFAULT_JIFFIE (48.0) // same as soundcard thread
</MACRO>
<STRUCT>
<NAME>AgsExportThread</NAME>
struct _AgsExportThread
{
  AgsThread thread;

  guint flags;

  guint tic;
  guint counter;

  GObject *soundcard;
  AgsAudioFile *audio_file;
};
</STRUCT>
<STRUCT>
<NAME>AgsExportThreadClass</NAME>
struct _AgsExportThreadClass
{
  AgsThreadClass thread;
};
</STRUCT>
<FUNCTION>
<NAME>ags_export_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_export_thread_new</NAME>
<RETURNS>AgsExportThread * </RETURNS>
GObject *soundcard, AgsAudioFile *audio_file 
</FUNCTION>
<FUNCTION>
<NAME>ags_recycling_thread_iterate_callback</NAME>
<RETURNS>void  </RETURNS>
AgsRecyclingThread *thread, gpointer user_data 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RECORD_THREAD</NAME>
#define AGS_TYPE_RECORD_THREAD                (ags_record_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RECORD_THREAD</NAME>
#define AGS_RECORD_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RECORD_THREAD, AgsRecordThread))
</MACRO>
<MACRO>
<NAME>AGS_RECORD_THREAD_CLASS</NAME>
#define AGS_RECORD_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_RECORD_THREAD, AgsRecordThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECORD_THREAD</NAME>
#define AGS_IS_RECORD_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RECORD_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_RECORD_THREAD_CLASS</NAME>
#define AGS_IS_RECORD_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RECORD_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_RECORD_THREAD_GET_CLASS</NAME>
#define AGS_RECORD_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_RECORD_THREAD, AgsRecordThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_RECORD_THREAD_DEFAULT_DELAY</NAME>
#define AGS_RECORD_THREAD_DEFAULT_DELAY (128)
</MACRO>
<STRUCT>
<NAME>AgsRecordThread</NAME>
struct _AgsRecordThread
{
  AgsThread thread;

  AgsRegistry *registry;

  guint delay;
  guint counter;
};
</STRUCT>
<STRUCT>
<NAME>AgsRecordThreadClass</NAME>
struct _AgsRecordThreadClass
{
  AgsThreadClass thread;
};
</STRUCT>
<FUNCTION>
<NAME>ags_record_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_record_thread_new</NAME>
<RETURNS>AgsRecordThread * </RETURNS>
GObject *soundcard, AgsRegistry *registry 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SOUNDCARD_THREAD</NAME>
#define AGS_TYPE_SOUNDCARD_THREAD                (ags_soundcard_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_THREAD</NAME>
#define AGS_SOUNDCARD_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SOUNDCARD_THREAD, AgsSoundcardThread))
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_THREAD_CLASS</NAME>
#define AGS_SOUNDCARD_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_SOUNDCARD_THREAD, AgsSoundcardThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SOUNDCARD_THREAD</NAME>
#define AGS_IS_SOUNDCARD_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_SOUNDCARD_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_SOUNDCARD_THREAD_CLASS</NAME>
#define AGS_IS_SOUNDCARD_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_SOUNDCARD_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_THREAD_GET_CLASS</NAME>
#define AGS_SOUNDCARD_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_SOUNDCARD_THREAD, AgsSoundcardThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_SOUNDCARD_THREAD_DEFAULT_JIFFIE</NAME>
#define AGS_SOUNDCARD_THREAD_DEFAULT_JIFFIE (48.0)
</MACRO>
<STRUCT>
<NAME>AgsSoundcardThread</NAME>
struct _AgsSoundcardThread
{
  AgsThread thread;

  time_t time_val;

  GObject *soundcard;
  
  AgsThread *timestamp_thread;

  GError *error;
};
</STRUCT>
<STRUCT>
<NAME>AgsSoundcardThreadClass</NAME>
struct _AgsSoundcardThreadClass
{
  AgsThreadClass thread;
};
</STRUCT>
<FUNCTION>
<NAME>ags_soundcard_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_soundcard_thread_new</NAME>
<RETURNS>AgsSoundcardThread * </RETURNS>
GObject *soundcard 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_HISTORY</NAME>
#define AGS_TYPE_HISTORY                (ags_history_get_type())
</MACRO>
<MACRO>
<NAME>AGS_HISTORY</NAME>
#define AGS_HISTORY(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_HISTORY, AgsHistory))
</MACRO>
<MACRO>
<NAME>AGS_HISTORY_CLASS</NAME>
#define AGS_HISTORY_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_HISTORY, AgsHistory))
</MACRO>
<MACRO>
<NAME>AGS_IS_HISTORY</NAME>
#define AGS_IS_HISTORY(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_HISTORY))
</MACRO>
<MACRO>
<NAME>AGS_IS_HISTORY_CLASS</NAME>
#define AGS_IS_HISTORY_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_HISTORY))
</MACRO>
<MACRO>
<NAME>AGS_HISTORY_GET_CLASS</NAME>
#define AGS_HISTORY_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_HISTORY, AgsHistoryClass))
</MACRO>
<STRUCT>
<NAME>AgsHistory</NAME>
struct _AgsHistory
{
  GObject gobject;
  
  GList *task;
};
</STRUCT>
<STRUCT>
<NAME>AgsHistoryClass</NAME>
struct _AgsHistoryClass
{
  GObjectClass gobject;
};
</STRUCT>
<FUNCTION>
<NAME>ags_history_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_history_new</NAME>
<RETURNS>AgsHistory * </RETURNS>
 
</FUNCTION>
<STRUCT>
<NAME>AgsHistoryAppend</NAME>
</STRUCT>
<MACRO>
<NAME>AGS_TYPE_THREAD</NAME>
#define AGS_TYPE_THREAD                (ags_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_THREAD</NAME>
#define AGS_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_THREAD, AgsThread))
</MACRO>
<MACRO>
<NAME>AGS_THREAD_CLASS</NAME>
#define AGS_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_THREAD, AgsThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_THREAD</NAME>
#define AGS_IS_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_THREAD_CLASS</NAME>
#define AGS_IS_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_THREAD_GET_CLASS</NAME>
#define AGS_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_THREAD, AgsThreadClass))
</MACRO>
<MACRO>
<NAME>MSEC_PER_SEC</NAME>
#define MSEC_PER_SEC    (1000000) /* The number of msecs per sec. */
</MACRO>
<MACRO>
<NAME>NSEC_PER_SEC</NAME>
#define NSEC_PER_SEC    (1000000000) /* The number of nsecs per sec. */
</MACRO>
<MACRO>
<NAME>AGS_THREAD_STACKSIZE</NAME>
#define AGS_THREAD_STACKSIZE (16384)
</MACRO>
<MACRO>
<NAME>AGS_THREAD_RESUME_SIG</NAME>
#define AGS_THREAD_RESUME_SIG SIGUSR2
</MACRO>
<MACRO>
<NAME>AGS_THREAD_SUSPEND_SIG</NAME>
#define AGS_THREAD_SUSPEND_SIG SIGUSR1
</MACRO>
<ENUM>
<NAME>AgsThreadFlags</NAME>
typedef enum{
  AGS_THREAD_RUNNING                 = 1,
  AGS_THREAD_IDLE                    = 1 << 1,
  AGS_THREAD_LOCKED                  = 1 << 2,
  AGS_THREAD_WAIT_FOR_PARENT         = 1 << 3,
  AGS_THREAD_WAIT_FOR_SIBLING        = 1 << 4,
  AGS_THREAD_WAIT_FOR_CHILDREN       = 1 << 5,
  AGS_THREAD_WAIT_FOR_BARRIER        = 1 << 6,
  AGS_THREAD_WAITING_FOR_PARENT      = 1 << 7,
  AGS_THREAD_WAITING_FOR_SIBLING     = 1 << 8,
  AGS_THREAD_WAITING_FOR_CHILDREN    = 1 << 9,
  AGS_THREAD_WAITING_FOR_BARRIER     = 1 << 10,
  AGS_THREAD_BROADCAST_PARENT        = 1 << 11,
  AGS_THREAD_BROADCAST_SIBLING       = 1 << 12,
  AGS_THREAD_BROADCAST_CHILDREN      = 1 << 13,
  AGS_THREAD_INITIAL_RUN             = 1 << 14,
  AGS_THREAD_TREE_SYNC_0             = 1 << 15,
  AGS_THREAD_WAIT_0                  = 1 << 16,
  AGS_THREAD_TREE_SYNC_1             = 1 << 17,
  AGS_THREAD_WAIT_1                  = 1 << 18,
  AGS_THREAD_TREE_SYNC_2             = 1 << 19,
  AGS_THREAD_WAIT_2                  = 1 << 20,
  AGS_THREAD_TIMELOCK_RUN            = 1 << 21,
  AGS_THREAD_TIMELOCK_WAIT           = 1 << 22,
  AGS_THREAD_TIMELOCK_RESUME         = 1 << 23,
  /*
   * prefered way would be unlocking greedy_locks
   * and the suspend to not become greedy
   * but while pthread_suspend and pthread_resume
   * are missing you need this as work-around
   */
  AGS_THREAD_SKIP_NON_GREEDY         = 1 << 24,
  AGS_THREAD_SKIPPED_BY_TIMELOCK     = 1 << 25,
  AGS_THREAD_LOCK_GREEDY_RUN_MUTEX   = 1 << 26,
  AGS_THREAD_SUSPENDED               = 1 << 27,
  AGS_THREAD_SINGLE_LOOP             = 1 << 28,
  AGS_THREAD_READY                   = 1 << 29,
  AGS_THREAD_UNREF_ON_EXIT           = 1 << 30,
}AgsThreadFlags;
</ENUM>
<STRUCT>
<NAME>AgsThread</NAME>
struct _AgsThread
{
  GObject object;

  atomic_t flags;

  atomic_t monitor;
  atomic_t lock_count;

  atomic_t barrier;
  atomic_t barrier_count;

  atomic_t dyntic;

  struct timespec timed_suspend;
  gint goodness;

  AgsThread *children;
  AgsThread *next;
  AgsThread *prev;
};
</STRUCT>
<STRUCT>
<NAME>AgsThreadClass</NAME>
struct _AgsThreadClass
{
  GObjectClass object;

  void (*start)(AgsThread *thread);
  void (*run)(AgsThread *thread);
  void (*suspend)(AgsThread *thread);
  void (*resume)(AgsThread *thread);
  void (*timelock)(AgsThread *thread);
  void (*stop)(AgsThread *thread);
};
</STRUCT>
<FUNCTION>
<NAME>ags_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_set_sync</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, guint tic 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_set_sync_all</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, guint tic 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_lock</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_trylock</NAME>
<RETURNS>gboolean  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_unlock</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_get_toplevel</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_first</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_last</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_remove_child</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, AgsThread *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_add_child</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, AgsThread *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_parental_is_locked</NAME>
<RETURNS>gboolean  </RETURNS>
AgsThread *thread, AgsThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_sibling_is_locked</NAME>
<RETURNS>gboolean  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_children_is_locked</NAME>
<RETURNS>gboolean  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_is_current_ready</NAME>
<RETURNS>gboolean  </RETURNS>
AgsThread *current 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_is_tree_ready</NAME>
<RETURNS>gboolean  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_next_parent_locked</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread, AgsThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_next_sibling_locked</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_next_children_locked</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_lock_parent</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, AgsThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_lock_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_lock_children</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_lock_all</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_unlock_parent</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, AgsThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_unlock_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_unlock_children</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_unlock_all</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_wait_parent</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, AgsThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_wait_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_wait_children</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_signal_parent</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, AgsThread *parent, gboolean broadcast 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_signal_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, gboolean broadcast 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_signal_children</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, gboolean broadcast 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_start</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_run</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_suspend</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_resume</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_timelock</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_stop</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_hangcheck</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_new</NAME>
<RETURNS>AgsThread * </RETURNS>
gpointer data 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TIMESTAMP_THREAD</NAME>
#define AGS_TYPE_TIMESTAMP_THREAD                (ags_timestamp_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_THREAD</NAME>
#define AGS_TIMESTAMP_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TIMESTAMP_THREAD, AgsTimestampThread))
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_THREAD_CLASS</NAME>
#define AGS_TIMESTAMP_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_TIMESTAMP_THREAD, AgsTimestampThread))
</MACRO>
<MACRO>
<NAME>AGS_IS_TIMESTAMP_THREAD</NAME>
#define AGS_IS_TIMESTAMP_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_TIMESTAMP_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_TIMESTAMP_THREAD_CLASS</NAME>
#define AGS_IS_TIMESTAMP_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_TIMESTAMP_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_THREAD_GET_CLASS</NAME>
#define AGS_TIMESTAMP_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_TIMESTAMP_THREAD, AgsTimestampThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_MICROSECONDS_PER_SECOND</NAME>
#define AGS_MICROSECONDS_PER_SECOND (1000000.0)
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_THREAD_DEFAULT_BPM</NAME>
#define AGS_TIMESTAMP_THREAD_DEFAULT_BPM (120.0)
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_THREAD_DEFAULT_SAMPLERATE</NAME>
#define AGS_TIMESTAMP_THREAD_DEFAULT_SAMPLERATE (44100.0)
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_THREAD_DEFAULT_BUFFER_SIZE</NAME>
#define AGS_TIMESTAMP_THREAD_DEFAULT_BUFFER_SIZE (256.0)
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_THREAD_DEFAULT_JIFFIE</NAME>
#define AGS_TIMESTAMP_THREAD_DEFAULT_JIFFIE (AGS_MICROSECONDS_PER_SECOND * \
					     60.0 / AGS_TIMESTAMP_THREAD_DEFAULT_BPM)
</MACRO>
<MACRO>
<NAME>AGS_TIMESTAMP_THREAD_DEFAULT_TIC</NAME>
#define AGS_TIMESTAMP_THREAD_DEFAULT_TIC (AGS_TIMESTAMP_THREAD_DEFAULT_JIFFIE / \
					  AGS_TIMESTAMP_THREAD_DEFAULT_SAMPLERATE / AGS_TIMESTAMP_THREAD_DEFAULT_BUFFER_SIZE)
</MACRO>
<STRUCT>
<NAME>AgsTimestampThread</NAME>
struct _AgsTimestampThread
{
  AgsThread thread;

  GObject *current_timestamp;
  GObject *current_latency;

  GObject *timestamp;
};
</STRUCT>
<STRUCT>
<NAME>AgsTimestampThreadClass</NAME>
struct _AgsTimestampThreadClass
{
  AgsThreadClass thread;
};
</STRUCT>
<FUNCTION>
<NAME>ags_timestamp_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_timestamp_thread_new</NAME>
<RETURNS>AgsTimestampThread * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_SINGLE_THREAD</NAME>
#define AGS_TYPE_SINGLE_THREAD                (ags_single_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_SINGLE_THREAD</NAME>
#define AGS_SINGLE_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_SINGLE_THREAD, AgsSingleThread))
</MACRO>
<MACRO>
<NAME>AGS_SINGLE_THREAD_CLASS</NAME>
#define AGS_SINGLE_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_SINGLE_THREAD, AgsSingleThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_SINGLE_THREAD</NAME>
#define AGS_IS_SINGLE_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_SINGLE_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_SINGLE_THREAD_CLASS</NAME>
#define AGS_IS_SINGLE_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_SINGLE_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_SINGLE_THREAD_GET_CLASS</NAME>
#define AGS_SINGLE_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_SINGLE_THREAD, AgsSingleThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_SINGLE_THREAD_DEFAULT_JIFFIE</NAME>
#define AGS_SINGLE_THREAD_DEFAULT_JIFFIE (48.0)
</MACRO>
<STRUCT>
<NAME>AgsSingleThread</NAME>
struct _AgsSingleThread
{
  AgsThread thread;
};
</STRUCT>
<STRUCT>
<NAME>AgsSingleThreadClass</NAME>
struct _AgsSingleThreadClass
{
  AgsThreadClass thread;
};
</STRUCT>
<FUNCTION>
<NAME>ags_single_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_single_thread_new</NAME>
<RETURNS>AgsSingleThread * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_PORTABLE_THREAD</NAME>
#define AGS_TYPE_PORTABLE_THREAD                (ags_portable_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_PORTABLE_THREAD</NAME>
#define AGS_PORTABLE_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_THREAD, AgsPortableThread))
</MACRO>
<MACRO>
<NAME>AGS_PORTABLE_THREAD_CLASS</NAME>
#define AGS_PORTABLE_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_THREAD, AgsPortableThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_PORTABLE_THREAD</NAME>
#define AGS_IS_PORTABLE_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_PORTABLE_THREAD_CLASS</NAME>
#define AGS_IS_PORTABLE_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_PORTABLE_THREAD_GET_CLASS</NAME>
#define AGS_PORTABLE_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_THREAD, AgsPortableThreadClass))
</MACRO>
<ENUM>
<NAME>AgsPortableThreadFlags</NAME>
typedef enum{
  AGS_PORTABLE_THREAD_RUNNING                 = 1,
  AGS_PORTABLE_THREAD_IDLE                    = 1 << 1,
  AGS_PORTABLE_THREAD_LOCKED                  = 1 << 2,
  AGS_PORTABLE_THREAD_WAIT_FOR_PARENT         = 1 << 3,
  AGS_PORTABLE_THREAD_WAIT_FOR_SIBLING        = 1 << 4,
  AGS_PORTABLE_THREAD_WAIT_FOR_CHILDREN       = 1 << 5,
  AGS_PORTABLE_THREAD_WAIT_FOR_BARRIER        = 1 << 6,
  AGS_PORTABLE_THREAD_WAITING_FOR_PARENT      = 1 << 7,
  AGS_PORTABLE_THREAD_WAITING_FOR_SIBLING     = 1 << 8,
  AGS_PORTABLE_THREAD_WAITING_FOR_CHILDREN    = 1 << 9,
  AGS_PORTABLE_THREAD_WAITING_FOR_BARRIER     = 1 << 10,
  AGS_PORTABLE_THREAD_BROADCAST_PARENT        = 1 << 11,
  AGS_PORTABLE_THREAD_BROADCAST_SIBLING       = 1 << 12,
  AGS_PORTABLE_THREAD_BROADCAST_CHILDREN      = 1 << 13,
  AGS_PORTABLE_THREAD_INITIAL_RUN             = 1 << 14,
  AGS_PORTABLE_THREAD_TREE_SYNC_0             = 1 << 15,
  AGS_PORTABLE_THREAD_WAIT_0                  = 1 << 16,
  AGS_PORTABLE_THREAD_TREE_SYNC_1             = 1 << 17,
  AGS_PORTABLE_THREAD_WAIT_1                  = 1 << 18,
  AGS_PORTABLE_THREAD_TREE_SYNC_2             = 1 << 19,
  AGS_PORTABLE_THREAD_WAIT_2                  = 1 << 20,
  AGS_PORTABLE_THREAD_TIMELOCK_RUN            = 1 << 21,
  AGS_PORTABLE_THREAD_TIMELOCK_WAIT           = 1 << 22,
  AGS_PORTABLE_THREAD_TIMELOCK_RESUME         = 1 << 23,
}AgsPortableThreadFlags;
</ENUM>
<STRUCT>
<NAME>AgsPortableThread</NAME>
struct _AgsPortableThread
{
  GObject object;

  volatile guint flags;

  pth_t thread;
  pth_attr_t thread_attr;

  pth_mutex_t mutex;
  pth_cond_t cond;

  pth_mutex_t start_mutex;
  pth_cond_t start_cond;

  pth_barrier_t barrier[2];
  gboolean first_barrier;
  int wait_count[2];

  pth_t timelock_thread;
  pth_mutex_t timelock_mutex;
  pth_cond_t timelock_cond;

  long timelock;

  GObject *devout;
  AgsPortableThread *parent;

  AgsPortableThread *next;
  AgsPortableThread *prev;

  AgsPortableThread *children;

  GObject *data;
};
</STRUCT>
<STRUCT>
<NAME>AgsPortableThreadClass</NAME>
struct _AgsPortableThreadClass
{
  GObjectClass object;

  void (*start)(AgsPortableThread *thread);
  void (*run)(AgsPortableThread *thread);
  void (*timelock)(AgsPortableThread *thread);
  void (*stop)(AgsPortableThread *thread);
};
</STRUCT>
<FUNCTION>
<NAME>ags_portable_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_lock</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_trylock</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_unlock</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_get_toplevel</NAME>
<RETURNS>AgsPortableThread * </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_first</NAME>
<RETURNS>AgsPortableThread * </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_last</NAME>
<RETURNS>AgsPortableThread * </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_remove_child</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread, AgsPortableThread *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_add_child</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread, AgsPortableThread *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_parental_is_locked</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPortableThread *thread, AgsPortableThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_sibling_is_locked</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_children_is_locked</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_is_current_ready</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPortableThread *current 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_is_current_synced</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPortableThread *current 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_is_tree_ready</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_is_tree_synced</NAME>
<RETURNS>gboolean  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_main_loop_unlock_children</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_next_parent_locked</NAME>
<RETURNS>AgsPortableThread * </RETURNS>
AgsPortableThread *thread, AgsPortableThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_next_sibling_locked</NAME>
<RETURNS>AgsPortableThread * </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_next_children_locked</NAME>
<RETURNS>AgsPortableThread * </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_lock_parent</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread, AgsPortableThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_lock_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_lock_children</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_lock_all</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_unlock_parent</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread, AgsPortableThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_unlock_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_unlock_children</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_unlock_all</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_wait_parent</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread, AgsPortableThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_wait_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_wait_children</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_signal_parent</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread, AgsPortableThread *parent, gboolean broadcast 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_signal_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread, gboolean broadcast 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_signal_children</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread, gboolean broadcast 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_start</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_run</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_timelock</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_stop</NAME>
<RETURNS>void  </RETURNS>
AgsPortableThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_portable_thread_new</NAME>
<RETURNS>AgsPortableThread * </RETURNS>
GObject *data 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TASK_THREAD</NAME>
#define AGS_TYPE_TASK_THREAD                (ags_task_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TASK_THREAD</NAME>
#define AGS_TASK_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TASK_THREAD, AgsTaskThread))
</MACRO>
<MACRO>
<NAME>AGS_TASK_THREAD_CLASS</NAME>
#define AGS_TASK_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_TASK_THREAD, AgsTaskThread))
</MACRO>
<MACRO>
<NAME>AGS_IS_TASK_THREAD</NAME>
#define AGS_IS_TASK_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_TASK_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_TASK_THREAD_CLASS</NAME>
#define AGS_IS_TASK_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_TASK_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_TASK_THREAD_GET_CLASS</NAME>
#define AGS_TASK_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_TASK_THREAD, AgsTaskThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_TASK_THREAD_DEFAULT_JIFFIE</NAME>
#define AGS_TASK_THREAD_DEFAULT_JIFFIE (1000)
</MACRO>
<STRUCT>
<NAME>AgsTaskThread</NAME>
struct _AgsTaskThread
{
  AgsThread thread;

  guint flags;

  GMutex mutex;
  GCond cond;

  pthread_mutex_t read_mutex;
  pthread_mutex_t launch_mutex;

  volatile guint queued;
  volatile guint pending;

  volatile GList *exec;
  volatile GList *queue;
};
</STRUCT>
<STRUCT>
<NAME>AgsTaskThreadClass</NAME>
struct _AgsTaskThreadClass
{
  AgsThreadClass thread;
};
</STRUCT>
<STRUCT>
<NAME>AgsTaskThreadAppend</NAME>
struct _AgsTaskThreadAppend
{
  volatile AgsTaskThread *task_thread;
  volatile gpointer data;
};
</STRUCT>
<FUNCTION>
<NAME>ags_task_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_task_thread_append_task</NAME>
<RETURNS>void  </RETURNS>
AgsTaskThread *task_thread, AgsTask *task 
</FUNCTION>
<FUNCTION>
<NAME>ags_task_thread_append_tasks</NAME>
<RETURNS>void  </RETURNS>
AgsTaskThread *task_thread, GList *list 
</FUNCTION>
<FUNCTION>
<NAME>ags_task_thread_new</NAME>
<RETURNS>AgsTaskThread * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_TASK</NAME>
#define AGS_TYPE_TASK                (ags_task_get_type())
</MACRO>
<MACRO>
<NAME>AGS_TASK</NAME>
#define AGS_TASK(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_TASK, AgsTask))
</MACRO>
<MACRO>
<NAME>AGS_TASK_CLASS</NAME>
#define AGS_TASK_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_TASK, AgsTaskClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_TASK</NAME>
#define AGS_IS_TASK(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_TASK))
</MACRO>
<MACRO>
<NAME>AGS_IS_TASK_CLASS</NAME>
#define AGS_IS_TASK_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_TASK))
</MACRO>
<MACRO>
<NAME>AGS_TASK_GET_CLASS</NAME>
#define AGS_TASK_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_TASK, AgsTaskClass)))
</MACRO>
<ENUM>
<NAME>AgsTaskFlags</NAME>
typedef enum{
  AGS_TASK_LOCKED = 1,
}AgsTaskFlags;
</ENUM>
<STRUCT>
<NAME>AgsTask</NAME>
struct _AgsTask
{
  GObject object;

  guint flags;

  char *name;

  guint delay;

  pthread_cond_t wait_sync_task_cond;
};
</STRUCT>
<STRUCT>
<NAME>AgsTaskClass</NAME>
struct _AgsTaskClass
{
  GObjectClass object;

  void (*launch)(AgsTask *task);

  void (*failure)(AgsTask *task, GError *error);
};
</STRUCT>
<FUNCTION>
<NAME>ags_task_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_task_launch</NAME>
<RETURNS>void  </RETURNS>
AgsTask *task 
</FUNCTION>
<FUNCTION>
<NAME>ags_task_failure</NAME>
<RETURNS>void  </RETURNS>
AgsTask *task, GError *error 
</FUNCTION>
<FUNCTION>
<NAME>ags_task_new</NAME>
<RETURNS>AgsTask * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_THREAD_APPLICATION_CONTEXT</NAME>
#define AGS_TYPE_THREAD_APPLICATION_CONTEXT                (ags_thread_application_context_get_type())
</MACRO>
<MACRO>
<NAME>AGS_THREAD_APPLICATION_CONTEXT</NAME>
#define AGS_THREAD_APPLICATION_CONTEXT(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_THREAD_APPLICATION_CONTEXT, AgsThreadApplicationContext))
</MACRO>
<MACRO>
<NAME>AGS_THREAD_APPLICATION_CONTEXT_CLASS</NAME>
#define AGS_THREAD_APPLICATION_CONTEXT_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_THREAD_APPLICATION_CONTEXT, AgsThreadApplicationContextClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_THREAD_APPLICATION_CONTEXT</NAME>
#define AGS_IS_THREAD_APPLICATION_CONTEXT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_THREAD_APPLICATION_CONTEXT))
</MACRO>
<MACRO>
<NAME>AGS_IS_THREAD_APPLICATION_CONTEXT_CLASS</NAME>
#define AGS_IS_THREAD_APPLICATION_CONTEXT_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_THREAD_APPLICATION_CONTEXT))
</MACRO>
<MACRO>
<NAME>AGS_THREAD_APPLICATION_CONTEXT_GET_CLASS</NAME>
#define AGS_THREAD_APPLICATION_CONTEXT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_THREAD_APPLICATION_CONTEXT, AgsThreadApplicationContextClass))
</MACRO>
<MACRO>
<NAME>AGS_THREAD_BUILD_ID</NAME>
#define AGS_THREAD_BUILD_ID "Thu Apr  2 13:04:21 GMT 2015\0"
</MACRO>
<MACRO>
<NAME>AGS_THREAD_DEFAULT_VERSION</NAME>
#define AGS_THREAD_DEFAULT_VERSION "0.4.3\0"
</MACRO>
<ENUM>
<NAME>AgsThreadApplicationContextFlags</NAME>
typedef enum{
  AGS_THREAD_APPLICATION_CONTEXT_SINGLE_THREAD      = 1,
}AgsThreadApplicationContextFlags;
</ENUM>
<STRUCT>
<NAME>AgsThreadApplicationContext</NAME>
struct _AgsThreadApplicationContext
{
  AgsApplicationContextClass application_contex;

  guint flags;

  AgsThread *main_loop;
  AgsThread *autosave_thread;
  AgsThreadPool *thread_pool;
};
</STRUCT>
<STRUCT>
<NAME>AgsThreadApplicationContextClass</NAME>
struct _AgsThreadApplicationContextClass
{
  AgsApplicationContextClass application_contex;
};
</STRUCT>
<FUNCTION>
<NAME>ags_thread_application_context_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_application_context_new</NAME>
<RETURNS>AgsThreadApplicationContext * </RETURNS>
AgsMainLoop *main_loop, AgsConfig *config 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_MUTEX_MANAGER</NAME>
#define AGS_TYPE_MUTEX_MANAGER                (ags_mutex_manager_get_type())
</MACRO>
<MACRO>
<NAME>AGS_MUTEX_MANAGER</NAME>
#define AGS_MUTEX_MANAGER(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_MUTEX_MANAGER, AgsMutexManager))
</MACRO>
<MACRO>
<NAME>AGS_MUTEX_MANAGER_CLASS</NAME>
#define AGS_MUTEX_MANAGER_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_MUTEX_MANAGER, AgsMutexManagerClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTEX_MANAGER</NAME>
#define AGS_IS_MUTEX_MANAGER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_MUTEX_MANAGER))
</MACRO>
<MACRO>
<NAME>AGS_IS_MUTEX_MANAGER_CLASS</NAME>
#define AGS_IS_MUTEX_MANAGER_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_MUTEX_MANAGER))
</MACRO>
<MACRO>
<NAME>AGS_MUTEX_MANAGER_GET_CLASS</NAME>
#define AGS_MUTEX_MANAGER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_MUTEX_MANAGER, AgsMutexManagerClass))
</MACRO>
<STRUCT>
<NAME>AgsMutexManager</NAME>
struct _AgsMutexManager
{
  GObject object;

  GHashTable *lock_object;
};
</STRUCT>
<STRUCT>
<NAME>AgsMutexManagerClass</NAME>
struct _AgsMutexManagerClass
{
  GObjectClass object;
};
</STRUCT>
<FUNCTION>
<NAME>ags_mutex_manager_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_mutex_manager_insert</NAME>
<RETURNS>gboolean  </RETURNS>
AgsMutexManager *mutex_manager, GObject *lock_object, pthread_mutex_t *mutex 
</FUNCTION>
<FUNCTION>
<NAME>ags_mutex_manager_remove</NAME>
<RETURNS>gboolean  </RETURNS>
AgsMutexManager *mutex_manager, GObject *lock_object 
</FUNCTION>
<FUNCTION>
<NAME>ags_mutex_manager_lookup</NAME>
<RETURNS>pthread_mutex_t * </RETURNS>
AgsMutexManager *mutex_manager, GObject *lock_object 
</FUNCTION>
<FUNCTION>
<NAME>ags_mutex_manager_get_instance</NAME>
<RETURNS>AgsMutexManager * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_mutex_manager_new</NAME>
<RETURNS>AgsMutexManager * </RETURNS>
 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_RETURNABLE_THREAD</NAME>
#define AGS_TYPE_RETURNABLE_THREAD                (ags_returnable_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_RETURNABLE_THREAD</NAME>
#define AGS_RETURNABLE_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_RETURNABLE_THREAD, AgsReturnableThread))
</MACRO>
<MACRO>
<NAME>AGS_RETURNABLE_THREAD_CLASS</NAME>
#define AGS_RETURNABLE_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_RETURNABLE_THREAD, AgsReturnableThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_RETURNABLE_THREAD</NAME>
#define AGS_IS_RETURNABLE_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_RETURNABLE_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_RETURNABLE_THREAD_CLASS</NAME>
#define AGS_IS_RETURNABLE_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_RETURNABLE_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_RETURNABLE_THREAD_GET_CLASS</NAME>
#define AGS_RETURNABLE_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_RETURNABLE_THREAD, AgsReturnableThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_RETURNABLE_THREAD_DEFAULT_JIFFIE</NAME>
#define AGS_RETURNABLE_THREAD_DEFAULT_JIFFIE (1000)
</MACRO>
<USER_FUNCTION>
<NAME>AgsReturnableThreadCallback</NAME>
<RETURNS>void </RETURNS>
AgsReturnableThread *returnable_thread, gpointer data
</USER_FUNCTION>
<ENUM>
<NAME>AgsReturnableThreadFlags</NAME>
typedef enum{
  AGS_RETURNABLE_THREAD_IN_USE              = 1,
  AGS_RETURNABLE_THREAD_RESET               = 1 << 1,
}AgsReturnableThreadFlags;
</ENUM>
<STRUCT>
<NAME>AgsReturnableThread</NAME>
struct _AgsReturnableThread
{
  AgsThread thread;

  volatile guint flags;

  GObject *thread_pool;

  pthread_mutex_t reset_mutex;
  volatile void *safe_data;

  gulong handler;
};
</STRUCT>
<STRUCT>
<NAME>AgsReturnableThreadClass</NAME>
struct _AgsReturnableThreadClass
{
  AgsThreadClass thread;

  void (*safe_run)(AgsReturnableThread *returnable_thread);
};
</STRUCT>
<FUNCTION>
<NAME>ags_returnable_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_returnable_thread_safe_run</NAME>
<RETURNS>void  </RETURNS>
AgsReturnableThread *returnable_thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_returnable_thread_connect_safe_run</NAME>
<RETURNS>void  </RETURNS>
AgsReturnableThread *returnable_thread, AgsReturnableThreadCallback callback 
</FUNCTION>
<FUNCTION>
<NAME>ags_returnable_thread_disconnect_safe_run</NAME>
<RETURNS>void  </RETURNS>
AgsReturnableThread *returnable_thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_returnable_thread_new</NAME>
<RETURNS>AgsReturnableThread * </RETURNS>
GObject *thread_pool 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_THREAD</NAME>
#define AGS_TYPE_THREAD                (ags_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_THREAD</NAME>
#define AGS_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_THREAD, AgsThread))
</MACRO>
<MACRO>
<NAME>AGS_THREAD_CLASS</NAME>
#define AGS_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_THREAD, AgsThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_THREAD</NAME>
#define AGS_IS_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_THREAD_CLASS</NAME>
#define AGS_IS_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_THREAD_GET_CLASS</NAME>
#define AGS_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_THREAD, AgsThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_ACCOUNTING_TABLE</NAME>
#define AGS_ACCOUNTING_TABLE(ptr) ((AgsAccountingTable *)(ptr))
</MACRO>
<MACRO>
<NAME>MSEC_PER_SEC</NAME>
#define MSEC_PER_SEC    (1000000) /* The number of msecs per sec. */
</MACRO>
<MACRO>
<NAME>NSEC_PER_SEC</NAME>
#define NSEC_PER_SEC    (1000000000) /* The number of nsecs per sec. */
</MACRO>
<MACRO>
<NAME>AGS_THREAD_RESUME_SIG</NAME>
#define AGS_THREAD_RESUME_SIG SIGUSR2
</MACRO>
<MACRO>
<NAME>AGS_THREAD_SUSPEND_SIG</NAME>
#define AGS_THREAD_SUSPEND_SIG SIGUSR1
</MACRO>
<MACRO>
<NAME>AGS_THREAD_DEFAULT_JIFFIE</NAME>
#define AGS_THREAD_DEFAULT_JIFFIE (250)
</MACRO>
<MACRO>
<NAME>AGS_THREAD_MAX_PRECISION</NAME>
#define AGS_THREAD_MAX_PRECISION (1000)
</MACRO>
<MACRO>
<NAME>AGS_THREAD_DEFAULT_ATTACK</NAME>
#define AGS_THREAD_DEFAULT_ATTACK (1.0)
</MACRO>
<ENUM>
<NAME>AgsThreadFlags</NAME>
typedef enum{
  AGS_THREAD_RUNNING                 = 1,
  AGS_THREAD_IDLE                    = 1 << 1,
  AGS_THREAD_LOCKED                  = 1 << 2,
  AGS_THREAD_WAIT_FOR_PARENT         = 1 << 3,
  AGS_THREAD_WAIT_FOR_SIBLING        = 1 << 4,
  AGS_THREAD_WAIT_FOR_CHILDREN       = 1 << 5,
  AGS_THREAD_WAIT_FOR_BARRIER        = 1 << 6,
  AGS_THREAD_WAITING_FOR_PARENT      = 1 << 7,
  AGS_THREAD_WAITING_FOR_SIBLING     = 1 << 8,
  AGS_THREAD_WAITING_FOR_CHILDREN    = 1 << 9,
  AGS_THREAD_WAITING_FOR_BARRIER     = 1 << 10,
  AGS_THREAD_BROADCAST_PARENT        = 1 << 11,
  AGS_THREAD_BROADCAST_SIBLING       = 1 << 12,
  AGS_THREAD_BROADCAST_CHILDREN      = 1 << 13,
  AGS_THREAD_INITIAL_RUN             = 1 << 14,
  AGS_THREAD_TREE_SYNC_0             = 1 << 15,
  AGS_THREAD_WAIT_0                  = 1 << 16,
  AGS_THREAD_TREE_SYNC_1             = 1 << 17,
  AGS_THREAD_WAIT_1                  = 1 << 18,
  AGS_THREAD_TREE_SYNC_2             = 1 << 19,
  AGS_THREAD_WAIT_2                  = 1 << 20,
  AGS_THREAD_TIMELOCK_RUN            = 1 << 21,
  AGS_THREAD_TIMELOCK_WAIT           = 1 << 22,
  AGS_THREAD_TIMELOCK_RESUME         = 1 << 23,
  /*
   * prefered way would be unlocking greedy_locks
   * and the suspend to not become greedy
   * but while pthread_suspend and pthread_resume
   * are missing you need this as work-around
   */
  AGS_THREAD_SKIP_NON_GREEDY         = 1 << 24,
  AGS_THREAD_SKIPPED_BY_TIMELOCK     = 1 << 25,
  AGS_THREAD_LOCK_GREEDY_RUN_MUTEX   = 1 << 26,
  AGS_THREAD_SUSPENDED               = 1 << 27,
  AGS_THREAD_SINGLE_LOOP             = 1 << 28,
  AGS_THREAD_READY                   = 1 << 29,
  AGS_THREAD_UNREF_ON_EXIT           = 1 << 30,
  AGS_THREAD_CONNECTED               = 1 << 31,
}AgsThreadFlags;
</ENUM>
<STRUCT>
<NAME>AgsThread</NAME>
struct _AgsThread
{
  GObject object;

  volatile guint flags;

  sigset_t wait_mask;

  pthread_t *thread;
  pthread_attr_t thread_attr;

  gdouble freq;

  pthread_mutex_t *mutex;
  pthread_mutexattr_t mutexattr;
  pthread_cond_t *cond;

  pthread_mutex_t *start_mutex;
  pthread_cond_t *start_cond;

  pthread_barrier_t **barrier;
  gboolean first_barrier;
  int wait_count[2];

  pthread_t timelock_thread;
  pthread_mutex_t *timelock_mutex;
  pthread_cond_t *timelock_cond;

  pthread_mutex_t *greedy_mutex;
  pthread_cond_t *greedy_cond;
  pthread_mutex_t *greedy_run_mutex;
  volatile guint locked_greedy;

  struct timespec timelock;
  GList *greedy_locks;

  pthread_mutex_t *suspend_mutex;
  volatile gboolean critical_region;

  AgsThread *parent;

  AgsThread *next;
  AgsThread *prev;

  AgsThread *children;

  gpointer data;
};
</STRUCT>
<STRUCT>
<NAME>AgsThreadClass</NAME>
struct _AgsThreadClass
{
  GObjectClass object;

  void (*start)(AgsThread *thread);
  void (*run)(AgsThread *thread);
  void (*suspend)(AgsThread *thread);
  void (*resume)(AgsThread *thread);
  void (*timelock)(AgsThread *thread);
  void (*stop)(AgsThread *thread);
};
</STRUCT>
<STRUCT>
<NAME>AgsAccountingTable</NAME>
struct _AgsAccountingTable
{
  AgsThread *thread;
  gdouble sanity;
};
</STRUCT>
<FUNCTION>
<NAME>ags_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_accounting_table_alloc</NAME>
<RETURNS>AgsAccountingTable * </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_accounting_table_set_sanity</NAME>
<RETURNS>void  </RETURNS>
GList *table, AgsThread *thread, gdouble sanity 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_set_sync</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, guint tic 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_set_sync_all</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, guint tic 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_lock</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_trylock</NAME>
<RETURNS>gboolean  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_unlock</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_get_toplevel</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_first</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_last</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_remove_child</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, AgsThread *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_add_child</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, AgsThread *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_parental_is_locked</NAME>
<RETURNS>gboolean  </RETURNS>
AgsThread *thread, AgsThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_sibling_is_locked</NAME>
<RETURNS>gboolean  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_children_is_locked</NAME>
<RETURNS>gboolean  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_is_current_ready</NAME>
<RETURNS>gboolean  </RETURNS>
AgsThread *current, guint tic 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_is_tree_ready</NAME>
<RETURNS>gboolean  </RETURNS>
AgsThread *thread, guint tic 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_next_parent_locked</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread, AgsThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_next_sibling_locked</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_next_children_locked</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_lock_parent</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, AgsThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_lock_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_lock_children</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_lock_all</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_unlock_parent</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, AgsThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_unlock_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_unlock_children</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_unlock_all</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_wait_parent</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, AgsThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_wait_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_wait_children</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_signal_parent</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, AgsThread *parent, gboolean broadcast 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_signal_sibling</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, gboolean broadcast 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_signal_children</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread, gboolean broadcast 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_start</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_run</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_suspend</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_resume</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_timelock</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_stop</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_hangcheck</NAME>
<RETURNS>void  </RETURNS>
AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_find_type</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThread *thread, GType type 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_new</NAME>
<RETURNS>AgsThread * </RETURNS>
gpointer data 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_AUTOSAVE_THREAD</NAME>
#define AGS_TYPE_AUTOSAVE_THREAD                (ags_autosave_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_AUTOSAVE_THREAD</NAME>
#define AGS_AUTOSAVE_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_AUTOSAVE_THREAD, AgsAutosaveThread))
</MACRO>
<MACRO>
<NAME>AGS_AUTOSAVE_THREAD_CLASS</NAME>
#define AGS_AUTOSAVE_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_AUTOSAVE_THREAD, AgsAutosaveThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUTOSAVE_THREAD</NAME>
#define AGS_IS_AUTOSAVE_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_AUTOSAVE_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_AUTOSAVE_THREAD_CLASS</NAME>
#define AGS_IS_AUTOSAVE_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_AUTOSAVE_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_AUTOSAVE_THREAD_GET_CLASS</NAME>
#define AGS_AUTOSAVE_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_AUTOSAVE_THREAD, AgsAutosaveThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_AUTOSAVE_THREAD_DEFAULT_JIFFIE</NAME>
#define AGS_AUTOSAVE_THREAD_DEFAULT_JIFFIE (0.2)
</MACRO>
<MACRO>
<NAME>AGS_AUTOSAVE_THREAD_DEFAULT_FILENAME</NAME>
#define AGS_AUTOSAVE_THREAD_DEFAULT_FILENAME "ags-autosaved.xml\0"
</MACRO>
<STRUCT>
<NAME>AgsAutosaveThread</NAME>
struct _AgsAutosaveThread
{
  AgsThread thread;

  volatile guint tic;
  volatile guint last_sync;

  GObject *application_context;

  guint delay;
  guint counter;
};
</STRUCT>
<STRUCT>
<NAME>AgsAutosaveThreadClass</NAME>
struct _AgsAutosaveThreadClass
{
  AgsThreadClass thread;
};
</STRUCT>
<FUNCTION>
<NAME>ags_autosave_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_autosave_thread_new</NAME>
<RETURNS>AgsAutosaveThread * </RETURNS>
GObject *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_CONCURRENCY_PROVIDER</NAME>
#define AGS_TYPE_CONCURRENCY_PROVIDER                    (ags_concurrency_provider_get_type())
</MACRO>
<MACRO>
<NAME>AGS_CONCURRENCY_PROVIDER</NAME>
#define AGS_CONCURRENCY_PROVIDER(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_CONCURRENCY_PROVIDER, AgsConcurrencyProvider))
</MACRO>
<MACRO>
<NAME>AGS_CONCURRENCY_PROVIDER_INTERFACE</NAME>
#define AGS_CONCURRENCY_PROVIDER_INTERFACE(vtable)       (G_TYPE_CHECK_CLASS_CAST((vtable), AGS_TYPE_CONCURRENCY_PROVIDER, AgsConcurrencyProviderInterface))
</MACRO>
<MACRO>
<NAME>AGS_IS_CONCURRENCY_PROVIDER</NAME>
#define AGS_IS_CONCURRENCY_PROVIDER(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_CONCURRENCY_PROVIDER))
</MACRO>
<MACRO>
<NAME>AGS_IS_CONCURRENCY_PROVIDER_INTERFACE</NAME>
#define AGS_IS_CONCURRENCY_PROVIDER_INTERFACE(vtable)    (G_TYPE_CHECK_CLASS_TYPE((vtable), AGS_TYPE_CONCURRENCY_PROVIDER))
</MACRO>
<MACRO>
<NAME>AGS_CONCURRENCY_PROVIDER_GET_INTERFACE</NAME>
#define AGS_CONCURRENCY_PROVIDER_GET_INTERFACE(obj)      (G_TYPE_INSTANCE_GET_INTERFACE((obj), AGS_TYPE_CONCURRENCY_PROVIDER, AgsConcurrencyProviderInterface))
</MACRO>
<TYPEDEF>
<NAME>AgsConcurrencyProvider</NAME>
typedef void AgsConcurrencyProvider;
</TYPEDEF>
<STRUCT>
<NAME>AgsConcurrencyProviderInterface</NAME>
struct _AgsConcurrencyProviderInterface
{
  GTypeInterface interface;

  AgsThread* (*get_main_loop)(AgsConcurrencyProvider *concurrency_provider);
  AgsThread* (*get_task_thread)(AgsConcurrencyProvider *concurrency_provider);
  AgsThreadPool* (*get_thread_pool)(AgsConcurrencyProvider *concurrency_provider);
};
</STRUCT>
<FUNCTION>
<NAME>ags_concurrency_provider_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_concurrency_provider_get_main_loop</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsConcurrencyProvider *concurrency_provider 
</FUNCTION>
<FUNCTION>
<NAME>ags_concurrency_provider_get_task_thread</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsConcurrencyProvider *concurrency_provider 
</FUNCTION>
<FUNCTION>
<NAME>ags_concurrency_provider_get_thread_pool</NAME>
<RETURNS>AgsThreadPool * </RETURNS>
AgsConcurrencyProvider *concurrency_provider 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_THREAD_POOL</NAME>
#define AGS_TYPE_THREAD_POOL                (ags_thread_pool_get_type())
</MACRO>
<MACRO>
<NAME>AGS_THREAD_POOL</NAME>
#define AGS_THREAD_POOL(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_THREAD_POOL, AgsThreadPool))
</MACRO>
<MACRO>
<NAME>AGS_THREAD_POOL_CLASS</NAME>
#define AGS_THREAD_POOL_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_THREAD_POOL, AgsThreadPoolClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_THREAD_POOL</NAME>
#define AGS_IS_THREAD_POOL(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_THREAD_POOL))
</MACRO>
<MACRO>
<NAME>AGS_IS_THREAD_POOL_CLASS</NAME>
#define AGS_IS_THREAD_POOL_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_THREAD_POOL))
</MACRO>
<MACRO>
<NAME>AGS_THREAD_POOL_GET_CLASS</NAME>
#define AGS_THREAD_POOL_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_THREAD_POOL, AgsThreadPoolClass))
</MACRO>
<ENUM>
<NAME>AgsThreadPoolFlags</NAME>
typedef enum{
  AGS_THREAD_POOL_RUNNING  = 1,
  AGS_THREAD_POOL_READY    = 1 << 1,
}AgsThreadPoolFlags;
</ENUM>
<STRUCT>
<NAME>AgsThreadPool</NAME>
struct _AgsThreadPool
{
  GObject object;

  volatile guint flags;

  volatile guint max_unused_threads;
  volatile guint max_threads;

  pthread_t thread;

  pthread_mutex_t creation_mutex;
  pthread_cond_t creation_cond;

  volatile guint n_threads;
  volatile guint newly_pulled;
  volatile guint queued;

  AgsThread *parent;
  volatile GList *returnable_thread;
  volatile GList *running_thread;

  pthread_mutex_t pull_mutex;

  pthread_mutex_t return_mutex;
  pthread_cond_t return_cond;
};
</STRUCT>
<STRUCT>
<NAME>AgsThreadPoolClass</NAME>
struct _AgsThreadPoolClass
{
  GObjectClass object;

  void (*start)(AgsThreadPool *thread_pool);
};
</STRUCT>
<FUNCTION>
<NAME>ags_thread_pool_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_pool_pull</NAME>
<RETURNS>AgsThread * </RETURNS>
AgsThreadPool *thread_pool 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_pool_start</NAME>
<RETURNS>void  </RETURNS>
AgsThreadPool *thread_pool 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_pool_new</NAME>
<RETURNS>AgsThreadPool * </RETURNS>
AgsThread *parent 
</FUNCTION>
<FUNCTION>
<NAME>ags_thread_init_context</NAME>
<RETURNS>void  </RETURNS>
AgsApplicationContext *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_START_THREAD</NAME>
#define AGS_TYPE_START_THREAD                (ags_start_thread_get_type())
</MACRO>
<MACRO>
<NAME>AGS_START_THREAD</NAME>
#define AGS_START_THREAD(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_START_THREAD, AgsStartThread))
</MACRO>
<MACRO>
<NAME>AGS_START_THREAD_CLASS</NAME>
#define AGS_START_THREAD_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_START_THREAD, AgsStartThreadClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_START_THREAD</NAME>
#define AGS_IS_START_THREAD(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_START_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_IS_START_THREAD_CLASS</NAME>
#define AGS_IS_START_THREAD_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_START_THREAD))
</MACRO>
<MACRO>
<NAME>AGS_START_THREAD_GET_CLASS</NAME>
#define AGS_START_THREAD_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_START_THREAD, AgsStartThreadClass))
</MACRO>
<STRUCT>
<NAME>AgsStartThread</NAME>
struct _AgsStartThread
{
  AgsTask task;

  AgsThread *parent;
  AgsThread *child;
};
</STRUCT>
<STRUCT>
<NAME>AgsStartThreadClass</NAME>
struct _AgsStartThreadClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_start_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_start_thread_new</NAME>
<RETURNS>AgsStartThread * </RETURNS>
AgsThread *parent, AgsThread *child 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_thread</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsThread **thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_thread</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsThread *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_thread_list</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, GList **thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_thread_list</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, GList *thread 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_thread_pool</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsThreadPool **thread_pool 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_thread_pool</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsThreadPool *thread_pool 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_read_main_loop</NAME>
<RETURNS>void  </RETURNS>
AgsFile *file, xmlNode *node, AgsThread *main_loop 
</FUNCTION>
<FUNCTION>
<NAME>ags_file_write_main_loop</NAME>
<RETURNS>xmlNode * </RETURNS>
AgsFile *file, xmlNode *parent, AgsThread *main_loop 
</FUNCTION>
<FUNCTION>
<NAME>ags_id_generator_create_uuid</NAME>
<RETURNS>gchar * </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>j_math_or</NAME>
<RETURNS>int  </RETURNS>
int a, int b 
</FUNCTION>
<FUNCTION>
<NAME>j_math_exclusive_or</NAME>
<RETURNS>int  </RETURNS>
int a, int b 
</FUNCTION>
<FUNCTION>
<NAME>j_math_and</NAME>
<RETURNS>int  </RETURNS>
int a, int b 
</FUNCTION>
<FUNCTION>
<NAME>j_math_more</NAME>
<RETURNS>jboolean  </RETURNS>
int a, int b 
</FUNCTION>
<FUNCTION>
<NAME>j_math_less</NAME>
<RETURNS>jboolean  </RETURNS>
int a, int b 
</FUNCTION>
<FUNCTION>
<NAME>j_math_sort_array</NAME>
<RETURNS>int * </RETURNS>
int *array, int size 
</FUNCTION>
<FUNCTION>
<NAME>j_math_put_null_at_beginning</NAME>
<RETURNS>void  </RETURNS>
int *array, uint size 
</FUNCTION>
<FUNCTION>
<NAME>j_math_put_null_at_end</NAME>
<RETURNS>void  </RETURNS>
int *array, uint size 
</FUNCTION>
<FUNCTION>
<NAME>j_math_width</NAME>
<RETURNS>uint  </RETURNS>
int a 
</FUNCTION>
<FUNCTION>
<NAME>j_math_width_list</NAME>
<RETURNS>JList * </RETURNS>
JList *list 
</FUNCTION>
<FUNCTION>
<NAME>j_math_cut_leading_zeros</NAME>
<RETURNS>JList * </RETURNS>
JList *value 
</FUNCTION>
<FUNCTION>
<NAME>j_math_exp2</NAME>
<RETURNS>int  </RETURNS>
int a 
</FUNCTION>
<FUNCTION>
<NAME>j_math_exp</NAME>
<RETURNS>int  </RETURNS>
int a, int b 
</FUNCTION>
<FUNCTION>
<NAME>j_math_root2</NAME>
<RETURNS>int  </RETURNS>
int a 
</FUNCTION>
<FUNCTION>
<NAME>j_math_root</NAME>
<RETURNS>int  </RETURNS>
int a, int b 
</FUNCTION>
<FUNCTION>
<NAME>j_math_make_valid</NAME>
<RETURNS>void  </RETURNS>
char *string 
</FUNCTION>
<FUNCTION>
<NAME>j_math_is_operator</NAME>
<RETURNS>jboolean  </RETURNS>
char *string 
</FUNCTION>
<FUNCTION>
<NAME>j_math_is_function</NAME>
<RETURNS>jboolean  </RETURNS>
char *string 
</FUNCTION>
<FUNCTION>
<NAME>j_math_is_function_backward</NAME>
<RETURNS>jboolean  </RETURNS>
char *start, char *string 
</FUNCTION>
<FUNCTION>
<NAME>j_math_get_first_level_operator</NAME>
<RETURNS>char * </RETURNS>
char *string 
</FUNCTION>
<FUNCTION>
<NAME>j_math_get_second_level_operator</NAME>
<RETURNS>char * </RETURNS>
char *string 
</FUNCTION>
<FUNCTION>
<NAME>j_math_solve_arithmetic</NAME>
<RETURNS>int  </RETURNS>
char *string 
</FUNCTION>
<FUNCTION>
<NAME>j_math_algebra_brackeds_out</NAME>
<RETURNS>char * </RETURNS>
char *string 
</FUNCTION>
<FUNCTION>
<NAME>j_math_algebra_operations_out</NAME>
<RETURNS>char * </RETURNS>
char *string 
</FUNCTION>
<FUNCTION>
<NAME>j_math_algebra_functions_out</NAME>
<RETURNS>char * </RETURNS>
char *string 
</FUNCTION>
<FUNCTION>
<NAME>j_math_algebra_solve</NAME>
<RETURNS>int * </RETURNS>
char *string, char *operation 
</FUNCTION>
<FUNCTION>
<NAME>j_math_gauss</NAME>
<RETURNS>int * </RETURNS>
char **string, uint count 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LOG</NAME>
#define AGS_TYPE_LOG                (ags_log_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LOG</NAME>
#define AGS_LOG(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LOG, AgsLog))
</MACRO>
<MACRO>
<NAME>AGS_LOG_CLASS</NAME>
#define AGS_LOG_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST(class, AGS_TYPE_LOG, AgsLog))
</MACRO>
<MACRO>
<NAME>AGS_IS_LOG</NAME>
#define AGS_IS_LOG(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), AGS_TYPE_LOG))
</MACRO>
<MACRO>
<NAME>AGS_IS_LOG_CLASS</NAME>
#define AGS_IS_LOG_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE ((class), AGS_TYPE_LOG))
</MACRO>
<MACRO>
<NAME>AGS_LOG_GET_CLASS</NAME>
#define AGS_LOG_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS(obj, AGS_TYPE_LOG, AgsLogClass))
</MACRO>
<MACRO>
<NAME>AGS_LOG_MESSAGE</NAME>
#define AGS_LOG_MESSAGE(ptr) ((AgsLogMessage *)(ptr))
</MACRO>
<MACRO>
<NAME>AGS_LOG_FORMATED_MESSAGE</NAME>
#define AGS_LOG_FORMATED_MESSAGE(ptr) ((AgsLogFormatedMessage *)(ptr))
</MACRO>
<MACRO>
<NAME>AGS_LOG_MESSAGE_LENGTH</NAME>
#define AGS_LOG_MESSAGE_LENGTH (4096)
</MACRO>
<MACRO>
<NAME>AGS_LOG_MESSAGE_DATE_LENGTH</NAME>
#define AGS_LOG_MESSAGE_DATE_LENGTH (19)
</MACRO>
<ENUM>
<NAME>AgsLogFLags</NAME>
typedef enum{
  AGS_LOG_TRACK     = 1,
}AgsLogFLags;
</ENUM>
<ENUM>
<NAME>AgsLogMode</NAME>
typedef enum{
  AGS_LOG_DEBUG      = 1,
  AGS_LOG_MESSAGE    = 1 << 1,
  AGS_LOG_WARN       = 1 << 2,
  AGS_LOG_ERROR      = 1 << 3,
}AgsLogMode;
</ENUM>
<STRUCT>
<NAME>AgsLog</NAME>
struct _AgsLog
{
  GObject object;

  guint flags;
  guint mode;
  
  GObject *application_context;
  pthread_mutex_t *application_mutex;
  
  FILE *file;

  pthread_mutex_t *mutex;
  
  volatile guint queued;
  volatile guint pending;
  
  volatile GList *queued_formated_message;
  volatile GList *formated_message;
  
  GList *log;
};
</STRUCT>
<STRUCT>
<NAME>AgsLogClass</NAME>
struct _AgsLogClass
{
  GObjectClass object;
};
</STRUCT>
<STRUCT>
<NAME>AgsLogMessage</NAME>
struct _AgsLogMessage
{
  guint mode;
  
  struct timespec *timestamp;
  char *format;
  va_list *args;
};
</STRUCT>
<STRUCT>
<NAME>AgsLogFormatedMessage</NAME>
struct _AgsLogFormatedMessage
{
  guint length;
  char *message;
};
</STRUCT>
<FUNCTION>
<NAME>ags_log_message_alloc</NAME>
<RETURNS>AgsLogMessage * </RETURNS>
struct timespec *timestamp, char *format, va_list *args 
</FUNCTION>
<FUNCTION>
<NAME>ags_log_message_free</NAME>
<RETURNS>void  </RETURNS>
AgsLogMessage *log_message 
</FUNCTION>
<FUNCTION>
<NAME>ags_log_formated_message_alloc</NAME>
<RETURNS>AgsLogFormatedMessage * </RETURNS>
guint length, char *message 
</FUNCTION>
<FUNCTION>
<NAME>ags_log_formated_message_free</NAME>
<RETURNS>void  </RETURNS>
AgsLogFormatedMessage *formated_message 
</FUNCTION>
<FUNCTION>
<NAME>ags_log_debug</NAME>
<RETURNS>void  </RETURNS>
AgsLog *log, char *format, ... 
</FUNCTION>
<FUNCTION>
<NAME>ags_log_message</NAME>
<RETURNS>void  </RETURNS>
AgsLog *log, char *format, ... 
</FUNCTION>
<FUNCTION>
<NAME>ags_log_warn</NAME>
<RETURNS>void  </RETURNS>
AgsLog *log, char *format, ... 
</FUNCTION>
<FUNCTION>
<NAME>ags_log_error</NAME>
<RETURNS>void  </RETURNS>
AgsLog *log, char *format, ... 
</FUNCTION>
<FUNCTION>
<NAME>ags_log_add_queue</NAME>
<RETURNS>void  </RETURNS>
AgsLog *log, AgsLogMessage *log_message 
</FUNCTION>
<FUNCTION>
<NAME>ags_log_output</NAME>
<RETURNS>void  </RETURNS>
AgsLog *log, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>ags_log_new</NAME>
<RETURNS>AgsLog * </RETURNS>
GObject *application_context 
</FUNCTION>
<MACRO>
<NAME>AGS_TYPE_LOG_TASK</NAME>
#define AGS_TYPE_LOG_TASK                (ags_log_task_get_type())
</MACRO>
<MACRO>
<NAME>AGS_LOG_TASK</NAME>
#define AGS_LOG_TASK(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj), AGS_TYPE_LOG_TASK, AgsLogTask))
</MACRO>
<MACRO>
<NAME>AGS_LOG_TASK_CLASS</NAME>
#define AGS_LOG_TASK_CLASS(class)        (G_TYPE_CHECK_CLASS_CAST((class), AGS_TYPE_LOG_TASK, AgsLogTaskClass))
</MACRO>
<MACRO>
<NAME>AGS_IS_LOG_TASK</NAME>
#define AGS_IS_LOG_TASK(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj), AGS_TYPE_LOG_TASK))
</MACRO>
<MACRO>
<NAME>AGS_IS_LOG_TASK_CLASS</NAME>
#define AGS_IS_LOG_TASK_CLASS(class)     (G_TYPE_CHECK_CLASS_TYPE((class), AGS_TYPE_LOG_TASK))
</MACRO>
<MACRO>
<NAME>AGS_LOG_TASK_GET_CLASS</NAME>
#define AGS_LOG_TASK_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS((obj), AGS_TYPE_LOG_TASK, AgsLogTaskClass))
</MACRO>
<STRUCT>
<NAME>AgsLogTask</NAME>
struct _AgsLogTask
{
  AgsTask task;

  AgsLog *log;
  AgsLogMessage *log_message;
};
</STRUCT>
<STRUCT>
<NAME>AgsLogTaskClass</NAME>
struct _AgsLogTaskClass
{
  AgsTaskClass task;
};
</STRUCT>
<FUNCTION>
<NAME>ags_log_task_get_type</NAME>
<RETURNS>GType  </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>ags_log_task_new</NAME>
<RETURNS>AgsLogTask * </RETURNS>
AgsLog *log, AgsLogMessage *log_message 
</FUNCTION>
